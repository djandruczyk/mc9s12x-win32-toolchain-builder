#!/bin/bash
# Making mc9s12x Crosstools for windows from linux:
#
# David J. Andruczyk, 2010
#
# This REQUIRES that you have dpkg-dev,texinfo mingw32, mingw32-binutils and 
# mingw32-runtime installed and working. (preferrable from the vendor
# repos and not from source as the paths will be different breaking '
# the cross/uncross cripts)
#

# ADJUST THIS TO SUIT
# NOTE: you'll also need to edit mc9s12x-toolchain.iss to suite your 
# wine configuration and target paths, if you use "all" or "buildpkg"

#set -x

CWD=$(pwd)
PROCS=`cat /proc/cpuinfo |grep -c ^processor`
BINUTILS_URI="http://ftp.gnu.org/gnu/binutils/"
BINUTILS_TAR=binutils-2.24.tar.bz2
BINUTILS_DIR="binutils-2.24"
BINUTILS_PATCH="tc-m68hc11.patch"
GCC_DIR="s12x-gcc"
GCC_GIT_BRANCH="tmp-for-dave"
GCC_GIT_URL="http://git.libreems.org/libreems-suite/s12x-gcc.git"
NEWLIB_DIR="s12x-newlib"
NEWLIB_GIT_URL="http://git.libreems.org/libreems-suite/s12x-newlib.git"

SRCDIR="${CWD}/sources"
PATCH_DIR="${CWD}/patches"

HOST_ARCH=`uname -m`

function warn_user {
echo ""
echo $*
echo ""
exit -1
}

if [ $# -ne 2 ] ; then
	warn_user "Invalid args, need <32|64> <all|get_pre_reqs|buildpkg|clean|realclean>"
else
    if [ "$1" -eq 32 -o "$1" -eq 64 ] ; then
        BITS=$1
        BUILDDIR="${CWD}/build${BITS}"
		DSTDIR="${CWD}/toolchain${BITS}"
		if [ "$1" -eq 32 ] ; then
			HOST="i686"
		fi
		if [ "$1" -eq 64 ] ; then
			HOST="x86_64"
		fi
        echo "Arch chosen is $1"
    else
        echo "Invalid args, expected [32|64] for 32 or 64 bit"
        exit -1
    fi
fi

# Additonal Packages needed to be added..
#PKGS="gawk-3.1.6-1-bin.zip bc-1.06-2-bin.zip bc-1.06-2-dep.zip coreutils-5.3.0-bin.zip coreutils-5.3.0-dep.zip make-3.81-bin.zip zlib-1.2.3-bin.zip libintl-0.14.4-bin.zip which-2.20-bin.zip"
PKGS="gawk-3.1.6-1-bin.zip bc-1.06-2-bin.zip bc-1.06-2-dep.zip coreutils-5.3.0-bin.zip coreutils-5.3.0-dep.zip make-3.81-bin.zip libintl-0.14.4-bin.zip which-2.20-bin.zip"


function setup {
if [ ! -d "${BUILDDIR}" ] ; then
	mkdir "${BUILDDIR}"
fi
if [ ! -d "${SRCDIR}" ] ; then
	mkdir "${SRCDIR}"
fi
mkdir -p "${SRCDIR}/support"
date +%Y-%m-%d >${CWD}/BSTAMP
}

function build_s12x_binutils_direct {
pushd "${BUILDDIR}" >/dev/null
# Make sure we don't have cross vars set to begin with
. uncross
# Setup crosscompile env vars:
# First: build binutils for 9s12x
if [ -f mc9s12x-direct-build/GOOD ] ; then
	return 0
fi
if [ -d mc9s12x-direct-build ] ; then
	rm -rf mc9s12x-direct-build
fi
mkdir mc9s12x-direct-build 
pushd mc9s12x-direct-build >/dev/null
# GCC needs a direct linux->m68hc11 assembler for its canadian cross
# intermediary compiler, so we need to build binutils twice, once for 
# Linux->m68hc11, and once as a crossbuild win32->m68hc11
# First linux->m68hc11
"${SRCDIR}"/"${BINUTILS_DIR}"/configure --target=m68hc11 --enable-targets=m68hc11,m68hc12,xgate --program-prefix=mc9s12x- --disable-nls --prefix="${DSTDIR}"/intermediary && \
CFLAGS+=-g make -j${PROCS} && \
make install && \
for i in addr2line ar as c++filt elfedit gprof ld.bfd ld nm objcopy objdump ranlib readelf size strings strip ; do \
	ln -s mc9s12x-$i "${DSTDIR}"/intermediary/bin/m68hc11-$i
done && \
popd >/dev/null && \
popd >/dev/null
if [ $? -eq 0 ]; then
	touch "${BUILDDIR}"/mc9s12x-direct-build/GOOD
	return 0
else
	return $?
fi
}

function build_s12x_binutils_cross {
# Now enable cross compile env vars and build the windows binaries
pushd "${BUILDDIR}" >/dev/null
if [ -f mc9s12x-cross-build/GOOD ] ; then
	return 0
fi
if [ -d mc9s12x-cross-build ] ; then
	rm -rf mc9s12x-cross-build
fi
mkdir mc9s12x-cross-build 
pushd mc9s12x-cross-build >/dev/null
. cross"${BITS}"
"${SRCDIR}"/"${BINUTILS_DIR}"/configure --build="${HOST_ARCH}"-pc-linux-gnu --host="${HOST}"-w"${BITS}"-mingw32  --target=m68hc11 --enable-targets=m68hc11,m68hc12,xgate --disable-nls  --program-prefix=mc9s12x- --prefix="${DSTDIR}" && \
make -j${PROCS} && \
make install && \
for i in addr2line ar as c++filt elfedit gprof ld.bfd ld nm objcopy objdump ranlib readelf size strings strip ; do \
	ln -s mc9s12x-$i.exe "${DSTDIR}"/bin/m68hc11-$i.exe
	ln -s mc9s12x-$i.exe "${DSTDIR}"/bin/m68hc12-$i.exe
done && \
popd >/dev/null && \
popd >/dev/null
. uncross
if [ $? -eq 0 ]; then
	touch "${BUILDDIR}"/mc9s12x-cross-build/GOOD
	return 0
else
	return $?
fi
}

function build_xgate_binutils_cross {
# Make Xgate version, no need to make intermediary for xgate as there is NOT
# yet a GCC for xgate
pushd "${BUILDDIR}" >/dev/null
if [ -f xgate-cross-build/GOOD ] ; then
	return 0
fi
if [ -d xgate-cross-build ] ; then
	rm -rf xgate-cross-build
fi
mkdir xgate-cross-build
pushd xgate-cross-build >/dev/null
. cross"${BITS}"
"${SRCDIR}"/"${BINUTILS_DIR}"/configure --build="${HOST_ARCH}"-pc-linux-gnu --host="${HOST}"-w"${BITS}"-mingw32 --target=xgate --enable-targets=m68hc11,m68hc12,xgate --program-prefix=xgate- --disable-nls --prefix="${DSTDIR}" && \
make -j${PROCS} && \
make install && \
. uncross \
popd >/dev/null && \
popd >/dev/null 
if [ $? -eq 0 ]; then
	touch "${BUILDDIR}"/xgate-cross-build/GOOD
	return 0
else
	return $?
fi
}

function build_intermediary_gcc {
pushd "${BUILDDIR}" >/dev/null
if [ -f gcc-intermediary-build/GOOD ] ; then
	return 0
fi
if [ -d gcc-intermediary-build ] ; then
	rm -rf gcc-intermediary-build
fi
mkdir gcc-intermediary-build
pushd gcc-intermediary-build >/dev/null
OLDPATH=$PATH
export PATH=$DSTDIR/intermediary/bin:$PATH
# GCC needs to be done twice.  Once as a native linux->m68hc11 compiler, and 
# then as a cross compiled win32->m68hc11 compiler, which depends on the 
# intermediary one being present, so build that one first
"${SRCDIR}"/"${GCC_DIR}"/src/configure --target=m68hc11 --program-prefix=mc9s12x- --disable-nls --with-gnu-as --with-gnu-ld --disable-checking --without-headers --enable-languages=c --prefix="${DSTDIR}"/intermediary && \
make -j${PROCS} &&
make install && \
mv "${DSTDIR}"/intermediary/bin/m68hc11-gcc "${DSTDIR}"/intermediary/bin/mc9s12x-gcc
mv "${DSTDIR}"/intermediary/bin/m68hc11-cpp "${DSTDIR}"/intermediary/bin/mc9s12x-cpp
for i in gcc cpp gcov gccbug ; do \
	ln -s mc9s12x-$i "${DSTDIR}"/intermediary/bin/m68hc11-$i
	ln -s mc9s12x-$i "${DSTDIR}"/intermediary/bin/m68hc12-$i
done && \
rm -f "${DSTDIR}"/intermediary/bin/m68hc11-gcc-3.3.6*
export PATH=$OLDPATH && \
popd >/dev/null && \
popd >/dev/null 
if [ $? -eq 0 ]; then
	touch "${BUILDDIR}"/gcc-intermediary-build/GOOD
	return 0
else
	return $?
fi
}

function build_cross_gcc {
pushd "${BUILDDIR}" >/dev/null
. cross"${BITS}"
if [ -f gcc-cross-build/GOOD ] ; then
	return 0
fi
if [ -d gcc-cross-build ] ; then
	rm -rf gcc-cross-build
fi
mkdir gcc-cross-build
pushd gcc-cross-build >/dev/null
# GCC needs to be done twice.  Once as a native linux->m68hc11 compiler, and 
# then as a cross compiled win32->m68hc11 compiler, which depends on the 
# intermediary one being present, so build that one first
OLDPATH=$PATH
export PATH=$DSTDIR/intermediary/bin:$PATH
"${SRCDIR}"/"${GCC_DIR}"/src/configure --build="${HOST_ARCH}"-pc-linux-gnu --host="${HOST}"-w"${BITS}"-mingw32 --target=m68hc11 --program-prefix=mc9s12x- --disable-nls  --without-headers --with-gnu-as --with-gnu-ld --disable-checking --enable-languages=c  --prefix="${DSTDIR}" && \
# FIX BUG in gcc 3.3.6 regarding canadian crosses
pushd "${HOST_ARCH}"-pc-linux-gnu >/dev/null && \
ln -sf "${SRCDIR}"/"${GCC_DIR}"/src/include/ && \
popd >/dev/null  && \
make -j${PROCS} && \
make install && \
if [ -f "${DSTDIR}"/bin/m68hc11-gcc.exe ] ; then
	mv "${DSTDIR}"/bin/m68hc11-gcc.exe "${DSTDIR}"/bin/mc9s12x-gcc.exe
fi
if [ -f "${DSTDIR}"/bin/m68hc11-cpp.exe ] ; then
	mv "${DSTDIR}"/bin/m68hc11-cpp.exe "${DSTDIR}"/bin/mc9s12x-cpp.exe
fi
if [ -f "${DSTDIR}"/bin/m68hc11-gcc-3.3.6-* ] ; then
	rm -f "${DSTDIR}"/bin/m68hc11-gcc-3.3.6-*
fi
for i in cpp gcc gccbug gcov ; do \
	ln -s mc9s12x-$i.exe "${DSTDIR}"/bin/m68hc11-$i.exe
	ln -s mc9s12x-$i.exe "${DSTDIR}"/bin/m68hc12-$i.exe
done && \
export PATH="${OLDPATH}" && \
popd >/dev/null && \
. uncross && \
popd >/dev/null
if [ $? -eq 0 ]; then
	touch "${BUILDDIR}"/gcc-cross-build/GOOD
	return 0
else
	return $?
fi
}

function build_direct_newlib {
#Now newlib
#RESET ENV VARS back to normal, as newlib sets things up its own way
pushd "${BUILDDIR}" >/dev/null
. uncross
if [ -f newlib-build/GOOD ] ; then
	return 0
fi
if [ -d newlib-build ] ; then
	rm -rf newlib-build
fi
OLDPATH="${PATH}"
export PATH="${DSTDIR}"/intermediary/bin:"${PATH}"
echo "Path is $PATH"
mkdir newlib-build
pushd newlib-build >/dev/null && \
"${SRCDIR}"/"${NEWLIB_DIR}"/src/configure --build="${HOST_ARCH}"-pc-linux-gnu --target=m68hc11 --disable-multilib --disable-shared --disable-threads --disable-nls --prefix="$DSTDIR" && \
make -j${PROCS} && \
make install && \
export PATH="${OLDPATH}" && \
popd >/dev/null && \
popd >/dev/null
if [ $? -eq 0 ]; then
	touch "${BUILDDIR}"/newlib-build/GOOD
	return 0
else
	return $?
fi
}


function build_toolchain {
# Make a clean TARGET location to stick everything
if [ ! -d "${DSTDIR}" ]; then
	mkdir "${DSTDIR}"
else
	echo "${DSTDIR} ALREADY EXISTS, this may not be what you want!!!"
	sleep 5
fi
echo "Target is ${DSTDIR}"	
build_s12x_binutils_direct
res=$?
binutils_direct_hcs12x_res=$res
if [ $res -ne 0 ] ; then
	warn_user $(printf "\b\nFailure directly compiling hcs12x binutils, result code %i\n" $res)
fi
build_s12x_binutils_cross
res=$?
binutils_cross_hcs12x_res=$res
if [ $res -ne 0 ] ; then
	warn_user $(printf "\b\nFailure cross compiling hcs12x binutils, result code %i\n" $res)
fi
build_xgate_binutils_cross
res=$?
binutils_cross_xgate_res=$res
if [ $res -ne 0 ] ; then
	warn_user $(printf "\b\nFailure cross compiling xgate binutils, result code %i\n" $res)
fi

build_intermediary_gcc
res=$?
gcc_direct_res=$?
if [ $res -ne 0 ] ; then
	warn_user $(printf "\b\nFailure direct compiling intermediary GCC for canadian cross, result code %i\n" $res)
fi

build_cross_gcc
res=$?
gcc_cross_res=$?
if [ $res -ne 0 ] ; then
	warn_user $(printf "\b\nFailure cross compiling GCC, result code %i\n" $res)
fi

build_direct_newlib
res=$?
newlib_direct_res=$?
if [ $res -ne 0 ] ; then
	warn_user $(printf "\b\nFailure direct compiling newlib, result code %i\n" $res)
fi

echo "
	Compilation Results:
	Direct Binutils Linux->hc11: $binutils_direct_hcs12x_res
	Cross Binutils Win32->hc11:  $binutils_cross_hcs12x_res
	Cross Binutils Win32->xgate: $binutils_cross_xgate_res
	Direct GCC Linux->hc11:      $gcc_direct_res
	Cross GCC Win32->hc11:       $gcc_cross_res
	Direct Newlib Linux->hc11:   $newlib_direct_res

		"

if [ $binutils_direct_hcs12x_res -eq 0 ] && \
	[ $binutils_cross_hcs12x_res -eq 0 ] && \
	[ $binutils_cross_xgate_res -eq 0 ] && \
	[ $gcc_direct_res -eq 0 ] && \
	[ $gcc_cross_res -eq 0 ] && \
	[ $newlib_direct_res -eq 0 ] ; then
	echo "Everything compiled OK, installing prepackaged windows binaries"
	add_win32_pkgs
fi
}

function cleanup {
	echo "Cleaning out build directories"
	clean_binutils
	clean_gcc
	clean_newlib
#clean_dest
	echo "All build dirs cleaned out"
}

function full_cleanup {
	echo "Cleaning out sources and build directories"
	clean_binutils
	clean_gcc
	clean_newlib
	clean_zips
	clean_gcc_sources
	clean_newlib_sources
	clean_binutils_sources
	clean_dest
	rm -f "${CWD}"/mc9s12x-toolchain.iss
	rm -f "${CWD}"/BSTAMP
	echo "All source and build dirs cleaned out"
}

function download_win32 {
pushd "${SRCDIR}/support" >/dev/null
echo "Downloading windows binaries from sourceforge"
wget -cnv http://downloads.sourceforge.net/project/gnuwin32/gawk/3.1.6-1/gawk-3.1.6-1-bin.zip -O gawk-3.1.6-1-bin.zip
wget -cnv http://downloads.sourceforge.net/project/gnuwin32/bc/1.06-2/bc-1.06-2-bin.zip -O bc-1.06-2-bin.zip
wget -cnv http://downloads.sourceforge.net/project/gnuwin32/bc/1.06-2/bc-1.06-2-dep.zip -O bc-1.06-2-dep.zip
wget -cnv http://downloads.sourceforge.net/project/gnuwin32/zlib/1.2.3/zlib-1.2.3-bin.zip -O zlib-1.2.3-bin.zip
wget -cnv http://downloads.sourceforge.net/project/gnuwin32/coreutils/5.3.0/coreutils-5.3.0-bin.zip -O coreutils-5.3.0-bin.zip
wget -cnv http://downloads.sourceforge.net/project/gnuwin32/coreutils/5.3.0/coreutils-5.3.0-dep.zip -O coreutils-5.3.0-dep.zip
wget -cnv http://downloads.sourceforge.net/project/gnuwin32/libintl/0.14.4/libintl-0.14.4-bin.zip -O libintl-0.14.4-bin.zip
wget -cnv http://downloads.sourceforge.net/project/gnuwin32/make/3.81/make-3.81-bin.zip -O make-3.81-bin.zip
wget -cnv http://downloads.sourceforge.net/project/gnuwin32/which/2.20/which-2.20-bin.zip -O which-2.20-bin.zip
echo "Complete!"
popd >/dev/null
}

function clean_binutils {
pushd "${BUILDDIR}" >/dev/null
if [ -d mc9s12x-direct-build ] ; then
	rm -rf mc9s12x-direct-build
fi
if [ -d mc9s12x-cross-build ] ; then
	rm -rf mc9s12x-cross-build
fi
if [ -d xgate-cross-build ] ; then
	rm -rf xgate-cross-build
fi
popd >/dev/null
}

function clean_binutils_sources {
pushd "${SRCDIR}" >/dev/null
rm -rf "${BINUTILS_DIR}"
popd >/dev/null
}

function dl_binutils {
# checkout seank's FreeScale-s12x-binutils
pushd "${SRCDIR}" >/dev/null
md5sum --status -c "${BINUTILS_TAR}".md5
RESULT=$?
if [ ${RESULT} -ne 0 ] ; then
	echo "Aquiring binutils"
	wget -c  "${BINUTILS_URI}"/"${BINUTILS_TAR}" -O "${BINUTILS_TAR}"
fi && \
if [ ! -d "${BINUTILS_DIR}" ] ; then
	tar xvf "${BINUTILS_TAR}" && \
	pushd "${BINUTILS_DIR}" >/dev/null && \
	patch -p1 < "${PATCH_DIR}"/"${BINUTILS_PATCH}" &&\
	popd >/dev/null 
fi && \
popd >/dev/null 
}

function clean_gcc {
pushd "${BUILDDIR}" >/dev/null
rm -rf gcc-*
if [ -d gcc-intermediary-build ] ; then
	rm -rf gcc-intermediary-build
fi
if [ -d gcc-cross-build ] ; then
	rm -rf gcc-cross-build
fi
popd >/dev/null
}

function clean_gcc_sources {
# checkout seank's repo for gcc
pushd "${SRCDIR}" >/dev/null
rm -rf gcc-*
rm -rf "${GCC_DIR}"
popd >/dev/null
}

function dl_gcc {
pushd "${SRCDIR}" >/dev/null
if [ -d "${GCC_DIR}" ] ; then
	pushd "${GCC_DIR}" >/dev/null
	git pull
	popd >/dev/null
elif [ ! -d "${GCC_DIR}" ] ; then
	echo "Downloading GCC from seank's repo"
    git clone -b "${GCC_GIT_BRANCH}" "${GCC_GIT_URL}" "${GCC_DIR}"
#	pushd FreeScale-s12x-gcc-patched >/dev/null
#	patch -p0 < "${CWD}"/patches/gcc-win32.patch
#	patch -p1 < "${CWD}"/patches/regex_c.patch
#	patch -p1 < "${CWD}"/patches/config.gcc.patch
	popd >/dev/null
fi
popd >/dev/null
}

function clean_newlib {
pushd "${BUILDDIR}" >/dev/null
# I used the sources from newlib-m68hc1x from ubuntu/debian
if [ -d newlib-build ] ; then
	rm -rf newlib-build
fi
popd >/dev/null
}

function clean_newlib_sources {
pushd "${SRCDIR}" >/dev/null
	rm -rf "${NEWLIB_DIR}"
popd >/dev/null
}

function clean_dest {
rm -rf "${DSTDIR}"
}

function dl_newlib {
pushd "${SRCDIR}" >/dev/null
if [ ! -d "${NEWLIB_DIR}" ] ; then
    git clone "${NEWLIB_GIT_URL}" "${NEWLIB_DIR}"
else
	pushd "${NEWLIB_DIR}" >/dev/null
	git pull
	popd >/dev/null
fi
popd >/dev/null
}

function clean_zips {
rm -f "${BUILDDIR}"/support/*.zip
}

function add_win32_pkgs {
pushd "${DSTDIR}" >/dev/null
for pkg in `echo ${PKGS}` ; do
	unzip -o "${SRCDIR}"/support/"${pkg}"
done
rm -rf contrib manifest
popd >/dev/null
}

function build_win32_pkg {
pushd "${CWD}" >/dev/null
if [ -f mc9s12x-toolchain.iss ] ; then
	rm -f mc9s12x-toolchain.iss
fi
DEST=$(echo "${DSTDIR}" |sed -e 's/\//\\\\/g')
BSTAMP=$(cat "${CWD}"/BSTAMP)
MICRO=$(cat "${CWD}"/MICRO)
sed -e s,_DSTDIR_,"${DEST}",g  -e s,_BSTAMP_,"${BSTAMP}",g -e s,_MICRO_,"${MICRO}",g < mc9s12x-toolchain${BITS}.iss.in > mc9s12x-toolchain${BITS}.iss
ISS_FILE="${CWD}"/mc9s12x-toolchain${BITS}.iss

iscc "${ISS_FILE}"
mv "${CWD}"/Output/setup.exe "${CWD}"/Output/mc9s12x-ToolChain_win${BITS}_"${BSTAMP}"."${MICRO}".exe
popd >/dev/null
}

function done_all {
	echo "

				ALL DONE!!!
mc9s12x-ToolChain_win${BITS}_$(cat ${CWD}/BSTAMP).$(cat ${CWD}/MICRO).exe should be in the ${CWD}/Output Directory
	
"
}

case "$2" in
	all) 
	setup
	dl_binutils
	dl_gcc
	dl_newlib
	#download_win32
	build_toolchain 
	add_win32_pkgs
	build_win32_pkg
	done_all
	;;
	compile)
	build_toolchain
	;;
	get_pre_reqs)
	setup
	dl_binutils
	dl_gcc
	dl_newlib
	download_win32
	;;
	get_binutils)
	dl_binutils
	;;
	get_gcc)
	dl_gcc
	;;
	get_newlib)
	dl_newlib
	;;
	buildpkg)
	#download_win32
	add_win32_pkgs
	build_win32_pkg
	;;
	clean)
	cleanup
	;;
	realclean)
	full_cleanup
	;;
	*)
	warn_user "Invalid args, need <32|64> <all|get_pre_reqs|buildpkg|clean|realclean>"
	;;
esac
