#!/bin/bash
# Making mc9s12x Crosstools for windows from linux:
#
# David J. Andruczyk, 2010
#
# This REQUIRES that you have dpkg-dev,texinfo mingw32, mingw32-binutils and 
# mingw32-runtime installed and working. (preferrable from the vendor
# repos and not from source as the paths will be different breaking '
# the cross/uncross cripts)
#

# ADJUST THIS TO SUIT
# NOTE: you'll also need to edit mc9s12x-toolchain.iss to suite your 
# wine configuration and target paths, if you use "all" or "buildpkg"

CWD=$(pwd)
PROCS=5

DSTDIR=${CWD}/toolchain
BUILDDIR=${CWD}/build
SRCDIR=${CWD}/sources
# Global variable for 32/64 bit
if test `uname -m` = "x86_64" ; then 
	BITS=64
else
	BITS=32
fi

# Additonal Packages needed to be added..
PKGS="bc-1.06-2-bin.zip bc-1.06-2-dep.zip coreutils-5.3.0-bin.zip coreutils-5.3.0-dep.zip make-3.81-bin.zip zlib-1.2.3-bin.zip libintl-0.14.4-bin.zip which-2.20-bin.zip"


function setup {
if [ ! -d "${BUILDDIR}" ] ; then
	mkdir "${BUILDDIR}"
fi
if [ ! -d "${SRCDIR}" ] ; then
	mkdir "${SRCDIR}"
fi
mkdir -p "${SRCDIR}/support"
}

function build_s12x_binutils_direct {
pushd "${BUILDDIR}" >/dev/null
# Make sure we don't have cross vars set to begin with
. uncross
# Setup crosscompile env vars:
# First: build binutils for 9s12x
if [ -f mc9s12x-direct-build/GOOD ] ; then
	return 0
fi
if [ -d mc9s12x-direct-build ] ; then
	rm -rf mc9s12x-direct-build
fi
mkdir mc9s12x-direct-build 
pushd mc9s12x-direct-build >/dev/null
# GCC needs a direct linux->m68hc11 assembler for its canadian cross
# intermediary compiler, so we need to build binutils twice, once for 
# Linux->m68hc11, and once as a crossbuild win32->m68hc11
# First linux->m68hc11
"${SRCDIR}"/FreeScale-s12x-binutils/configure --target=m68hc11 --enable-targets=m68hc11,m68hc12,xgate --program-prefix=m68hc11- --disable-nls --prefix="${DSTDIR}"/intermediary && \
CFLAGS+=-g make -j${PROCS} && \
make install && \
popd >/dev/null && \
popd >/dev/null
if [ $? -eq 0 ]; then
	touch "${BUILDDIR}"/mc9s12x-direct-build/GOOD
	return 0
else
	return $?
fi
}

function build_s12x_binutils_cross {
# Now enable cross compile env vars and build the windows binaries
pushd "${BUILDDIR}" >/dev/null
if [ -f mc9s12x-cross-build/GOOD ] ; then
	return 0
fi
if [ -d mc9s12x-cross-build ] ; then
	rm -rf mc9s12x-cross-build
fi
mkdir mc9s12x-cross-build 
pushd mc9s12x-cross-build >/dev/null
. cross"${BITS}"
"${SRCDIR}"/FreeScale-s12x-binutils/configure --build=i686-pc-linux-gnu --host=i686-w"${BITS}"-mingw32  --target=m68hc11 --enable-targets=m68hc11,m68hc12,xgate --disable-nls  --program-prefix=m68hc11- --prefix="${DSTDIR}" && \
make -j${PROCS} && \
make install && \
popd >/dev/null && \
popd >/dev/null
. uncross
if [ $? -eq 0 ]; then
	touch "${BUILDDIR}"/mc9s12x-cross-build/GOOD
	return 0
else
	return $?
fi
}

function build_xgate_binutils_cross {
# Make Xgate version, no need to make intermediary for xgate as there is NOT
# yet a GCC for xgate
pushd "${BUILDDIR}" >/dev/null
if [ -f xgate-cross-build/GOOD ] ; then
	return 0
fi
if [ -d xgate-cross-build ] ; then
	rm -rf xgate-cross-build
fi
mkdir xgate-cross-build
pushd xgate-cross-build >/dev/null
. cross"${BITS}"
"${SRCDIR}"/FreeScale-s12x-binutils/configure --build=i686-pc-linux-gnu --host=i686-w"${BITS}"-mingw32 --target=xgate --enable-targets=xgate --program-prefix=xgate- --disable-nls --prefix="${DSTDIR}" && \
make -j${PROCS} && \
make install && \
. uncross \
popd >/dev/null && \
popd >/dev/null 
if [ $? -eq 0 ]; then
	touch "${BUILDDIR}"/xgate-cross-build/GOOD
	return 0
else
	return $?
fi
}

function build_intermediary_gcc {
pushd "${BUILDDIR}" >/dev/null
if [ -f gcc-intermediary-build/GOOD ] ; then
	return 0
fi
if [ -d gcc-intermediary-build ] ; then
	rm -rf gcc-intermediary-build
fi
mkdir gcc-intermediary-build
pushd gcc-intermediary-build >/dev/null
OLDPATH=$PATH
export PATH=$DSTDIR/intermediary/bin:$PATH
# GCC needs to be done twice.  Once as a native linux->m68hc11 compiler, and 
# then as a cross compiled win32->m68hc11 compiler, which depends on the 
# intermediary one being present, so build that one first
"${SRCDIR}"/FreeScale-s12x-gcc-patched/src/configure --target=m68hc11 --program-prefix=m68hc11- --disable-nls --with-gnu-as --with-gnu-ld --disable-checking --without-headers --enable-languages=c --prefix="${DSTDIR}"/intermediary && \
make -j${PROCS} &&
make install && \
export PATH=$OLDPATH && \
popd >/dev/null && \
popd >/dev/null 
if [ $? -eq 0 ]; then
	touch "${BUILDDIR}"/gcc-intermediary-build/GOOD
	return 0
else
	return $?
fi
}


function build_cross_gcc {
pushd "${BUILDDIR}" >/dev/null
. cross"${BITS}"
if [ -f gcc-cross-build/GOOD ] ; then
	return 0
fi
if [ -d gcc-cross-build ] ; then
	rm -rf gcc-cross-build
fi
mkdir gcc-cross-build
pushd gcc-cross-build >/dev/null
# GCC needs to be done twice.  Once as a native linux->m68hc11 compiler, and 
# then as a cross compiled win32->m68hc11 compiler, which depends on the 
# intermediary one being present, so build that one first
OLDPATH=$PATH
export PATH=$DSTDIR/intermediary/bin:$PATH
"${SRCDIR}"/FreeScale-s12x-gcc-patched/src/configure --build=i686-pc-linux-gnu --host=i686-w"${BITS}"-mingw32 --disable-multilib --target=m68hc11 --program-prefix=m68hc11- --disable-nls  --without-headers --with-gnu-as --with-gnu-ld --disable-checking --enable-languages=c  --prefix="${DSTDIR}" && \
# FIX BUG in gcc 3.3.6 regarding canadian crosses
pushd i686-pc-linux-gnu >/dev/null && \
ln -sf "${SRCDIR}"/FreeScale-s12x-gcc-patched/src/include/ && \
popd >/dev/null  && \
make -j${PROCS} && \
make install && \
export PATH="${OLDPATH}" && \
popd >/dev/null && \
. uncross && \
popd >/dev/null
if [ $? -eq 0 ]; then
	touch "${BUILDDIR}"/gcc-cross-build/GOOD
	return 0
else
	return $?
fi
}

function build_direct_newlib {
#Now newlib
#RESET ENV VARS back to normal, as newlib sets things up its own way
pushd "${BUILDDIR}" >/dev/null
. uncross
if [ -f newlib-build/GOOD ] ; then
	return 0
fi
if [ -d newlib-build ] ; then
	rm -rf newlib-build
fi
OLDPATH="${PATH}"
export PATH="${DSTDIR}"/intermediary/bin:"${PATH}"
echo "Path is $PATH"
mkdir newlib-build
pushd newlib-build >/dev/null && \
"${SRCDIR}"/FreeScale-s12x-newlib/src/configure --build=i686-pc-linux-gnu --target=m68hc11 --disable-multilib --disable-shared --disable-threads --disable-nls --prefix="$DSTDIR" && \
make -j${PROCS} && \
make install && \
export PATH="${OLDPATH}" && \
popd >/dev/null && \
popd >/dev/null
if [ $? -eq 0 ]; then
	touch "${BUILDDIR}"/newlib-build/GOOD
	return 0
else
	return $?
fi
}


function build_toolchain {
# Make a clean TARGET location to stick everything
if [ ! -d "${DSTDIR}" ]; then
	mkdir "${DSTDIR}"
else
	echo "${DSTDIR} ALREADY EXISTS, this may not be what you want!!!"
	sleep 5
fi
echo "Target is ${DSTDIR}"	
build_s12x_binutils_direct
res=$?
binutils_direct_hcs12x_res=$res
if [ $res -ne 0 ] ; then
	warn_user $(printf "\b\nFailure directly compiling hcs12x binutils, result code %i\n" $res)
fi
build_s12x_binutils_cross
res=$?
binutils_cross_hcs12x_res=$res
if [ $res -ne 0 ] ; then
	warn_user $(printf "\b\nFailure cross compiling hcs12x binutils, result code %i\n" $res)
fi
build_xgate_binutils_cross
res=$?
binutils_cross_xgate_res=$res
if [ $res -ne 0 ] ; then
	warn_user $(printf "\b\nFailure cross compiling xgate binutils, result code %i\n" $res)
fi

build_intermediary_gcc
res=$?
gcc_direct_res=$?
if [ $res -ne 0 ] ; then
	warn_user $(printf "\b\nFailure direct compiling intermediary GCC for canadian cross, result code %i\n" $res)
fi

build_cross_gcc
res=$?
gcc_cross_res=$?
if [ $res -ne 0 ] ; then
	warn_user $(printf "\b\nFailure cross compiling GCC, result code %i\n" $res)
fi

build_direct_newlib
res=$?
newlib_direct_res=$?
if [ $res -ne 0 ] ; then
	warn_user $(printf "\b\nFailure direct compiling newlib, result code %i\n" $res)
fi

echo "
	Compilation Results:
	Direct Binutils Linux->hc11: $binutils_direct_hcs12x_res
	Cross Binutils Win32->hc11:  $binutils_cross_hcs12x_res
	Cross Binutils Win32->xgate: $binutils_cross_xgate_res
	Direct GCC Linux->hc11:      $gcc_direct_res
	Cross GCC Win32->hc11:       $gcc_cross_res
	Direct Newlib Linux->hc11:   $newlib_direct_res

		"

if [ $binutils_direct_hcs12x_res -eq 0 ] && \
	[ $binutils_cross_hcs12x_res -eq 0 ] && \
	[ $binutils_cross_xgate_res -eq 0 ] && \
	[ $gcc_direct_res -eq 0 ] && \
	[ $gcc_cross_res -eq 0 ] && \
	[ $newlib_direct_res -eq 0 ] ; then
	echo "Everything compiled OK, installing prepackaged windows binaries"
	add_win32_pkgs
fi
}

function cleanup {
	echo "Cleaning out build directories"
	clean_binutils
	clean_gcc
	clean_newlib
#clean_dest
	echo "All build dirs cleaned out"
}

function full_cleanup {
	echo "Cleaning out sources and build directories"
	clean_binutils
	clean_gcc
	clean_newlib
	clean_zips
	clean_gcc_sources
	clean_newlib_sources
	clean_binutils_sources
	clean_dest
	rm -f "${CWD}"/mc9s12x-toolchain.iss
	rm -f "${CWD}"/BSTAMP
	echo "All source and build dirs cleaned out"
}

function download_win32 {
pushd "${SRCDIR}/support" >/dev/null
echo "Downloading windows binaries from sourceforge"
wget -cnv http://sourceforge.net/projects/gnuwin32/files/bc/1.06-2/bc-1.06-2-bin.zip/download -O bc-1.06-2-bin.zip
wget -cnv http://sourceforge.net/projects/gnuwin32/files/bc/1.06-2/bc-1.06-2-dep.zip/download -O bc-1.06-2-dep.zip
wget -cnv http://sourceforge.net/projects/gnuwin32/files/zlib/1.2.3/zlib-1.2.3-bin.zip/download -O zlib-1.2.3-bin.zip
wget -cnv http://sourceforge.net/projects/gnuwin32/files/coreutils/5.3.0/coreutils-5.3.0-bin.zip/download -O coreutils-5.3.0-bin.zip
wget -cnv http://sourceforge.net/projects/gnuwin32/files/coreutils/5.3.0/coreutils-5.3.0-dep.zip/download -O coreutils-5.3.0-dep.zip
wget -cnv http://sourceforge.net/projects/gnuwin32/files/libintl/0.14.4/libintl-0.14.4-bin.zip/download -O libintl-0.14.4-bin.zip
wget -cnv http://sourceforge.net/projects/gnuwin32/files/make/3.81/make-3.81-bin.zip/download -O make-3.81-bin.zip
wget -cnv http://sourceforge.net/projects/gnuwin32/files/which/2.20/which-2.20-bin.zip/download -O which-2.20-bin.zip
echo "Complete!"
popd >/dev/null
}

function clean_binutils {
pushd "${BUILDDIR}" >/dev/null
if [ -d mc9s12x-direct-build ] ; then
	rm -rf mc9s12x-direct-build
fi
if [ -d mc9s12x-cross-build ] ; then
	rm -rf mc9s12x-cross-build
fi
if [ -d xgate-cross-build ] ; then
	rm -rf xgate-cross-build
fi
popd >/dev/null
}

function clean_binutils_sources {
pushd "${SRCDIR}" >/dev/null
rm -rf FreeScale-s12x-binutils
popd >/dev/null
}

function dl_binutils {
# checkout seank's FreeScale-s12x-binutils
pushd "${SRCDIR}" >/dev/null
echo "Cloning binutils git tree locally"
if [ ! -d FreeScale-s12x-binutils ] ; then
	git clone http://github.com/seank/FreeScale-s12x-binutils.git 
else
	pushd FreeScale-s12x-binutils >/dev/null
	git pull
	popd >/dev/null
fi
pushd FreeScale-s12x-binutils >/dev/null
git log --date=short |grep Date |head -n1 |awk '{print $2}' > "$CWD/BSTAMP"
popd >/dev/null
popd >/dev/null
}

function clean_gcc {
pushd "${BUILDDIR}" >/dev/null
rm -rf gcc-*
if [ -d gcc-intermediary-build ] ; then
	rm -rf gcc-intermediary-build
fi
if [ -d gcc-cross-build ] ; then
	rm -rf gcc-cross-build
fi
popd >/dev/null
}

function clean_gcc_sources {
# checkout seank's repo for gcc
pushd "${SRCDIR}" >/dev/null
rm -rf gcc-*
rm -rf FreeScale-s12x-gcc*
popd >/dev/null
}

function dl_gcc {
pushd "${SRCDIR}" >/dev/null
if [ -d FreeScale-s12x-gcc-patched ] ; then
	pushd FreeScale-s12x-gcc-patched
	git pull
	popd
elif [ ! -d FreeScale-s12x-gcc ] ; then
	echo "Downloading GCC from seank's repo"
    git clone git://github.com/seank/FreeScale-s12x-gcc.git
	mv FreeScale-s12x-gcc FreeScale-s12x-gcc-patched
	pushd FreeScale-s12x-gcc-patched >/dev/null
	patch -p0 < "${CWD}"/patches/gcc-win32.patch
	patch -p1 < "${CWD}"/patches/regex_c.patch
	popd >/dev/null
fi
popd >/dev/null
}

function clean_newlib {
pushd "${BUILDDIR}" >/dev/null
# I used the sources from newlib-m68hc1x from ubuntu/debian
if [ -d newlib-build ] ; then
	rm -rf newlib-build
fi
popd >/dev/null
}

function clean_newlib_sources {
pushd "${SRCDIR}" >/dev/null
	rm -rf FreeScale-s12x-newlib
popd >/dev/null
}

function clean_dest {
rm -rf "${DSTDIR}"
}

function dl_newlib {
pushd "${SRCDIR}" >/dev/null
if [ ! -d FreeScale-s12x-newlib ] ; then
    git clone git://github.com/seank/FreeScale-s12x-newlib.git
else
	pushd FreeScale-s12x-newlib >/dev/null
	git pull
	popd >/dev/null
fi
popd >/dev/null
}

function clean_zips {
rm -f "${BUILDDIR}"/support/*.zip
}

function add_win32_pkgs {
pushd "${DSTDIR}" >/dev/null
for pkg in `echo ${PKGS}` ; do
	unzip -o "${BUILDDIR}"/support/"${pkg}"
done
rm -rf contrib manifest
popd >/dev/null
}

function build_win32_pkg {
pushd "${CWD}"
if [ -f mc9s12x-toolchain.iss ] ; then
	rm -f mc9s12x-toolchain.iss
fi
DEST=$(echo "${DSTDIR}" |sed -e 's/\//\\\\/g')
BSTAMP=$(cat "${CWD}"/BSTAMP)
MICRO=$(cat "${CWD}"/MICRO)
sed -e s,_DSTDIR_,"${DEST}",g  -e s,_BSTAMP_,"${BSTAMP}",g -e s,_MICRO_,"${MICRO}",g < mc9s12x-toolchain.iss.in > mc9s12x-toolchain.iss
ISS_FILE=dave/git/mc9s12x-win32-toolchain-builder/mc9s12x-toolchain.iss
DRIVE=L

wine ~/.wine/drive_c/Program\ Files/Inno\ Setup\ 5/ISCC.exe "${DRIVE}":/"${ISS_FILE}"
mv "${CWD}"/Output/setup.exe "${CWD}"/Output/mc9s12x-ToolChain_"${BSTAMP}"."${MICRO}".exe
popd >/dev/null
}

function warn_user {
echo ""
echo $*
echo ""
exit -1
}

function done_all {
	echo "

				ALL DONE!!!
mc9s12x-ToolChain_$(cat ${CWD}/BSTAMP).$(cat ${CWD}/MICRO).exe should be in the ${CWD}/Output Directory
	
"
}

if [ $# -ne 1 ] ; then
	warn_user "Invalid args, need <all|get_pre_reqs|buildpkg|clean|realclean>"
fi

case "$1" in
	all) 
	setup
	dl_binutils
	dl_gcc
	dl_newlib
	download_win32
	build_toolchain 
	add_win32_pkgs
	build_win32_pkg
	done_all
	;;
	compile)
	build_toolchain
	;;
	get_pre_reqs)
	setup
	dl_binutils
	dl_gcc
	dl_newlib
	download_win32
	;;
	get_binutils)
	dl_binutils
	;;
	get_gcc)
	dl_gcc
	;;
	get_newlib)
	dl_newlib
	;;
	buildpkg)
	download_win32
	add_win32_pkgs
	build_win32_pkg
	;;
	clean)
	cleanup
	;;
	realclean)
	full_cleanup
	;;
	*)
	warn_user "Invalid args, need <all|get_pre_reqs|buildpkg|clean|realclean>"
	;;
esac
