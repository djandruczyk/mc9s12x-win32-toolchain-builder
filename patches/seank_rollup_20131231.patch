This is a complete ROLLUP of all of seank's work on top of a "pristine" gcc-3.3.6 tree in an attempt to record all the changes unfortunatley not in a patch by patch basis...
--- /dev/null
+++ b/ChangeLog.M68HC11
@@ -0,0 +1,4 @@
+2003-05-18  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* configure.in (m68hc11): Configure libstdcxx_version.
+
--- a/configure
+++ b/configure
@@ -89,7 +89,7 @@
 target_alias=NOTARGET
 target_makefile_frag=
 undefs=NOUNDEFS
-version="$Revision: 1.49.4.1 $"
+version="$Revision: 1.1 $"
 x11=default
 bindir='${exec_prefix}/bin'
 sbindir='${exec_prefix}/sbin'
--- /dev/null
+++ b/gcc/ChangeLog.M68HC11
@@ -0,0 +1,384 @@
+2010-10-28 James Murray <jsm@jsm-net.demon.co.uk>
+    More work on 9s12x target building
+    S12X optimisations in larith.asm
+
+2010-10-26 James Murray <jsm@jsm-net.demon.co.uk>
+    Bump version
+    Include A.E.Smith S12X ldivmod.asm assembler long division
+    Port ldivmod.asm to S12
+    (Earlier work)
+    Support building as 9S12X target to match binutils
+
+2006-01-22  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* version.c: Bump to 2006-01-22
+
+2006-01-22  Stephane Carrez  <stcarrez@nerim.fr>
+
+        PR savannah/13917
+	* config/m68hc11/m68hc11.c (nonimmediate_noinc_operand): New predicate.
+	* config/m68hc11/m68hc11-protos.h (nonimmediate_noinc_operand): Declare.
+	* config/m68hc11/m68hc11.h (PREDICATE_CODES): Register it.
+	* config/m68hc11/m68hc11.md ("addqi3"): Use it for operand 0, 1.
+	("uminqi3"): Likewise.
+	("umaxqi3"): Likewise.
+	("uminhi3"): Likewise.
+	("umaxhi3"): Likewise.
+	("negqi2"): Likewise.
+	("*ashlqi3_const1", "*ashrqi3_const1"): Likewise.
+	("lshrhi3_const", "*lshrqi3_const1"): Likewise.
+
+2006-01-20  Stephane Carrez  <stcarrez@nerim.fr>
+
+	savannah/15493
+	* config/m68hc11/m68hc11.c (m68hc11_gen_movqi): Must save register
+	A and copy X or Y in it for a move when both operands refer to X or Y.
+
+2005-11-05  Stephane Carrez  <stcarrez@nerim.fr>
+
+	PR savannah/13879
+	* expmed.c (make_tree): If we have a constant for SIGN_EXTEND or
+	ZERO_EXTEND, use the mode from the extend node; the constant is VOIDmode
+	and it will crash.
+
+2005-11-05  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* expmed.c (store_bit_field): Must apply a correction for big-endian
+	target when the bitfield contains less word than the source constant.
+
+2005-05-15  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* config/m68hc11/m68hc11.h (REG_VALID_P): The macro can be used with
+	signed numbers passed as argument.
+	* version.c: Bump to 20050515
+
+2005-05-08  Stephane Carrez  <stcarrez@nerim.fr>
+
+	PR savannah/12572
+	* config/m68hc11/m68hc11.md ("movhi"): Sign extend the constants in
+	the range 32768..65535 so that the generated set is recognized.
+
+2005-05-08  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* config/m68hc11/m68hc11.md ("mulqi3"): Use general_operand for operand
+	1 and fix constraints.
+	("mulqihi3")" Use general_operand for operand 2.
+	* config/m68hc11/m68hc11.c (m68hc11_gen_movqi): Use pula and pulb
+	instead of lda and ldb for 68HC12.
+
+2005-05-08  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* config/m68hc11/m68hc11-protos.h (m68hc11_hard_regno_rename_ok): Pass
+	the mode.
+	* config/m68hc11/m68hc11.h (HARD_REGNO_RENAME_OK): Likewise.
+	* config/m68hc11/m68hc11.c (m68hc11_hard_regno_rename_ok): Likewise.
+	* regrename.c (regrename_optimize): Pass the mode in which the register
+	is used.
+
+2005-04-03  Stephane Carrez  <stcarrez@nerim.fr>
+
+	PR savannah/12297
+	* config/m68hc11/m68hc11.c (m68hc11_z_replacement): Use emit_insn_after
+	when adding the save Z instruction so that it is part of the good BB.
+
+2005-02-13  Stephane Carrez  <stcarrez@nerim.fr>
+
+	PR target/17551
+	* gcse.c (handle_avail_expr): Use gen_move_insn() instead of
+	gen_rtx_SET()
+
+2005-02-13  Stephane Carrez  <stcarrez@nerim.fr>
+
+	PR target/16925
+	* config/m68hc11/m68hc11.c (m68hc11_gen_highpart): Handle split of
+	64-bit constants on 64-bit hosts.
+	(m68hc11_split_logical): Simplify.
+	(m68hc11_split_move): Likewise.
+
+2005-02-12  Stephane Carrez  <stcarrez@nerim.fr>
+
+	PR savannah/11813
+	* config/m68hc11/m68hc11.c (reg_or_some_mem_operand): Do not allow
+	the 68HC12 address indirect addressing mode as it is not supported
+	by bset and bclr.
+
+2005-01-29  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* version.c (version_string): Bump to 2005-01-29.
+	* config/udivmodsi4.c (__udivmodsi4): Rewrite ediv as it didn't
+	passed the gcc validation.
+
+2005-01-28  Stephane Carrez  <stcarrez@nerim.fr>
+
+	From philipljohnson@comcast.net:
+
+	Patch savannah/3626
+	* config/udivmodsi4.c (__udivmodsi4): Use 68HC12 ediv instruction to
+	compute division and modulus.
+
+2004-08-30  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* config/m68hc11/m68hc11.c (m68hc11_gen_movhi): Fix invalid generation
+	of indexed indirect addressing with movw
+
+2004-08-29  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* version.c (version_string): Bump to 2004-08-29.
+
+2004-08-29  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* final.c (alter_subreg): Adjust the offset of paradoxical subreg
+	so that we load the correct value.
+
+2004-08-06  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* config/m68hc11/m68hc11.md ("movhi_const0"): Use this pattern only
+	for 68HC11.
+
+2004-08-01  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* version.c (version_string): Bump to 2004-08-01 and use gcc 3.3.4.
+
+2004-06-06  Stephane Carrez  <stcarrez@nerim.fr>
+
+	PR target/14542
+	* config/m68hc11/m68hc11.md (move peephole2): Emit a use note to avoid
+	a live change of a register after peephole replacement.
+
+2004-06-06  Stephane Carrez  <stcarrez@nerim.fr>
+
+	PR target/14457
+	* config/m68hc11/m68hc11.c (splitable_operand): New predicate.
+	* config/m68hc11/m68hc11-protos.h (splitable_operand): Declare.
+	* config/m68hc11/m68hc11.h (PREDICATE_CODES): Register it.
+	(inhibit_libc): Must define.
+	* config/m68hc11/m68hc11.md ("movhi_const0"): Use splitable_operand.
+	("*andhi3_gen", "iorhi3", "*iorhi3_gen"): Likewise.
+	("xorhi3"): Likewise.
+
+2004-04-25  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* config/m68hc11/m68hc11.md ("iorqi3_gen"): Use general_operand for
+	first operand.
+	("*andqi3_gen", "xorqi3"): Likewise.
+	("subqi3", "*subhi3"): Likewise.
+	("*addhi3_zext"): Likewise.
+
+2004-04-25  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* config/m68hc11/m68hc11.h (ASM_OUTPUT_LABELREF): Redefine to strip
+	any name encoding.
+
+2004-03-07  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* config/m68hc11/m68hc11.md ("*lshrsi3_const"): Disable for 68HC12.
+	("*lshrsi3"): Also accept an immediate for 68HC12.
+	("*ashrsi3_const"): Likewise.
+	("*ashrsi3"): Likewise.
+	("*ashlsi3_const"): Likewise.
+	("*ashlsi3"): Likewise.
+	("cmphi_1_hc12"): Compare two hard register by pushing them and
+	comparing with a pop; don't use a split for that.
+	("cmphi split"): Disable compare split for 68HC12.
+
+2004-03-06  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* config/m68hc11/m68hc11.md ("*lshrsi3_const1"): Allow a memory for
+	operand 1 when operand 0 is a soft register.
+	("*ashlsi3_const1"): Likewise.
+
+2004-03-06  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* config/m68hc11/m68hc11.c (m68hc11_gen_movhi): Use 2,-sp to push
+	the stack register.
+
+2004-03-06  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* doc/extend.texi (Function Attributes): Document page0, trap and
+	update far documentation.
+
+2004-03-06  Stephane Carrez  <stcarrez@nerim.fr>
+
+	PR savannah/4987:
+	* doc/invoke.texi (M68hc1x Options): Document -mrelax
+
+2004-03-06  Stephane Carrez  <stcarrez@nerim.fr>
+
+	PR savannah/8028:
+	* config/m68hc11/m68hc11.c (expand_prologue): Don't make an interrupt
+	or a trap handler a far symbol.
+	(m68hc11_initial_elimination_offset): Likewise.
+
+2004-03-06  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* config/m68hc11/m68hc11.md ("*lshrsi3_const1"): Tune constraints
+	to optimize more case where we don't need a scratch register.
+	("*ashlsi3_const1"): Likewise.
+	("*pushdi_internal"): New insn and split
+	to separate push from moves.
+	("*pushdf_internal"): Likewise.
+	("*pushsf_internal"): Likewise.
+	("*pushsi_internal"): Likewise.
+	("movdi_internal"): Use define_insn_and_split; non push operand.
+	("movdf_internal"): Likewise.
+	("movsf_internal"): Likewise.
+	("movsi_internal"): Likewise.
+
+2004-03-02  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* config/m68hc11/m68hc11.c (m68hc11_addr_mode): New variable.
+	(m68hc11_mov_addr_mode): Likewise.
+	(m68hc11_override_options): Initialize them based on target.
+	(register_indirect_p): Allow a MEM for indirect addressing modes and
+	use flags to control what is allowed.
+	(m68hc11_small_indexed_indirect_p): Use m68hc11_mov_addr_mode for
+	supported addressing modes.
+	(m68hc11_register_indirect_p): Use m68hc11_addr_mode.
+	(go_if_legitimate_address_internal): Likewise.
+	(m68hc11_indirect_p): Likewise and check the mode.
+	(print_operand): Allow a (MEM (MEM)) and generate indirect addressing.
+
+2004-02-22  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* version.c: Bump to 20040222 and use gcc 3.3.3.
+
+2003-11-16  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* version.c: Bump to 200311116.
+
+2003-11-10  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* config/m68hc11/m68hc11-protos.h (m68hc11_page0_symbol_p): Declare.
+	* config/m68hc11/m68hc11.c (m68hc11_page0_symbol_p): New predicate.
+	(m68hc11_indirect_p): Use it.
+	(print_operand): Likewise.
+	(m68hc11_handle_page0_attribute): New function to handle page0
+	attribute
+	(m68hc11_attribute_table): New attribute page0
+	(m68hc11_encode_section_info): Check page0 attribute.
+	* config/m68hc11/m68hc11.md: Use define_insn_and_split
+	(peephole2): New peephole to generate bset/bclr.
+	(peephole): New peephole to optimize compare in few cases and
+	setting of 2 registers from memory.
+
+2003-10-04  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* version.c: Bump to 20031004.
+
+2003-10-04  Stephane Carrez  <stcarrez@nerim.fr>
+
+	PR savannah/3432:
+	* config/m68hc11/t-m68hc11-gas (MULTILIB_MATCHES): m68hcs12 is
+	identical to m68hc12 for libraries.
+
+2003-10-01  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* version.c: Bump to 20031001.
+
+2003-09-30  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* config/m68hc11/m68hc11.md ("*ashldi3_const32"): Adjust first operand
+	if it uses stack pointer register.
+
+2003-09-30  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* config/m68hc11/m68hc11.md (peephole2 "remove one load"): Make sure
+	that register operand 3 does not appear in operand 2.
+
+2003-08-08  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* version.c: Bump to 20030808
+
+2003-08-02  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* config/m68hc11/m68hc11.md (peephole2 "leas 2,sp"): Enable it
+	and add a use rtx.
+	(peephole2): New peephole to optimize moves on stack.
+
+2003-07-19  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* config/m68hc11/m68hc11.md (peephole2 abx): Use m68hc11_gen_lowpart
+	to make sure the constant has the appropriate QImode.
+
+2003-07-08  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* config/m68hc11/m68hc11.h (HAVE_AS_DWARF2_DEBUG_LINE): Don't define
+	as .file/.loc directives are incompatible with linker relaxation.
+
+2003-05-19  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* config/m68hc11/m68hc11.md ("*movqi" split): Don't split when source
+	or destination is d, b or a register.
+
+2003-05-18  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* config/m68hc11/m68hc11.md ("*logicalhi3_zexthi_ashift8): Allow
+	address registers for operand 1 and 2.
+
+2003-05-18  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* reload.c (find_reloads_toplev): Do not reload the paradoxical
+	subreg with its wider mode but the register itself.
+
+2003-05-18  Stephane Carrez  <stcarrez@nerim.fr>
+
+	Merge 3.0.4-20030501 patchs in 3.3
+
+	2003-03-12  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* config/m68hc11/m68hc11.md
+	("movdi_internal", "movdf_internal"): Fix constraints.
+	("movsi_internal", "movsf_internal"): Likewise.
+	(peephole2): New peephole2 to optimize the address computations
+	by using 'abx' and 'aby'.
+	(peephole2): New peephole2 to optimize 32-bit shift and use only
+	one hard register instead of two.
+	(peephole2): New peephole2 to avoid loading the same value in two
+	different registers.
+
+	2003-03-12  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* config/m68hc11/m68hc11.md (split "logicalsi3_silshl16_zext"): Split
+	after reload but reject the particular case that generates a xgdx
+	pattern, it must be handled after Z register replacement.
+
+	2003-03-10  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* config/m68hc11/m68hc11.md ("*addhi3_68hc12"): Accept any constant
+	when adding to X and Y since leax/leay are fast.
+	("*addhi3"): Accept 'I' constraint when adding to address register.
+
+	2003-02-27  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* config/m68hc11/m68hc11.md ("*logicalsi3_silshr16"): Accept D reg
+	on all operands.
+
+	2003-01-10  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* config/m68hc11/m68hc11.md ("*logicalsi3_silshl16_zext"): New split.
+	("*logicalsi3_silshr16"): Fix constraints.
+
+	2002-02-27  Stephane Carrez  <Stephane.Carrez@worldnet.fr>
+
+	* reload.c (find_reloads): Change to RELOAD_FOR_OTHER_ADDRESS any
+	RELOAD_FOR_OPERAND_ADDRESS reloads which is used by a RELOAD_FOR_OTHER
+	reload (ensures correct order of reload insns).
+
+	2001-07-09  Stephane Carrez  <Stephane.Carrez@worldnet.fr>
+
+	* reload1.c (merge_assigned_reloads): After a RELOAD_OTHER merge,
+	fix setting of the reloads of that reload to RELOAD_FOR_OTHER_ADDRESS.
+
+	2001-06-22  Stephane Carrez  <Stephane.Carrez@worldnet.fr>
+
+	* config/m68hc11/m68hc11.h (MAX_BITS_PER_WORD): Define to 32.
+
+	2001-03-01  Stephane Carrez  <Stephane.Carrez@worldnet.fr>
+
+	* reload1.c (merge_assigned_reloads): Change the type of the
+	reload to emit it at the good place after the merge.
+
+	2001-02-24  Stephane Carrez  <Stephane.Carrez@worldnet.fr>
+
+        * reload.c (find_reloads_subreg_address): Call find_reloads_address
+        with the same reload type.
--- a/gcc/c-parse.c
+++ b/gcc/c-parse.c
@@ -1,12 +1,13 @@
-/* A Bison parser, made by GNU Bison 1.875.  */
+/* A Bison parser, made by GNU Bison 2.5.  */
 
-/* Skeleton parser for Yacc-like parsing with Bison,
-   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002 Free Software Foundation, Inc.
+/* Bison implementation for Yacc-like parsers in C
 
-   This program is free software; you can redistribute it and/or modify
+      Copyright (C) 1984, 1989-1990, 2000-2011 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2, or (at your option)
-   any later version.
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
@@ -14,17 +15,23 @@
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 59 Temple Place - Suite 330,
-   Boston, MA 02111-1307, USA.  */
-
-/* As a special exception, when this file is copied by Bison into a
-   Bison output file, you may use that output file without restriction.
-   This special exception was added by the Free Software Foundation
-   in version 1.24 of Bison.  */
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
 
-/* Written by Richard Stallman by simplifying the original so called
-   ``semantic'' parser.  */
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+/* C LALR(1) parser skeleton written by Richard Stallman, by
+   simplifying the original so-called "semantic" parser.  */
 
 /* All symbols defined below should begin with yy or YY, to avoid
    infringing on user name space.  This should be done even for local
@@ -36,164 +43,29 @@
 /* Identify Bison output.  */
 #define YYBISON 1
 
+/* Bison version.  */
+#define YYBISON_VERSION "2.5"
+
 /* Skeleton name.  */
 #define YYSKELETON_NAME "yacc.c"
 
 /* Pure parsers.  */
 #define YYPURE 0
 
-/* Using locations.  */
-#define YYLSP_NEEDED 0
-
-
+/* Push parsers.  */
+#define YYPUSH 0
 
-/* Tokens.  */
-#ifndef YYTOKENTYPE
-# define YYTOKENTYPE
-   /* Put the tokens into the symbol table, so that GDB and other debuggers
-      know about them.  */
-   enum yytokentype {
-     IDENTIFIER = 258,
-     TYPENAME = 259,
-     SCSPEC = 260,
-     STATIC = 261,
-     TYPESPEC = 262,
-     TYPE_QUAL = 263,
-     CONSTANT = 264,
-     STRING = 265,
-     ELLIPSIS = 266,
-     SIZEOF = 267,
-     ENUM = 268,
-     STRUCT = 269,
-     UNION = 270,
-     IF = 271,
-     ELSE = 272,
-     WHILE = 273,
-     DO = 274,
-     FOR = 275,
-     SWITCH = 276,
-     CASE = 277,
-     DEFAULT = 278,
-     BREAK = 279,
-     CONTINUE = 280,
-     RETURN = 281,
-     GOTO = 282,
-     ASM_KEYWORD = 283,
-     TYPEOF = 284,
-     ALIGNOF = 285,
-     ATTRIBUTE = 286,
-     EXTENSION = 287,
-     LABEL = 288,
-     REALPART = 289,
-     IMAGPART = 290,
-     VA_ARG = 291,
-     CHOOSE_EXPR = 292,
-     TYPES_COMPATIBLE_P = 293,
-     PTR_VALUE = 294,
-     PTR_BASE = 295,
-     PTR_EXTENT = 296,
-     STRING_FUNC_NAME = 297,
-     VAR_FUNC_NAME = 298,
-     ASSIGN = 299,
-     OROR = 300,
-     ANDAND = 301,
-     EQCOMPARE = 302,
-     ARITHCOMPARE = 303,
-     RSHIFT = 304,
-     LSHIFT = 305,
-     MINUSMINUS = 306,
-     PLUSPLUS = 307,
-     UNARY = 308,
-     HYPERUNARY = 309,
-     POINTSAT = 310,
-     INTERFACE = 311,
-     IMPLEMENTATION = 312,
-     END = 313,
-     SELECTOR = 314,
-     DEFS = 315,
-     ENCODE = 316,
-     CLASSNAME = 317,
-     PUBLIC = 318,
-     PRIVATE = 319,
-     PROTECTED = 320,
-     PROTOCOL = 321,
-     OBJECTNAME = 322,
-     CLASS = 323,
-     ALIAS = 324
-   };
-#endif
-#define IDENTIFIER 258
-#define TYPENAME 259
-#define SCSPEC 260
-#define STATIC 261
-#define TYPESPEC 262
-#define TYPE_QUAL 263
-#define CONSTANT 264
-#define STRING 265
-#define ELLIPSIS 266
-#define SIZEOF 267
-#define ENUM 268
-#define STRUCT 269
-#define UNION 270
-#define IF 271
-#define ELSE 272
-#define WHILE 273
-#define DO 274
-#define FOR 275
-#define SWITCH 276
-#define CASE 277
-#define DEFAULT 278
-#define BREAK 279
-#define CONTINUE 280
-#define RETURN 281
-#define GOTO 282
-#define ASM_KEYWORD 283
-#define TYPEOF 284
-#define ALIGNOF 285
-#define ATTRIBUTE 286
-#define EXTENSION 287
-#define LABEL 288
-#define REALPART 289
-#define IMAGPART 290
-#define VA_ARG 291
-#define CHOOSE_EXPR 292
-#define TYPES_COMPATIBLE_P 293
-#define PTR_VALUE 294
-#define PTR_BASE 295
-#define PTR_EXTENT 296
-#define STRING_FUNC_NAME 297
-#define VAR_FUNC_NAME 298
-#define ASSIGN 299
-#define OROR 300
-#define ANDAND 301
-#define EQCOMPARE 302
-#define ARITHCOMPARE 303
-#define RSHIFT 304
-#define LSHIFT 305
-#define MINUSMINUS 306
-#define PLUSPLUS 307
-#define UNARY 308
-#define HYPERUNARY 309
-#define POINTSAT 310
-#define INTERFACE 311
-#define IMPLEMENTATION 312
-#define END 313
-#define SELECTOR 314
-#define DEFS 315
-#define ENCODE 316
-#define CLASSNAME 317
-#define PUBLIC 318
-#define PRIVATE 319
-#define PROTECTED 320
-#define PROTOCOL 321
-#define OBJECTNAME 322
-#define CLASS 323
-#define ALIAS 324
+/* Pull parsers.  */
+#define YYPULL 1
 
+/* Using locations.  */
+#define YYLSP_NEEDED 0
 
 
 
 /* Copy the first part of user declarations.  */
+
+/* Line 268 of yacc.c  */
 #line 34 "c-parse.y"
 
 #include "config.h"
@@ -262,6 +134,9 @@
 } while (0)
 
 
+/* Line 268 of yacc.c  */
+#line 139 "c-p5137.c"
+
 /* Enabling traces.  */
 #ifndef YYDEBUG
 # define YYDEBUG 0
@@ -275,20 +150,112 @@
 # define YYERROR_VERBOSE 0
 #endif
 
-#if ! defined (YYSTYPE) && ! defined (YYSTYPE_IS_DECLARED)
+/* Enabling the token table.  */
+#ifndef YYTOKEN_TABLE
+# define YYTOKEN_TABLE 0
+#endif
+
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     IDENTIFIER = 258,
+     TYPENAME = 259,
+     SCSPEC = 260,
+     STATIC = 261,
+     TYPESPEC = 262,
+     TYPE_QUAL = 263,
+     CONSTANT = 264,
+     STRING = 265,
+     ELLIPSIS = 266,
+     SIZEOF = 267,
+     ENUM = 268,
+     STRUCT = 269,
+     UNION = 270,
+     IF = 271,
+     ELSE = 272,
+     WHILE = 273,
+     DO = 274,
+     FOR = 275,
+     SWITCH = 276,
+     CASE = 277,
+     DEFAULT = 278,
+     BREAK = 279,
+     CONTINUE = 280,
+     RETURN = 281,
+     GOTO = 282,
+     ASM_KEYWORD = 283,
+     TYPEOF = 284,
+     ALIGNOF = 285,
+     ATTRIBUTE = 286,
+     EXTENSION = 287,
+     LABEL = 288,
+     REALPART = 289,
+     IMAGPART = 290,
+     VA_ARG = 291,
+     CHOOSE_EXPR = 292,
+     TYPES_COMPATIBLE_P = 293,
+     PTR_VALUE = 294,
+     PTR_BASE = 295,
+     PTR_EXTENT = 296,
+     STRING_FUNC_NAME = 297,
+     VAR_FUNC_NAME = 298,
+     ASSIGN = 299,
+     OROR = 300,
+     ANDAND = 301,
+     EQCOMPARE = 302,
+     ARITHCOMPARE = 303,
+     RSHIFT = 304,
+     LSHIFT = 305,
+     MINUSMINUS = 306,
+     PLUSPLUS = 307,
+     UNARY = 308,
+     HYPERUNARY = 309,
+     POINTSAT = 310,
+     INTERFACE = 311,
+     IMPLEMENTATION = 312,
+     END = 313,
+     SELECTOR = 314,
+     DEFS = 315,
+     ENCODE = 316,
+     CLASSNAME = 317,
+     PUBLIC = 318,
+     PRIVATE = 319,
+     PROTECTED = 320,
+     PROTOCOL = 321,
+     OBJECTNAME = 322,
+     CLASS = 323,
+     ALIAS = 324
+   };
+#endif
+
+
+
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef union YYSTYPE
+{
+
+/* Line 293 of yacc.c  */
 #line 103 "c-parse.y"
-typedef union YYSTYPE {long itype; tree ttype; enum tree_code code;
-	const char *filename; int lineno; } YYSTYPE;
-/* Line 191 of yacc.c.  */
-#line 283 "c-p15339.c"
+long itype; tree ttype; enum tree_code code;
+	const char *filename; int lineno;
+
+
+/* Line 293 of yacc.c  */
+#line 249 "c-p5137.c"
+} YYSTYPE;
+# define YYSTYPE_IS_TRIVIAL 1
 # define yystype YYSTYPE /* obsolescent; will be withdrawn */
 # define YYSTYPE_IS_DECLARED 1
-# define YYSTYPE_IS_TRIVIAL 1
 #endif
 
 
-
 /* Copy the second part of user declarations.  */
+
+/* Line 343 of yacc.c  */
 #line 237 "c-parse.y"
 
 /* Number of statements (loosely speaking) and compound statements
@@ -375,51 +342,173 @@
 
 
 
-/* Line 214 of yacc.c.  */
-#line 379 "c-p15339.c"
+/* Line 343 of yacc.c  */
+#line 347 "c-p5137.c"
 
-#if ! defined (yyoverflow) || YYERROR_VERBOSE
+#ifdef short
+# undef short
+#endif
 
-/* The parser invokes alloca or malloc; define the necessary symbols.  */
+#ifdef YYTYPE_UINT8
+typedef YYTYPE_UINT8 yytype_uint8;
+#else
+typedef unsigned char yytype_uint8;
+#endif
+
+#ifdef YYTYPE_INT8
+typedef YYTYPE_INT8 yytype_int8;
+#elif (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+typedef signed char yytype_int8;
+#else
+typedef short int yytype_int8;
+#endif
+
+#ifdef YYTYPE_UINT16
+typedef YYTYPE_UINT16 yytype_uint16;
+#else
+typedef unsigned short int yytype_uint16;
+#endif
+
+#ifdef YYTYPE_INT16
+typedef YYTYPE_INT16 yytype_int16;
+#else
+typedef short int yytype_int16;
+#endif
 
-# if YYSTACK_USE_ALLOCA
-#  define YYSTACK_ALLOC alloca
+#ifndef YYSIZE_T
+# ifdef __SIZE_TYPE__
+#  define YYSIZE_T __SIZE_TYPE__
+# elif defined size_t
+#  define YYSIZE_T size_t
+# elif ! defined YYSIZE_T && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYSIZE_T size_t
 # else
-#  ifndef YYSTACK_USE_ALLOCA
-#   if defined (alloca) || defined (_ALLOCA_H)
-#    define YYSTACK_ALLOC alloca
+#  define YYSIZE_T unsigned int
+# endif
+#endif
+
+#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
+
+#ifndef YY_
+# if defined YYENABLE_NLS && YYENABLE_NLS
+#  if ENABLE_NLS
+#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
+#   define YY_(msgid) dgettext ("bison-runtime", msgid)
+#  endif
+# endif
+# ifndef YY_
+#  define YY_(msgid) msgid
+# endif
+#endif
+
+/* Suppress unused-variable warnings by "using" E.  */
+#if ! defined lint || defined __GNUC__
+# define YYUSE(e) ((void) (e))
+#else
+# define YYUSE(e) /* empty */
+#endif
+
+/* Identity function, used to suppress warnings about constant conditions.  */
+#ifndef lint
+# define YYID(n) (n)
+#else
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static int
+YYID (int yyi)
+#else
+static int
+YYID (yyi)
+    int yyi;
+#endif
+{
+  return yyi;
+}
+#endif
+
+#if ! defined yyoverflow || YYERROR_VERBOSE
+
+/* The parser invokes alloca or malloc; define the necessary symbols.  */
+
+# ifdef YYSTACK_USE_ALLOCA
+#  if YYSTACK_USE_ALLOCA
+#   ifdef __GNUC__
+#    define YYSTACK_ALLOC __builtin_alloca
+#   elif defined __BUILTIN_VA_ARG_INCR
+#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
+#   elif defined _AIX
+#    define YYSTACK_ALLOC __alloca
+#   elif defined _MSC_VER
+#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
+#    define alloca _alloca
 #   else
-#    ifdef __GNUC__
-#     define YYSTACK_ALLOC __builtin_alloca
+#    define YYSTACK_ALLOC alloca
+#    if ! defined _ALLOCA_H && ! defined EXIT_SUCCESS && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#     ifndef EXIT_SUCCESS
+#      define EXIT_SUCCESS 0
+#     endif
 #    endif
 #   endif
 #  endif
 # endif
 
 # ifdef YYSTACK_ALLOC
-   /* Pacify GCC's `empty if-body' warning. */
-#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (0)
+   /* Pacify GCC's `empty if-body' warning.  */
+#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (YYID (0))
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+    /* The OS might guarantee only one guard page at the bottom of the stack,
+       and a page size can be as small as 4096 bytes.  So we cannot safely
+       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
+       to allow for a few compiler-allocated temporary stack slots.  */
+#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
+#  endif
 # else
-#  if defined (__STDC__) || defined (__cplusplus)
+#  define YYSTACK_ALLOC YYMALLOC
+#  define YYSTACK_FREE YYFREE
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
+#  endif
+#  if (defined __cplusplus && ! defined EXIT_SUCCESS \
+       && ! ((defined YYMALLOC || defined malloc) \
+	     && (defined YYFREE || defined free)))
 #   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
-#   define YYSIZE_T size_t
+#   ifndef EXIT_SUCCESS
+#    define EXIT_SUCCESS 0
+#   endif
+#  endif
+#  ifndef YYMALLOC
+#   define YYMALLOC malloc
+#   if ! defined malloc && ! defined EXIT_SUCCESS && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+#  ifndef YYFREE
+#   define YYFREE free
+#   if ! defined free && ! defined EXIT_SUCCESS && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void free (void *); /* INFRINGES ON USER NAME SPACE */
+#   endif
 #  endif
-#  define YYSTACK_ALLOC malloc
-#  define YYSTACK_FREE free
 # endif
-#endif /* ! defined (yyoverflow) || YYERROR_VERBOSE */
+#endif /* ! defined yyoverflow || YYERROR_VERBOSE */
 
 
-#if (! defined (yyoverflow) \
-     && (! defined (__cplusplus) \
-	 || (YYSTYPE_IS_TRIVIAL)))
+#if (! defined yyoverflow \
+     && (! defined __cplusplus \
+	 || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
 
 /* A type that is properly aligned for any stack member.  */
 union yyalloc
 {
-  short yyss;
-  YYSTYPE yyvs;
-  };
+  yytype_int16 yyss_alloc;
+  YYSTYPE yyvs_alloc;
+};
 
 /* The size of the maximum gap between one aligned stack and the next.  */
 # define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
@@ -427,74 +516,72 @@
 /* The size of an array large to enough to hold all stacks, each with
    N elements.  */
 # define YYSTACK_BYTES(N) \
-     ((N) * (sizeof (short) + sizeof (YYSTYPE))				\
+     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE)) \
       + YYSTACK_GAP_MAXIMUM)
 
-/* Copy COUNT objects from FROM to TO.  The source and destination do
-   not overlap.  */
-# ifndef YYCOPY
-#  if 1 < __GNUC__
-#   define YYCOPY(To, From, Count) \
-      __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
-#  else
-#   define YYCOPY(To, From, Count)		\
-      do					\
-	{					\
-	  register YYSIZE_T yyi;		\
-	  for (yyi = 0; yyi < (Count); yyi++)	\
-	    (To)[yyi] = (From)[yyi];		\
-	}					\
-      while (0)
-#  endif
-# endif
+# define YYCOPY_NEEDED 1
 
 /* Relocate STACK from its old location to the new one.  The
    local variables YYSIZE and YYSTACKSIZE give the old and new number of
    elements in the stack, and YYPTR gives the new location of the
    stack.  Advance YYPTR to a properly aligned location for the next
    stack.  */
-# define YYSTACK_RELOCATE(Stack)					\
+# define YYSTACK_RELOCATE(Stack_alloc, Stack)				\
     do									\
       {									\
 	YYSIZE_T yynewbytes;						\
-	YYCOPY (&yyptr->Stack, Stack, yysize);				\
-	Stack = &yyptr->Stack;						\
+	YYCOPY (&yyptr->Stack_alloc, Stack, yysize);			\
+	Stack = &yyptr->Stack_alloc;					\
 	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
 	yyptr += yynewbytes / sizeof (*yyptr);				\
       }									\
-    while (0)
+    while (YYID (0))
 
 #endif
 
-#if defined (__STDC__) || defined (__cplusplus)
-   typedef signed char yysigned_char;
-#else
-   typedef short yysigned_char;
-#endif
+#if defined YYCOPY_NEEDED && YYCOPY_NEEDED
+/* Copy COUNT objects from FROM to TO.  The source and destination do
+   not overlap.  */
+# ifndef YYCOPY
+#  if defined __GNUC__ && 1 < __GNUC__
+#   define YYCOPY(To, From, Count) \
+      __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
+#  else
+#   define YYCOPY(To, From, Count)		\
+      do					\
+	{					\
+	  YYSIZE_T yyi;				\
+	  for (yyi = 0; yyi < (Count); yyi++)	\
+	    (To)[yyi] = (From)[yyi];		\
+	}					\
+      while (YYID (0))
+#  endif
+# endif
+#endif /* !YYCOPY_NEEDED */
 
-/* YYFINAL -- State number of the termination state. */
+/* YYFINAL -- State number of the termination state.  */
 #define YYFINAL  4
 /* YYLAST -- Last index in YYTABLE.  */
 #define YYLAST   3120
 
-/* YYNTOKENS -- Number of terminals. */
+/* YYNTOKENS -- Number of terminals.  */
 #define YYNTOKENS  92
-/* YYNNTS -- Number of nonterminals. */
+/* YYNNTS -- Number of nonterminals.  */
 #define YYNNTS  202
-/* YYNRULES -- Number of rules. */
+/* YYNRULES -- Number of rules.  */
 #define YYNRULES  558
-/* YYNRULES -- Number of states. */
+/* YYNRULES -- Number of states.  */
 #define YYNSTATES  896
 
 /* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
 #define YYUNDEFTOK  2
 #define YYMAXUTOK   324
 
-#define YYTRANSLATE(YYX) 						\
+#define YYTRANSLATE(YYX)						\
   ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
 
 /* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
-static const unsigned char yytranslate[] =
+static const yytype_uint8 yytranslate[] =
 {
        0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
@@ -534,7 +621,7 @@
 #if YYDEBUG
 /* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
    YYRHS.  */
-static const unsigned short yyprhs[] =
+static const yytype_uint16 yyprhs[] =
 {
        0,     0,     3,     4,     6,     7,    10,    11,    15,    17,
       19,    21,    27,    30,    34,    39,    44,    47,    50,    53,
@@ -594,8 +681,8 @@
     1695,  1696,  1700,  1702,  1705,  1707,  1711,  1713,  1717
 };
 
-/* YYRHS -- A `-1'-separated list of the rules' RHS. */
-static const short yyrhs[] =
+/* YYRHS -- A `-1'-separated list of the rules' RHS.  */
+static const yytype_int16 yyrhs[] =
 {
       93,     0,    -1,    -1,    94,    -1,    -1,    95,    97,    -1,
       -1,    94,    96,    97,    -1,    98,    -1,   100,    -1,    99,
@@ -772,7 +859,7 @@
 };
 
 /* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
-static const unsigned short yyrline[] =
+static const yytype_uint16 yyrline[] =
 {
        0,   324,   324,   328,   347,   347,   348,   348,   352,   357,
      358,   359,   367,   372,   379,   381,   383,   385,   386,   387,
@@ -833,76 +920,77 @@
 };
 #endif
 
-#if YYDEBUG || YYERROR_VERBOSE
-/* YYTNME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
-   First, the terminals, then, starting at YYNTOKENS, nonterminals. */
+#if YYDEBUG || YYERROR_VERBOSE || YYTOKEN_TABLE
+/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
 static const char *const yytname[] =
 {
-  "$end", "error", "$undefined", "IDENTIFIER", "TYPENAME", "SCSPEC", 
-  "STATIC", "TYPESPEC", "TYPE_QUAL", "CONSTANT", "STRING", "ELLIPSIS", 
-  "SIZEOF", "ENUM", "STRUCT", "UNION", "IF", "ELSE", "WHILE", "DO", "FOR", 
-  "SWITCH", "CASE", "DEFAULT", "BREAK", "CONTINUE", "RETURN", "GOTO", 
-  "ASM_KEYWORD", "TYPEOF", "ALIGNOF", "ATTRIBUTE", "EXTENSION", "LABEL", 
-  "REALPART", "IMAGPART", "VA_ARG", "CHOOSE_EXPR", "TYPES_COMPATIBLE_P", 
-  "PTR_VALUE", "PTR_BASE", "PTR_EXTENT", "STRING_FUNC_NAME", 
-  "VAR_FUNC_NAME", "'='", "ASSIGN", "'?'", "':'", "OROR", "ANDAND", "'|'", 
-  "'^'", "'&'", "EQCOMPARE", "ARITHCOMPARE", "RSHIFT", "LSHIFT", "'+'", 
-  "'-'", "'*'", "'/'", "'%'", "MINUSMINUS", "PLUSPLUS", "UNARY", 
-  "HYPERUNARY", "'.'", "'('", "'['", "POINTSAT", "INTERFACE", 
-  "IMPLEMENTATION", "END", "SELECTOR", "DEFS", "ENCODE", "CLASSNAME", 
-  "PUBLIC", "PRIVATE", "PROTECTED", "PROTOCOL", "OBJECTNAME", "CLASS", 
-  "ALIAS", "')'", "';'", "'}'", "'~'", "'!'", "','", "'{'", "']'", 
-  "$accept", "program", "extdefs", "@1", "@2", "extdef", "extdef_1", 
-  "datadef", "fndef", "@3", "@4", "@5", "@6", "@7", "@8", "identifier", 
-  "unop", "expr", "exprlist", "nonnull_exprlist", "unary_expr", "sizeof", 
-  "alignof", "typeof", "cast_expr", "expr_no_commas", "@9", "@10", "@11", 
-  "@12", "@13", "primary", "@14", "old_style_parm_decls", 
-  "old_style_parm_decls_1", "lineno_datadecl", "datadecls", "datadecl", 
-  "lineno_decl", "setspecs", "maybe_resetattrs", "decl", 
-  "declspecs_nosc_nots_nosa_noea", "declspecs_nosc_nots_nosa_ea", 
-  "declspecs_nosc_nots_sa_noea", "declspecs_nosc_nots_sa_ea", 
-  "declspecs_nosc_ts_nosa_noea", "declspecs_nosc_ts_nosa_ea", 
-  "declspecs_nosc_ts_sa_noea", "declspecs_nosc_ts_sa_ea", 
-  "declspecs_sc_nots_nosa_noea", "declspecs_sc_nots_nosa_ea", 
-  "declspecs_sc_nots_sa_noea", "declspecs_sc_nots_sa_ea", 
-  "declspecs_sc_ts_nosa_noea", "declspecs_sc_ts_nosa_ea", 
-  "declspecs_sc_ts_sa_noea", "declspecs_sc_ts_sa_ea", "declspecs_ts", 
-  "declspecs_nots", "declspecs_ts_nosa", "declspecs_nots_nosa", 
-  "declspecs_nosc_ts", "declspecs_nosc_nots", "declspecs_nosc", 
-  "declspecs", "maybe_type_quals_attrs", "typespec_nonattr", 
-  "typespec_attr", "typespec_reserved_nonattr", "typespec_reserved_attr", 
-  "typespec_nonreserved_nonattr", "initdecls", "notype_initdecls", 
-  "maybeasm", "initdcl", "@15", "notype_initdcl", "@16", 
-  "maybe_attribute", "attributes", "attribute", "attribute_list", 
-  "attrib", "any_word", "scspec", "init", "@17", "initlist_maybe_comma", 
-  "initlist1", "initelt", "@18", "initval", "@19", "designator_list", 
-  "designator", "nested_function", "@20", "@21", "notype_nested_function", 
-  "@22", "@23", "declarator", "after_type_declarator", "parm_declarator", 
-  "parm_declarator_starttypename", "parm_declarator_nostarttypename", 
-  "notype_declarator", "struct_head", "union_head", "enum_head", 
-  "structsp_attr", "@24", "@25", "@26", "@27", "structsp_nonattr", 
-  "maybecomma", "maybecomma_warn", "component_decl_list", 
-  "component_decl_list2", "component_decl", "components", 
-  "components_notype", "component_declarator", 
-  "component_notype_declarator", "enumlist", "enumerator", "typename", 
-  "@28", "absdcl", "absdcl_maybe_attribute", "absdcl1", "absdcl1_noea", 
-  "absdcl1_ea", "direct_absdcl1", "array_declarator", "stmts_and_decls", 
-  "lineno_stmt_decl_or_labels_ending_stmt", 
-  "lineno_stmt_decl_or_labels_ending_decl", 
-  "lineno_stmt_decl_or_labels_ending_label", 
-  "lineno_stmt_decl_or_labels_ending_error", "lineno_stmt_decl_or_labels", 
-  "errstmt", "pushlevel", "poplevel", "c99_block_start", "c99_block_end", 
-  "maybe_label_decls", "label_decls", "label_decl", "compstmt_or_error", 
-  "compstmt_start", "compstmt_nostart", "compstmt_contents_nonempty", 
-  "compstmt_primary_start", "compstmt", "simple_if", "if_prefix", "@29", 
-  "do_stmt_start", "@30", "save_filename", "save_lineno", 
-  "lineno_labeled_stmt", "c99_block_lineno_labeled_stmt", "lineno_stmt", 
-  "lineno_label", "select_or_iter_stmt", "@31", "@32", "@33", "@34", 
-  "@35", "@36", "@37", "@38", "for_init_stmt", "stmt", "label", 
-  "maybe_type_qual", "xexpr", "asm_operands", "nonnull_asm_operands", 
-  "asm_operand", "asm_clobbers", "parmlist", "@39", "parmlist_1", "@40", 
-  "@41", "parmlist_2", "parms", "parm", "firstparm", "setspecs_fp", 
-  "parmlist_or_identifiers", "@42", "parmlist_or_identifiers_1", 
+  "$end", "error", "$undefined", "IDENTIFIER", "TYPENAME", "SCSPEC",
+  "STATIC", "TYPESPEC", "TYPE_QUAL", "CONSTANT", "STRING", "ELLIPSIS",
+  "SIZEOF", "ENUM", "STRUCT", "UNION", "IF", "ELSE", "WHILE", "DO", "FOR",
+  "SWITCH", "CASE", "DEFAULT", "BREAK", "CONTINUE", "RETURN", "GOTO",
+  "ASM_KEYWORD", "TYPEOF", "ALIGNOF", "ATTRIBUTE", "EXTENSION", "LABEL",
+  "REALPART", "IMAGPART", "VA_ARG", "CHOOSE_EXPR", "TYPES_COMPATIBLE_P",
+  "PTR_VALUE", "PTR_BASE", "PTR_EXTENT", "STRING_FUNC_NAME",
+  "VAR_FUNC_NAME", "'='", "ASSIGN", "'?'", "':'", "OROR", "ANDAND", "'|'",
+  "'^'", "'&'", "EQCOMPARE", "ARITHCOMPARE", "RSHIFT", "LSHIFT", "'+'",
+  "'-'", "'*'", "'/'", "'%'", "MINUSMINUS", "PLUSPLUS", "UNARY",
+  "HYPERUNARY", "'.'", "'('", "'['", "POINTSAT", "INTERFACE",
+  "IMPLEMENTATION", "END", "SELECTOR", "DEFS", "ENCODE", "CLASSNAME",
+  "PUBLIC", "PRIVATE", "PROTECTED", "PROTOCOL", "OBJECTNAME", "CLASS",
+  "ALIAS", "')'", "';'", "'}'", "'~'", "'!'", "','", "'{'", "']'",
+  "$accept", "program", "extdefs", "@1", "@2", "extdef", "extdef_1",
+  "datadef", "fndef", "$@3", "$@4", "$@5", "$@6", "$@7", "$@8",
+  "identifier", "unop", "expr", "exprlist", "nonnull_exprlist",
+  "unary_expr", "sizeof", "alignof", "typeof", "cast_expr",
+  "expr_no_commas", "$@9", "$@10", "$@11", "$@12", "$@13", "primary",
+  "$@14", "old_style_parm_decls", "old_style_parm_decls_1",
+  "lineno_datadecl", "datadecls", "datadecl", "lineno_decl", "setspecs",
+  "maybe_resetattrs", "decl", "declspecs_nosc_nots_nosa_noea",
+  "declspecs_nosc_nots_nosa_ea", "declspecs_nosc_nots_sa_noea",
+  "declspecs_nosc_nots_sa_ea", "declspecs_nosc_ts_nosa_noea",
+  "declspecs_nosc_ts_nosa_ea", "declspecs_nosc_ts_sa_noea",
+  "declspecs_nosc_ts_sa_ea", "declspecs_sc_nots_nosa_noea",
+  "declspecs_sc_nots_nosa_ea", "declspecs_sc_nots_sa_noea",
+  "declspecs_sc_nots_sa_ea", "declspecs_sc_ts_nosa_noea",
+  "declspecs_sc_ts_nosa_ea", "declspecs_sc_ts_sa_noea",
+  "declspecs_sc_ts_sa_ea", "declspecs_ts", "declspecs_nots",
+  "declspecs_ts_nosa", "declspecs_nots_nosa", "declspecs_nosc_ts",
+  "declspecs_nosc_nots", "declspecs_nosc", "declspecs",
+  "maybe_type_quals_attrs", "typespec_nonattr", "typespec_attr",
+  "typespec_reserved_nonattr", "typespec_reserved_attr",
+  "typespec_nonreserved_nonattr", "initdecls", "notype_initdecls",
+  "maybeasm", "initdcl", "@15", "notype_initdcl", "@16", "maybe_attribute",
+  "attributes", "attribute", "attribute_list", "attrib", "any_word",
+  "scspec", "init", "$@17", "initlist_maybe_comma", "initlist1", "initelt",
+  "$@18", "initval", "$@19", "designator_list", "designator",
+  "nested_function", "$@20", "$@21", "notype_nested_function", "$@22",
+  "$@23", "declarator", "after_type_declarator", "parm_declarator",
+  "parm_declarator_starttypename", "parm_declarator_nostarttypename",
+  "notype_declarator", "struct_head", "union_head", "enum_head",
+  "structsp_attr", "@24", "@25", "@26", "@27", "structsp_nonattr",
+  "maybecomma", "maybecomma_warn", "component_decl_list",
+  "component_decl_list2", "component_decl", "components",
+  "components_notype", "component_declarator",
+  "component_notype_declarator", "enumlist", "enumerator", "typename",
+  "@28", "absdcl", "absdcl_maybe_attribute", "absdcl1", "absdcl1_noea",
+  "absdcl1_ea", "direct_absdcl1", "array_declarator", "stmts_and_decls",
+  "lineno_stmt_decl_or_labels_ending_stmt",
+  "lineno_stmt_decl_or_labels_ending_decl",
+  "lineno_stmt_decl_or_labels_ending_label",
+  "lineno_stmt_decl_or_labels_ending_error", "lineno_stmt_decl_or_labels",
+  "errstmt", "pushlevel", "poplevel", "c99_block_start", "c99_block_end",
+  "maybe_label_decls", "label_decls", "label_decl", "compstmt_or_error",
+  "compstmt_start", "compstmt_nostart", "compstmt_contents_nonempty",
+  "compstmt_primary_start", "compstmt", "simple_if", "if_prefix", "@29",
+  "do_stmt_start", "@30", "save_filename", "save_lineno",
+  "lineno_labeled_stmt", "c99_block_lineno_labeled_stmt", "lineno_stmt",
+  "lineno_label", "select_or_iter_stmt", "$@31", "@32", "@33", "@34",
+  "$@35", "$@36", "$@37", "@38", "for_init_stmt", "stmt", "label",
+  "maybe_type_qual", "xexpr", "asm_operands", "nonnull_asm_operands",
+  "asm_operand", "asm_clobbers", "parmlist", "$@39", "parmlist_1", "$@40",
+  "$@41", "parmlist_2", "parms", "parm", "firstparm", "setspecs_fp",
+  "parmlist_or_identifiers", "$@42", "parmlist_or_identifiers_1",
   "identifiers", "identifiers_or_typenames", "extension", 0
 };
 #endif
@@ -910,7 +998,7 @@
 # ifdef YYPRINT
 /* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
    token YYLEX-NUM.  */
-static const unsigned short yytoknum[] =
+static const yytype_uint16 yytoknum[] =
 {
        0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
      265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
@@ -926,7 +1014,7 @@
 # endif
 
 /* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
-static const unsigned short yyr1[] =
+static const yytype_uint16 yyr1[] =
 {
        0,    92,    93,    93,    95,    94,    96,    94,    97,    98,
       98,    98,    98,    99,    99,    99,    99,    99,    99,    99,
@@ -987,7 +1075,7 @@
 };
 
 /* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
-static const unsigned char yyr2[] =
+static const yytype_uint8 yyr2[] =
 {
        0,     2,     0,     1,     0,     2,     0,     3,     1,     1,
        1,     5,     2,     3,     4,     4,     2,     2,     2,     1,
@@ -1047,10 +1135,10 @@
        0,     3,     1,     2,     1,     3,     1,     3,     1
 };
 
-/* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
-   STATE-NUM when YYTABLE doesn't specify something else to do.  Zero
+/* YYDEFACT[STATE-NAME] -- Default reduction number in state STATE-NUM.
+   Performed when YYTABLE doesn't specify something else to do.  Zero
    means the default is an error.  */
-static const unsigned short yydefact[] =
+static const yytype_uint16 yydefact[] =
 {
        4,     0,     6,     0,     1,     0,     0,   267,   299,   298,
      264,   126,   354,   350,   352,     0,    59,     0,   558,    19,
@@ -1144,8 +1232,8 @@
      490,   523,   506,   525,   449,   491
 };
 
-/* YYDEFGOTO[NTERM-NUM]. */
-static const short yydefgoto[] =
+/* YYDEFGOTO[NTERM-NUM].  */
+static const yytype_int16 yydefgoto[] =
 {
       -1,     1,     2,     3,     5,    20,    21,    22,    23,   316,
      501,   322,   503,   217,   407,   587,   180,   246,   375,   182,
@@ -1173,7 +1261,7 @@
 /* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
    STATE-NUM.  */
 #define YYPACT_NINF -735
-static const short yypact[] =
+static const yytype_int16 yypact[] =
 {
       66,   112,   119,  1512,  -735,  1512,   221,  -735,  -735,  -735,
     -735,  -735,   105,   105,   105,    91,  -735,   106,  -735,  -735,
@@ -1268,7 +1356,7 @@
 };
 
 /* YYPGOTO[NTERM-NUM].  */
-static const short yypgoto[] =
+static const yytype_int16 yypgoto[] =
 {
     -735,  -735,  -735,  -735,  -735,    84,  -735,  -735,  -735,  -735,
     -735,  -735,  -735,  -735,  -735,    96,  -735,   -65,   596,  -244,
@@ -1295,10 +1383,9 @@
 
 /* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
    positive, shift that token.  If negative, reduce the rule which
-   number is the opposite.  If zero, do what YYDEFACT says.
-   If YYTABLE_NINF, syntax error.  */
+   number is the opposite.  If YYTABLE_NINF, syntax error.  */
 #define YYTABLE_NINF -534
-static const short yytable[] =
+static const yytype_int16 yytable[] =
 {
      181,    26,   192,    26,   415,    50,   225,    50,    73,   228,
      418,   146,   147,   317,    62,    63,    64,   617,   417,   391,
@@ -1615,7 +1702,13 @@
      271
 };
 
-static const short yycheck[] =
+#define yypact_value_is_default(yystate) \
+  ((yystate) == (-735))
+
+#define yytable_value_is_error(yytable_value) \
+  YYID (0)
+
+static const yytype_int16 yycheck[] =
 {
       65,     3,    67,     5,   316,     3,   146,     5,    25,   147,
      322,    42,    43,   225,    12,    13,    14,   538,   318,   291,
@@ -1934,7 +2027,7 @@
 
 /* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
    symbol of state STATE-NUM.  */
-static const unsigned short yystos[] =
+static const yytype_uint16 yystos[] =
 {
        0,    93,    94,    95,     0,    96,     1,     4,     5,     6,
        7,     8,    13,    14,    15,    28,    29,    31,    32,    85,
@@ -2028,22 +2121,6 @@
       84,    84,    85,    10,   267,   257
 };
 
-#if ! defined (YYSIZE_T) && defined (__SIZE_TYPE__)
-# define YYSIZE_T __SIZE_TYPE__
-#endif
-#if ! defined (YYSIZE_T) && defined (size_t)
-# define YYSIZE_T size_t
-#endif
-#if ! defined (YYSIZE_T)
-# if defined (__STDC__) || defined (__cplusplus)
-#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
-#  define YYSIZE_T size_t
-# endif
-#endif
-#if ! defined (YYSIZE_T)
-# define YYSIZE_T unsigned int
-#endif
-
 #define yyerrok		(yyerrstatus = 0)
 #define yyclearin	(yychar = YYEMPTY)
 #define YYEMPTY		(-2)
@@ -2051,13 +2128,23 @@
 
 #define YYACCEPT	goto yyacceptlab
 #define YYABORT		goto yyabortlab
-#define YYERROR		goto yyerrlab1
+#define YYERROR		goto yyerrorlab
+
 
 /* Like YYERROR except do call yyerror.  This remains here temporarily
    to ease the transition to the new meaning of YYERROR, for GCC.
-   Once GCC version 2 has supplanted version 1, this can go.  */
+   Once GCC version 2 has supplanted version 1, this can go.  However,
+   YYFAIL appears to be in use.  Nevertheless, it is formally deprecated
+   in Bison 2.4.2's NEWS entry, where a plan to phase it out is
+   discussed.  */
 
 #define YYFAIL		goto yyerrlab
+#if defined YYFAIL
+  /* This is here to suppress warnings from the GCC cpp's
+     -Wunused-macros.  Normally we don't worry about that warning, but
+     some users do, and we want to make it easy for users to remove
+     YYFAIL uses, which will produce warnings from Bison 2.5.  */
+#endif
 
 #define YYRECOVERING()  (!!yyerrstatus)
 
@@ -2067,31 +2154,54 @@
     {								\
       yychar = (Token);						\
       yylval = (Value);						\
-      yytoken = YYTRANSLATE (yychar);				\
-      YYPOPSTACK;						\
+      YYPOPSTACK (1);						\
       goto yybackup;						\
     }								\
   else								\
-    { 								\
-      yyerror ("syntax error: cannot back up");\
+    {								\
+      yyerror (YY_("syntax error: cannot back up")); \
       YYERROR;							\
     }								\
-while (0)
+while (YYID (0))
+
 
 #define YYTERROR	1
 #define YYERRCODE	256
 
-/* YYLLOC_DEFAULT -- Compute the default location (before the actions
-   are run).  */
 
+/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].
+   If N is 0, then set CURRENT to the empty location which ends
+   the previous symbol: RHS[0] (always defined).  */
+
+#define YYRHSLOC(Rhs, K) ((Rhs)[K])
 #ifndef YYLLOC_DEFAULT
-# define YYLLOC_DEFAULT(Current, Rhs, N)         \
-  Current.first_line   = Rhs[1].first_line;      \
-  Current.first_column = Rhs[1].first_column;    \
-  Current.last_line    = Rhs[N].last_line;       \
-  Current.last_column  = Rhs[N].last_column;
+# define YYLLOC_DEFAULT(Current, Rhs, N)				\
+    do									\
+      if (YYID (N))                                                    \
+	{								\
+	  (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;	\
+	  (Current).first_column = YYRHSLOC (Rhs, 1).first_column;	\
+	  (Current).last_line    = YYRHSLOC (Rhs, N).last_line;		\
+	  (Current).last_column  = YYRHSLOC (Rhs, N).last_column;	\
+	}								\
+      else								\
+	{								\
+	  (Current).first_line   = (Current).last_line   =		\
+	    YYRHSLOC (Rhs, 0).last_line;				\
+	  (Current).first_column = (Current).last_column =		\
+	    YYRHSLOC (Rhs, 0).last_column;				\
+	}								\
+    while (YYID (0))
 #endif
 
+
+/* This macro is provided for backward compatibility. */
+
+#ifndef YY_LOCATION_PRINT
+# define YY_LOCATION_PRINT(File, Loc) ((void) 0)
+#endif
+
+
 /* YYLEX -- calling `yylex' with the right arguments.  */
 
 #ifdef YYLEX_PARAM
@@ -2112,43 +2222,100 @@
 do {						\
   if (yydebug)					\
     YYFPRINTF Args;				\
-} while (0)
+} while (YYID (0))
 
-# define YYDSYMPRINT(Args)			\
-do {						\
-  if (yydebug)					\
-    yysymprint Args;				\
-} while (0)
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)			  \
+do {									  \
+  if (yydebug)								  \
+    {									  \
+      YYFPRINTF (stderr, "%s ", Title);					  \
+      yy_symbol_print (stderr,						  \
+		  Type, Value); \
+      YYFPRINTF (stderr, "\n");						  \
+    }									  \
+} while (YYID (0))
 
-# define YYDSYMPRINTF(Title, Token, Value, Location)		\
-do {								\
-  if (yydebug)							\
-    {								\
-      YYFPRINTF (stderr, "%s ", Title);				\
-      yysymprint (stderr, 					\
-                  Token, Value);	\
-      YYFPRINTF (stderr, "\n");					\
-    }								\
-} while (0)
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_value_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (!yyvaluep)
+    return;
+# ifdef YYPRINT
+  if (yytype < YYNTOKENS)
+    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
+# else
+  YYUSE (yyoutput);
+# endif
+  switch (yytype)
+    {
+      default:
+	break;
+    }
+}
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (yytype < YYNTOKENS)
+    YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
+  else
+    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
+
+  yy_symbol_value_print (yyoutput, yytype, yyvaluep);
+  YYFPRINTF (yyoutput, ")");
+}
 
 /*------------------------------------------------------------------.
 | yy_stack_print -- Print the state stack from its BOTTOM up to its |
-| TOP (cinluded).                                                   |
+| TOP (included).                                                   |
 `------------------------------------------------------------------*/
 
-#if defined (__STDC__) || defined (__cplusplus)
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
 static void
-yy_stack_print (short *bottom, short *top)
+yy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)
 #else
 static void
-yy_stack_print (bottom, top)
-    short *bottom;
-    short *top;
+yy_stack_print (yybottom, yytop)
+    yytype_int16 *yybottom;
+    yytype_int16 *yytop;
 #endif
 {
   YYFPRINTF (stderr, "Stack now");
-  for (/* Nothing. */; bottom <= top; ++bottom)
-    YYFPRINTF (stderr, " %d", *bottom);
+  for (; yybottom <= yytop; yybottom++)
+    {
+      int yybot = *yybottom;
+      YYFPRINTF (stderr, " %d", yybot);
+    }
   YYFPRINTF (stderr, "\n");
 }
 
@@ -2156,45 +2323,52 @@
 do {								\
   if (yydebug)							\
     yy_stack_print ((Bottom), (Top));				\
-} while (0)
+} while (YYID (0))
 
 
 /*------------------------------------------------.
 | Report that the YYRULE is going to be reduced.  |
 `------------------------------------------------*/
 
-#if defined (__STDC__) || defined (__cplusplus)
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
 static void
-yy_reduce_print (int yyrule)
+yy_reduce_print (YYSTYPE *yyvsp, int yyrule)
 #else
 static void
-yy_reduce_print (yyrule)
+yy_reduce_print (yyvsp, yyrule)
+    YYSTYPE *yyvsp;
     int yyrule;
 #endif
 {
+  int yynrhs = yyr2[yyrule];
   int yyi;
-  unsigned int yylineno = yyrline[yyrule];
-  YYFPRINTF (stderr, "Reducing stack by rule %d (line %u), ",
-             yyrule - 1, yylineno);
-  /* Print the symbols being reduced, and their result.  */
-  for (yyi = yyprhs[yyrule]; 0 <= yyrhs[yyi]; yyi++)
-    YYFPRINTF (stderr, "%s ", yytname [yyrhs[yyi]]);
-  YYFPRINTF (stderr, "-> %s\n", yytname [yyr1[yyrule]]);
+  unsigned long int yylno = yyrline[yyrule];
+  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
+	     yyrule - 1, yylno);
+  /* The symbols being reduced.  */
+  for (yyi = 0; yyi < yynrhs; yyi++)
+    {
+      YYFPRINTF (stderr, "   $%d = ", yyi + 1);
+      yy_symbol_print (stderr, yyrhs[yyprhs[yyrule] + yyi],
+		       &(yyvsp[(yyi + 1) - (yynrhs)])
+		       		       );
+      YYFPRINTF (stderr, "\n");
+    }
 }
 
 # define YY_REDUCE_PRINT(Rule)		\
 do {					\
   if (yydebug)				\
-    yy_reduce_print (Rule);		\
-} while (0)
+    yy_reduce_print (yyvsp, Rule); \
+} while (YYID (0))
 
 /* Nonzero means print parse trace.  It is left uninitialized so that
    multiple parsers can coexist.  */
 int yydebug;
 #else /* !YYDEBUG */
 # define YYDPRINTF(Args)
-# define YYDSYMPRINT(Args)
-# define YYDSYMPRINTF(Title, Token, Value, Location)
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
 # define YY_STACK_PRINT(Bottom, Top)
 # define YY_REDUCE_PRINT(Rule)
 #endif /* !YYDEBUG */
@@ -2209,61 +2383,58 @@
    if the built-in stack extension method is used).
 
    Do not make this value too large; the results are undefined if
-   SIZE_MAX < YYSTACK_BYTES (YYMAXDEPTH)
+   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
    evaluated with infinite-precision integer arithmetic.  */
 
-#if YYMAXDEPTH == 0
-# undef YYMAXDEPTH
-#endif
-
 #ifndef YYMAXDEPTH
 # define YYMAXDEPTH 10000
 #endif
 
-
 
 #if YYERROR_VERBOSE
 
 # ifndef yystrlen
-#  if defined (__GLIBC__) && defined (_STRING_H)
+#  if defined __GLIBC__ && defined _STRING_H
 #   define yystrlen strlen
 #  else
 /* Return the length of YYSTR.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
 static YYSIZE_T
-#   if defined (__STDC__) || defined (__cplusplus)
 yystrlen (const char *yystr)
-#   else
+#else
+static YYSIZE_T
 yystrlen (yystr)
-     const char *yystr;
-#   endif
+    const char *yystr;
+#endif
 {
-  register const char *yys = yystr;
-
-  while (*yys++ != '\0')
+  YYSIZE_T yylen;
+  for (yylen = 0; yystr[yylen]; yylen++)
     continue;
-
-  return yys - yystr - 1;
+  return yylen;
 }
 #  endif
 # endif
 
 # ifndef yystpcpy
-#  if defined (__GLIBC__) && defined (_STRING_H) && defined (_GNU_SOURCE)
+#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
 #   define yystpcpy stpcpy
 #  else
 /* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
    YYDEST.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
 static char *
-#   if defined (__STDC__) || defined (__cplusplus)
 yystpcpy (char *yydest, const char *yysrc)
-#   else
+#else
+static char *
 yystpcpy (yydest, yysrc)
-     char *yydest;
-     const char *yysrc;
-#   endif
+    char *yydest;
+    const char *yysrc;
+#endif
 {
-  register char *yyd = yydest;
-  register const char *yys = yysrc;
+  char *yyd = yydest;
+  const char *yys = yysrc;
 
   while ((*yyd++ = *yys++) != '\0')
     continue;
@@ -2273,84 +2444,232 @@
 #  endif
 # endif
 
-#endif /* !YYERROR_VERBOSE */
+# ifndef yytnamerr
+/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
+   quotes and backslashes, so that it's suitable for yyerror.  The
+   heuristic is that double-quoting is unnecessary unless the string
+   contains an apostrophe, a comma, or backslash (other than
+   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
+   null, do not copy; instead, return the length of what the result
+   would have been.  */
+static YYSIZE_T
+yytnamerr (char *yyres, const char *yystr)
+{
+  if (*yystr == '"')
+    {
+      YYSIZE_T yyn = 0;
+      char const *yyp = yystr;
 
-
+      for (;;)
+	switch (*++yyp)
+	  {
+	  case '\'':
+	  case ',':
+	    goto do_not_strip_quotes;
+
+	  case '\\':
+	    if (*++yyp != '\\')
+	      goto do_not_strip_quotes;
+	    /* Fall through.  */
+	  default:
+	    if (yyres)
+	      yyres[yyn] = *yyp;
+	    yyn++;
+	    break;
+
+	  case '"':
+	    if (yyres)
+	      yyres[yyn] = '\0';
+	    return yyn;
+	  }
+    do_not_strip_quotes: ;
+    }
 
-#if YYDEBUG
-/*--------------------------------.
-| Print this symbol on YYOUTPUT.  |
-`--------------------------------*/
+  if (! yyres)
+    return yystrlen (yystr);
 
-#if defined (__STDC__) || defined (__cplusplus)
-static void
-yysymprint (FILE *yyoutput, int yytype, YYSTYPE *yyvaluep)
-#else
-static void
-yysymprint (yyoutput, yytype, yyvaluep)
-    FILE *yyoutput;
-    int yytype;
-    YYSTYPE *yyvaluep;
-#endif
+  return yystpcpy (yyres, yystr) - yyres;
+}
+# endif
+
+/* Copy into *YYMSG, which is of size *YYMSG_ALLOC, an error message
+   about the unexpected token YYTOKEN for the state stack whose top is
+   YYSSP.
+
+   Return 0 if *YYMSG was successfully written.  Return 1 if *YYMSG is
+   not large enough to hold the message.  In that case, also set
+   *YYMSG_ALLOC to the required number of bytes.  Return 2 if the
+   required number of bytes is too large to store.  */
+static int
+yysyntax_error (YYSIZE_T *yymsg_alloc, char **yymsg,
+                yytype_int16 *yyssp, int yytoken)
 {
-  /* Pacify ``unused variable'' warnings.  */
-  (void) yyvaluep;
+  YYSIZE_T yysize0 = yytnamerr (0, yytname[yytoken]);
+  YYSIZE_T yysize = yysize0;
+  YYSIZE_T yysize1;
+  enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
+  /* Internationalized format string. */
+  const char *yyformat = 0;
+  /* Arguments of yyformat. */
+  char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
+  /* Number of reported tokens (one for the "unexpected", one per
+     "expected"). */
+  int yycount = 0;
+
+  /* There are many possibilities here to consider:
+     - Assume YYFAIL is not used.  It's too flawed to consider.  See
+       <http://lists.gnu.org/archive/html/bison-patches/2009-12/msg00024.html>
+       for details.  YYERROR is fine as it does not invoke this
+       function.
+     - If this state is a consistent state with a default action, then
+       the only way this function was invoked is if the default action
+       is an error action.  In that case, don't check for expected
+       tokens because there are none.
+     - The only way there can be no lookahead present (in yychar) is if
+       this state is a consistent state with a default action.  Thus,
+       detecting the absence of a lookahead is sufficient to determine
+       that there is no unexpected or expected token to report.  In that
+       case, just report a simple "syntax error".
+     - Don't assume there isn't a lookahead just because this state is a
+       consistent state with a default action.  There might have been a
+       previous inconsistent state, consistent state with a non-default
+       action, or user semantic action that manipulated yychar.
+     - Of course, the expected token list depends on states to have
+       correct lookahead information, and it depends on the parser not
+       to perform extra reductions after fetching a lookahead from the
+       scanner and before detecting a syntax error.  Thus, state merging
+       (from LALR or IELR) and default reductions corrupt the expected
+       token list.  However, the list is correct for canonical LR with
+       one exception: it will still contain any token that will not be
+       accepted due to an error action in a later state.
+  */
+  if (yytoken != YYEMPTY)
+    {
+      int yyn = yypact[*yyssp];
+      yyarg[yycount++] = yytname[yytoken];
+      if (!yypact_value_is_default (yyn))
+        {
+          /* Start YYX at -YYN if negative to avoid negative indexes in
+             YYCHECK.  In other words, skip the first -YYN actions for
+             this state because they are default actions.  */
+          int yyxbegin = yyn < 0 ? -yyn : 0;
+          /* Stay within bounds of both yycheck and yytname.  */
+          int yychecklim = YYLAST - yyn + 1;
+          int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
+          int yyx;
+
+          for (yyx = yyxbegin; yyx < yyxend; ++yyx)
+            if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR
+                && !yytable_value_is_error (yytable[yyx + yyn]))
+              {
+                if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
+                  {
+                    yycount = 1;
+                    yysize = yysize0;
+                    break;
+                  }
+                yyarg[yycount++] = yytname[yyx];
+                yysize1 = yysize + yytnamerr (0, yytname[yyx]);
+                if (! (yysize <= yysize1
+                       && yysize1 <= YYSTACK_ALLOC_MAXIMUM))
+                  return 2;
+                yysize = yysize1;
+              }
+        }
+    }
 
-  if (yytype < YYNTOKENS)
+  switch (yycount)
     {
-      YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
-# ifdef YYPRINT
-      YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
-# endif
+# define YYCASE_(N, S)                      \
+      case N:                               \
+        yyformat = S;                       \
+      break
+      YYCASE_(0, YY_("syntax error"));
+      YYCASE_(1, YY_("syntax error, unexpected %s"));
+      YYCASE_(2, YY_("syntax error, unexpected %s, expecting %s"));
+      YYCASE_(3, YY_("syntax error, unexpected %s, expecting %s or %s"));
+      YYCASE_(4, YY_("syntax error, unexpected %s, expecting %s or %s or %s"));
+      YYCASE_(5, YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s"));
+# undef YYCASE_
     }
-  else
-    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
 
-  switch (yytype)
+  yysize1 = yysize + yystrlen (yyformat);
+  if (! (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM))
+    return 2;
+  yysize = yysize1;
+
+  if (*yymsg_alloc < yysize)
     {
-      default:
-        break;
+      *yymsg_alloc = 2 * yysize;
+      if (! (yysize <= *yymsg_alloc
+             && *yymsg_alloc <= YYSTACK_ALLOC_MAXIMUM))
+        *yymsg_alloc = YYSTACK_ALLOC_MAXIMUM;
+      return 1;
     }
-  YYFPRINTF (yyoutput, ")");
+
+  /* Avoid sprintf, as that infringes on the user's name space.
+     Don't have undefined behavior even if the translation
+     produced a string with the wrong number of "%s"s.  */
+  {
+    char *yyp = *yymsg;
+    int yyi = 0;
+    while ((*yyp = *yyformat) != '\0')
+      if (*yyp == '%' && yyformat[1] == 's' && yyi < yycount)
+        {
+          yyp += yytnamerr (yyp, yyarg[yyi++]);
+          yyformat += 2;
+        }
+      else
+        {
+          yyp++;
+          yyformat++;
+        }
+  }
+  return 0;
 }
+#endif /* YYERROR_VERBOSE */
 
-#endif /* ! YYDEBUG */
 /*-----------------------------------------------.
 | Release the memory associated to this symbol.  |
 `-----------------------------------------------*/
 
-#if defined (__STDC__) || defined (__cplusplus)
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
 static void
-yydestruct (int yytype, YYSTYPE *yyvaluep)
+yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)
 #else
 static void
-yydestruct (yytype, yyvaluep)
+yydestruct (yymsg, yytype, yyvaluep)
+    const char *yymsg;
     int yytype;
     YYSTYPE *yyvaluep;
 #endif
 {
-  /* Pacify ``unused variable'' warnings.  */
-  (void) yyvaluep;
+  YYUSE (yyvaluep);
+
+  if (!yymsg)
+    yymsg = "Deleting";
+  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
 
   switch (yytype)
     {
 
       default:
-        break;
+	break;
     }
 }
-
 
-/* Prevent warnings from -Wmissing-prototypes.  */
 
+/* Prevent warnings from -Wmissing-prototypes.  */
 #ifdef YYPARSE_PARAM
-# if defined (__STDC__) || defined (__cplusplus)
+#if defined __STDC__ || defined __cplusplus
 int yyparse (void *YYPARSE_PARAM);
-# else
+#else
 int yyparse ();
-# endif
+#endif
 #else /* ! YYPARSE_PARAM */
-#if defined (__STDC__) || defined (__cplusplus)
+#if defined __STDC__ || defined __cplusplus
 int yyparse (void);
 #else
 int yyparse ();
@@ -2358,7 +2677,6 @@
 #endif /* ! YYPARSE_PARAM */
 
 
-
 /* The lookahead symbol.  */
 int yychar;
 
@@ -2369,20 +2687,23 @@
 int yynerrs;
 
 
-
 /*----------.
 | yyparse.  |
 `----------*/
 
 #ifdef YYPARSE_PARAM
-# if defined (__STDC__) || defined (__cplusplus)
-int yyparse (void *YYPARSE_PARAM)
-# else
-int yyparse (YYPARSE_PARAM)
-  void *YYPARSE_PARAM;
-# endif
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void *YYPARSE_PARAM)
+#else
+int
+yyparse (YYPARSE_PARAM)
+    void *YYPARSE_PARAM;
+#endif
 #else /* ! YYPARSE_PARAM */
-#if defined (__STDC__) || defined (__cplusplus)
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
 int
 yyparse (void)
 #else
@@ -2392,60 +2713,66 @@
 #endif
 #endif
 {
-  
-  register int yystate;
-  register int yyn;
-  int yyresult;
-  /* Number of tokens to shift before error messages enabled.  */
-  int yyerrstatus;
-  /* Lookahead token as an internal (translated) token number.  */
-  int yytoken = 0;
-
-  /* Three stacks and their tools:
-     `yyss': related to states,
-     `yyvs': related to semantic values,
-     `yyls': related to locations.
-
-     Refer to the stacks thru separate pointers, to allow yyoverflow
-     to reallocate them elsewhere.  */
+    int yystate;
+    /* Number of tokens to shift before error messages enabled.  */
+    int yyerrstatus;
+
+    /* The stacks and their tools:
+       `yyss': related to states.
+       `yyvs': related to semantic values.
+
+       Refer to the stacks thru separate pointers, to allow yyoverflow
+       to reallocate them elsewhere.  */
+
+    /* The state stack.  */
+    yytype_int16 yyssa[YYINITDEPTH];
+    yytype_int16 *yyss;
+    yytype_int16 *yyssp;
+
+    /* The semantic value stack.  */
+    YYSTYPE yyvsa[YYINITDEPTH];
+    YYSTYPE *yyvs;
+    YYSTYPE *yyvsp;
 
-  /* The state stack.  */
-  short	yyssa[YYINITDEPTH];
-  short *yyss = yyssa;
-  register short *yyssp;
-
-  /* The semantic value stack.  */
-  YYSTYPE yyvsa[YYINITDEPTH];
-  YYSTYPE *yyvs = yyvsa;
-  register YYSTYPE *yyvsp;
-
-
-
-#define YYPOPSTACK   (yyvsp--, yyssp--)
-
-  YYSIZE_T yystacksize = YYINITDEPTH;
+    YYSIZE_T yystacksize;
 
+  int yyn;
+  int yyresult;
+  /* Lookahead token as an internal (translated) token number.  */
+  int yytoken;
   /* The variables used to return semantic value and location from the
      action routines.  */
   YYSTYPE yyval;
 
+#if YYERROR_VERBOSE
+  /* Buffer for error messages, and its allocated size.  */
+  char yymsgbuf[128];
+  char *yymsg = yymsgbuf;
+  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
+#endif
+
+#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
 
-  /* When reducing, the number of symbols on the RHS of the reduced
-     rule.  */
-  int yylen;
+  /* The number of symbols on the RHS of the reduced rule.
+     Keep to zero when no symbol should be popped.  */
+  int yylen = 0;
+
+  yytoken = 0;
+  yyss = yyssa;
+  yyvs = yyvsa;
+  yystacksize = YYINITDEPTH;
 
   YYDPRINTF ((stderr, "Starting parse\n"));
 
   yystate = 0;
   yyerrstatus = 0;
   yynerrs = 0;
-  yychar = YYEMPTY;		/* Cause a token to be read.  */
+  yychar = YYEMPTY; /* Cause a token to be read.  */
 
   /* Initialize stack pointers.
      Waste one element of value and location stack
      so that they stay on the same level as the state stack.
      The wasted elements are never initialized.  */
-
   yyssp = yyss;
   yyvsp = yyvs;
 
@@ -2456,8 +2783,7 @@
 `------------------------------------------------------------*/
  yynewstate:
   /* In all cases, when you get here, the value and location stacks
-     have just been pushed. so pushing a state here evens the stacks.
-     */
+     have just been pushed.  So pushing a state here evens the stacks.  */
   yyssp++;
 
  yysetstate:
@@ -2470,21 +2796,19 @@
 
 #ifdef yyoverflow
       {
-	/* Give user a chance to reallocate the stack. Use copies of
+	/* Give user a chance to reallocate the stack.  Use copies of
 	   these so that the &'s don't force the real ones into
 	   memory.  */
 	YYSTYPE *yyvs1 = yyvs;
-	short *yyss1 = yyss;
-
+	yytype_int16 *yyss1 = yyss;
 
 	/* Each stack pointer address is followed by the size of the
 	   data in use in that stack, in bytes.  This used to be a
 	   conditional around just the two extra args, but that might
 	   be undefined if yyoverflow is a macro.  */
-	yyoverflow ("parser stack overflow",
+	yyoverflow (YY_("memory exhausted"),
 		    &yyss1, yysize * sizeof (*yyssp),
 		    &yyvs1, yysize * sizeof (*yyvsp),
-
 		    &yystacksize);
 
 	yyss = yyss1;
@@ -2492,24 +2816,23 @@
       }
 #else /* no yyoverflow */
 # ifndef YYSTACK_RELOCATE
-      goto yyoverflowlab;
+      goto yyexhaustedlab;
 # else
       /* Extend the stack our own way.  */
       if (YYMAXDEPTH <= yystacksize)
-	goto yyoverflowlab;
+	goto yyexhaustedlab;
       yystacksize *= 2;
       if (YYMAXDEPTH < yystacksize)
 	yystacksize = YYMAXDEPTH;
 
       {
-	short *yyss1 = yyss;
+	yytype_int16 *yyss1 = yyss;
 	union yyalloc *yyptr =
 	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
 	if (! yyptr)
-	  goto yyoverflowlab;
-	YYSTACK_RELOCATE (yyss);
-	YYSTACK_RELOCATE (yyvs);
-
+	  goto yyexhaustedlab;
+	YYSTACK_RELOCATE (yyss_alloc, yyss);
+	YYSTACK_RELOCATE (yyvs_alloc, yyvs);
 #  undef YYSTACK_RELOCATE
 	if (yyss1 != yyssa)
 	  YYSTACK_FREE (yyss1);
@@ -2520,7 +2843,6 @@
       yyssp = yyss + yysize - 1;
       yyvsp = yyvs + yysize - 1;
 
-
       YYDPRINTF ((stderr, "Stack size increased to %lu\n",
 		  (unsigned long int) yystacksize));
 
@@ -2530,6 +2852,9 @@
 
   YYDPRINTF ((stderr, "Entering state %d\n", yystate));
 
+  if (yystate == YYFINAL)
+    YYACCEPT;
+
   goto yybackup;
 
 /*-----------.
@@ -2537,14 +2862,12 @@
 `-----------*/
 yybackup:
 
-/* Do appropriate processing given the current state.  */
-/* Read a lookahead token if we need one and don't already have one.  */
-/* yyresume: */
+  /* Do appropriate processing given the current state.  Read a
+     lookahead token if we need one and don't already have one.  */
 
   /* First try to decide what to do without reference to lookahead token.  */
-
   yyn = yypact[yystate];
-  if (yyn == YYPACT_NINF)
+  if (yypact_value_is_default (yyn))
     goto yydefault;
 
   /* Not known => get a lookahead token if don't already have one.  */
@@ -2564,7 +2887,7 @@
   else
     {
       yytoken = YYTRANSLATE (yychar);
-      YYDSYMPRINTF ("Next token is", yytoken, &yylval, &yylloc);
+      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
     }
 
   /* If the proper action on seeing token YYTOKEN is to reduce or to
@@ -2575,31 +2898,26 @@
   yyn = yytable[yyn];
   if (yyn <= 0)
     {
-      if (yyn == 0 || yyn == YYTABLE_NINF)
-	goto yyerrlab;
+      if (yytable_value_is_error (yyn))
+        goto yyerrlab;
       yyn = -yyn;
       goto yyreduce;
     }
 
-  if (yyn == YYFINAL)
-    YYACCEPT;
-
-  /* Shift the lookahead token.  */
-  YYDPRINTF ((stderr, "Shifting token %s, ", yytname[yytoken]));
-
-  /* Discard the token being shifted unless it is eof.  */
-  if (yychar != YYEOF)
-    yychar = YYEMPTY;
-
-  *++yyvsp = yylval;
-
-
   /* Count tokens shifted since error; after three, turn off error
      status.  */
   if (yyerrstatus)
     yyerrstatus--;
 
+  /* Shift the lookahead token.  */
+  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
+
+  /* Discard the shifted token.  */
+  yychar = YYEMPTY;
+
   yystate = yyn;
+  *++yyvsp = yylval;
+
   goto yynewstate;
 
 
@@ -2635,14 +2953,18 @@
   switch (yyn)
     {
         case 2:
+
+/* Line 1806 of yacc.c  */
 #line 324 "c-parse.y"
     { if (pedantic)
 		    pedwarn ("ISO C forbids an empty source file");
 		  finish_file ();
-		;}
+		}
     break;
 
   case 3:
+
+/* Line 1806 of yacc.c  */
 #line 329 "c-parse.y"
     {
 		  /* In case there were missing closebraces,
@@ -2654,482 +2976,638 @@
 		     still works without it.  */
 		  finish_fname_decls ();
                   finish_file ();
-		;}
+		}
     break;
 
   case 4:
+
+/* Line 1806 of yacc.c  */
 #line 347 "c-parse.y"
-    {yyval.ttype = NULL_TREE; ;}
+    {(yyval.ttype) = NULL_TREE; }
     break;
 
   case 6:
+
+/* Line 1806 of yacc.c  */
 #line 348 "c-parse.y"
-    {yyval.ttype = NULL_TREE; ggc_collect(); ;}
+    {(yyval.ttype) = NULL_TREE; ggc_collect(); }
     break;
 
   case 8:
+
+/* Line 1806 of yacc.c  */
 #line 353 "c-parse.y"
-    { parsing_iso_function_signature = false; ;}
+    { parsing_iso_function_signature = false; }
     break;
 
   case 11:
+
+/* Line 1806 of yacc.c  */
 #line 360 "c-parse.y"
-    { STRIP_NOPS (yyvsp[-2].ttype);
-		  if ((TREE_CODE (yyvsp[-2].ttype) == ADDR_EXPR
-		       && TREE_CODE (TREE_OPERAND (yyvsp[-2].ttype, 0)) == STRING_CST)
-		      || TREE_CODE (yyvsp[-2].ttype) == STRING_CST)
-		    assemble_asm (yyvsp[-2].ttype);
+    { STRIP_NOPS ((yyvsp[(3) - (5)].ttype));
+		  if ((TREE_CODE ((yyvsp[(3) - (5)].ttype)) == ADDR_EXPR
+		       && TREE_CODE (TREE_OPERAND ((yyvsp[(3) - (5)].ttype), 0)) == STRING_CST)
+		      || TREE_CODE ((yyvsp[(3) - (5)].ttype)) == STRING_CST)
+		    assemble_asm ((yyvsp[(3) - (5)].ttype));
 		  else
-		    error ("argument of `asm' is not a constant string"); ;}
+		    error ("argument of `asm' is not a constant string"); }
     break;
 
   case 12:
+
+/* Line 1806 of yacc.c  */
 #line 368 "c-parse.y"
-    { RESTORE_EXT_FLAGS (yyvsp[-1].ttype); ;}
+    { RESTORE_EXT_FLAGS ((yyvsp[(1) - (2)].ttype)); }
     break;
 
   case 13:
+
+/* Line 1806 of yacc.c  */
 #line 373 "c-parse.y"
     { if (pedantic)
 		    error ("ISO C forbids data definition with no type or storage class");
 		  else
 		    warning ("data definition has no type or storage class");
 
-		  POP_DECLSPEC_STACK; ;}
+		  POP_DECLSPEC_STACK; }
     break;
 
   case 14:
+
+/* Line 1806 of yacc.c  */
 #line 380 "c-parse.y"
-    { POP_DECLSPEC_STACK; ;}
+    { POP_DECLSPEC_STACK; }
     break;
 
   case 15:
+
+/* Line 1806 of yacc.c  */
 #line 382 "c-parse.y"
-    { POP_DECLSPEC_STACK; ;}
+    { POP_DECLSPEC_STACK; }
     break;
 
   case 16:
+
+/* Line 1806 of yacc.c  */
 #line 384 "c-parse.y"
-    { shadow_tag (yyvsp[-1].ttype); ;}
+    { shadow_tag ((yyvsp[(1) - (2)].ttype)); }
     break;
 
   case 19:
+
+/* Line 1806 of yacc.c  */
 #line 388 "c-parse.y"
     { if (pedantic)
-		    pedwarn ("ISO C does not allow extra `;' outside of a function"); ;}
+		    pedwarn ("ISO C does not allow extra `;' outside of a function"); }
     break;
 
   case 20:
+
+/* Line 1806 of yacc.c  */
 #line 394 "c-parse.y"
-    { if (! start_function (current_declspecs, yyvsp[0].ttype,
+    { if (! start_function (current_declspecs, (yyvsp[(3) - (3)].ttype),
 					all_prefix_attributes))
 		    YYERROR1;
-		;}
+		}
     break;
 
   case 21:
+
+/* Line 1806 of yacc.c  */
 #line 399 "c-parse.y"
-    { store_parm_decls (); ;}
+    { store_parm_decls (); }
     break;
 
   case 22:
+
+/* Line 1806 of yacc.c  */
 #line 401 "c-parse.y"
-    { DECL_SOURCE_FILE (current_function_decl) = yyvsp[-2].filename;
-		  DECL_SOURCE_LINE (current_function_decl) = yyvsp[-1].lineno;
+    { DECL_SOURCE_FILE (current_function_decl) = (yyvsp[(7) - (9)].filename);
+		  DECL_SOURCE_LINE (current_function_decl) = (yyvsp[(8) - (9)].lineno);
 		  finish_function (0, 1);
-		  POP_DECLSPEC_STACK; ;}
+		  POP_DECLSPEC_STACK; }
     break;
 
   case 23:
+
+/* Line 1806 of yacc.c  */
 #line 406 "c-parse.y"
-    { POP_DECLSPEC_STACK; ;}
+    { POP_DECLSPEC_STACK; }
     break;
 
   case 24:
+
+/* Line 1806 of yacc.c  */
 #line 408 "c-parse.y"
-    { if (! start_function (current_declspecs, yyvsp[0].ttype,
+    { if (! start_function (current_declspecs, (yyvsp[(3) - (3)].ttype),
 					all_prefix_attributes))
 		    YYERROR1;
-		;}
+		}
     break;
 
   case 25:
+
+/* Line 1806 of yacc.c  */
 #line 413 "c-parse.y"
-    { store_parm_decls (); ;}
+    { store_parm_decls (); }
     break;
 
   case 26:
+
+/* Line 1806 of yacc.c  */
 #line 415 "c-parse.y"
-    { DECL_SOURCE_FILE (current_function_decl) = yyvsp[-2].filename;
-		  DECL_SOURCE_LINE (current_function_decl) = yyvsp[-1].lineno;
+    { DECL_SOURCE_FILE (current_function_decl) = (yyvsp[(7) - (9)].filename);
+		  DECL_SOURCE_LINE (current_function_decl) = (yyvsp[(8) - (9)].lineno);
 		  finish_function (0, 1);
-		  POP_DECLSPEC_STACK; ;}
+		  POP_DECLSPEC_STACK; }
     break;
 
   case 27:
+
+/* Line 1806 of yacc.c  */
 #line 420 "c-parse.y"
-    { POP_DECLSPEC_STACK; ;}
+    { POP_DECLSPEC_STACK; }
     break;
 
   case 28:
+
+/* Line 1806 of yacc.c  */
 #line 422 "c-parse.y"
-    { if (! start_function (NULL_TREE, yyvsp[0].ttype,
+    { if (! start_function (NULL_TREE, (yyvsp[(2) - (2)].ttype),
 					all_prefix_attributes))
 		    YYERROR1;
-		;}
+		}
     break;
 
   case 29:
+
+/* Line 1806 of yacc.c  */
 #line 427 "c-parse.y"
-    { store_parm_decls (); ;}
+    { store_parm_decls (); }
     break;
 
   case 30:
+
+/* Line 1806 of yacc.c  */
 #line 429 "c-parse.y"
-    { DECL_SOURCE_FILE (current_function_decl) = yyvsp[-2].filename;
-		  DECL_SOURCE_LINE (current_function_decl) = yyvsp[-1].lineno;
+    { DECL_SOURCE_FILE (current_function_decl) = (yyvsp[(6) - (8)].filename);
+		  DECL_SOURCE_LINE (current_function_decl) = (yyvsp[(7) - (8)].lineno);
 		  finish_function (0, 1);
-		  POP_DECLSPEC_STACK; ;}
+		  POP_DECLSPEC_STACK; }
     break;
 
   case 31:
+
+/* Line 1806 of yacc.c  */
 #line 434 "c-parse.y"
-    { POP_DECLSPEC_STACK; ;}
+    { POP_DECLSPEC_STACK; }
     break;
 
   case 34:
+
+/* Line 1806 of yacc.c  */
 #line 443 "c-parse.y"
-    { yyval.code = ADDR_EXPR; ;}
+    { (yyval.code) = ADDR_EXPR; }
     break;
 
   case 35:
+
+/* Line 1806 of yacc.c  */
 #line 445 "c-parse.y"
-    { yyval.code = NEGATE_EXPR; ;}
+    { (yyval.code) = NEGATE_EXPR; }
     break;
 
   case 36:
+
+/* Line 1806 of yacc.c  */
 #line 447 "c-parse.y"
-    { yyval.code = CONVERT_EXPR;
+    { (yyval.code) = CONVERT_EXPR;
   if (warn_traditional && !in_system_header)
     warning ("traditional C rejects the unary plus operator");
-		;}
+		}
     break;
 
   case 37:
+
+/* Line 1806 of yacc.c  */
 #line 452 "c-parse.y"
-    { yyval.code = PREINCREMENT_EXPR; ;}
+    { (yyval.code) = PREINCREMENT_EXPR; }
     break;
 
   case 38:
+
+/* Line 1806 of yacc.c  */
 #line 454 "c-parse.y"
-    { yyval.code = PREDECREMENT_EXPR; ;}
+    { (yyval.code) = PREDECREMENT_EXPR; }
     break;
 
   case 39:
+
+/* Line 1806 of yacc.c  */
 #line 456 "c-parse.y"
-    { yyval.code = BIT_NOT_EXPR; ;}
+    { (yyval.code) = BIT_NOT_EXPR; }
     break;
 
   case 40:
+
+/* Line 1806 of yacc.c  */
 #line 458 "c-parse.y"
-    { yyval.code = TRUTH_NOT_EXPR; ;}
+    { (yyval.code) = TRUTH_NOT_EXPR; }
     break;
 
   case 41:
+
+/* Line 1806 of yacc.c  */
 #line 462 "c-parse.y"
-    { yyval.ttype = build_compound_expr (yyvsp[0].ttype); ;}
+    { (yyval.ttype) = build_compound_expr ((yyvsp[(1) - (1)].ttype)); }
     break;
 
   case 42:
+
+/* Line 1806 of yacc.c  */
 #line 467 "c-parse.y"
-    { yyval.ttype = NULL_TREE; ;}
+    { (yyval.ttype) = NULL_TREE; }
     break;
 
   case 44:
+
+/* Line 1806 of yacc.c  */
 #line 473 "c-parse.y"
-    { yyval.ttype = build_tree_list (NULL_TREE, yyvsp[0].ttype); ;}
+    { (yyval.ttype) = build_tree_list (NULL_TREE, (yyvsp[(1) - (1)].ttype)); }
     break;
 
   case 45:
+
+/* Line 1806 of yacc.c  */
 #line 475 "c-parse.y"
-    { chainon (yyvsp[-2].ttype, build_tree_list (NULL_TREE, yyvsp[0].ttype)); ;}
+    { chainon ((yyvsp[(1) - (3)].ttype), build_tree_list (NULL_TREE, (yyvsp[(3) - (3)].ttype))); }
     break;
 
   case 47:
+
+/* Line 1806 of yacc.c  */
 #line 481 "c-parse.y"
-    { yyval.ttype = build_indirect_ref (yyvsp[0].ttype, "unary *"); ;}
+    { (yyval.ttype) = build_indirect_ref ((yyvsp[(2) - (2)].ttype), "unary *"); }
     break;
 
   case 48:
+
+/* Line 1806 of yacc.c  */
 #line 484 "c-parse.y"
-    { yyval.ttype = yyvsp[0].ttype;
-		  RESTORE_EXT_FLAGS (yyvsp[-1].ttype); ;}
+    { (yyval.ttype) = (yyvsp[(2) - (2)].ttype);
+		  RESTORE_EXT_FLAGS ((yyvsp[(1) - (2)].ttype)); }
     break;
 
   case 49:
+
+/* Line 1806 of yacc.c  */
 #line 487 "c-parse.y"
-    { yyval.ttype = build_unary_op (yyvsp[-1].code, yyvsp[0].ttype, 0);
-		  overflow_warning (yyval.ttype); ;}
+    { (yyval.ttype) = build_unary_op ((yyvsp[(1) - (2)].code), (yyvsp[(2) - (2)].ttype), 0);
+		  overflow_warning ((yyval.ttype)); }
     break;
 
   case 50:
+
+/* Line 1806 of yacc.c  */
 #line 491 "c-parse.y"
-    { yyval.ttype = finish_label_address_expr (yyvsp[0].ttype); ;}
+    { (yyval.ttype) = finish_label_address_expr ((yyvsp[(2) - (2)].ttype)); }
     break;
 
   case 51:
+
+/* Line 1806 of yacc.c  */
 #line 493 "c-parse.y"
     { skip_evaluation--;
-		  if (TREE_CODE (yyvsp[0].ttype) == COMPONENT_REF
-		      && DECL_C_BIT_FIELD (TREE_OPERAND (yyvsp[0].ttype, 1)))
+		  if (TREE_CODE ((yyvsp[(2) - (2)].ttype)) == COMPONENT_REF
+		      && DECL_C_BIT_FIELD (TREE_OPERAND ((yyvsp[(2) - (2)].ttype), 1)))
 		    error ("`sizeof' applied to a bit-field");
-		  yyval.ttype = c_sizeof (TREE_TYPE (yyvsp[0].ttype)); ;}
+		  (yyval.ttype) = c_sizeof (TREE_TYPE ((yyvsp[(2) - (2)].ttype))); }
     break;
 
   case 52:
+
+/* Line 1806 of yacc.c  */
 #line 499 "c-parse.y"
     { skip_evaluation--;
-		  yyval.ttype = c_sizeof (groktypename (yyvsp[-1].ttype)); ;}
+		  (yyval.ttype) = c_sizeof (groktypename ((yyvsp[(3) - (4)].ttype))); }
     break;
 
   case 53:
+
+/* Line 1806 of yacc.c  */
 #line 502 "c-parse.y"
     { skip_evaluation--;
-		  yyval.ttype = c_alignof_expr (yyvsp[0].ttype); ;}
+		  (yyval.ttype) = c_alignof_expr ((yyvsp[(2) - (2)].ttype)); }
     break;
 
   case 54:
+
+/* Line 1806 of yacc.c  */
 #line 505 "c-parse.y"
     { skip_evaluation--;
-		  yyval.ttype = c_alignof (groktypename (yyvsp[-1].ttype)); ;}
+		  (yyval.ttype) = c_alignof (groktypename ((yyvsp[(3) - (4)].ttype))); }
     break;
 
   case 55:
+
+/* Line 1806 of yacc.c  */
 #line 508 "c-parse.y"
-    { yyval.ttype = build_unary_op (REALPART_EXPR, yyvsp[0].ttype, 0); ;}
+    { (yyval.ttype) = build_unary_op (REALPART_EXPR, (yyvsp[(2) - (2)].ttype), 0); }
     break;
 
   case 56:
+
+/* Line 1806 of yacc.c  */
 #line 510 "c-parse.y"
-    { yyval.ttype = build_unary_op (IMAGPART_EXPR, yyvsp[0].ttype, 0); ;}
+    { (yyval.ttype) = build_unary_op (IMAGPART_EXPR, (yyvsp[(2) - (2)].ttype), 0); }
     break;
 
   case 57:
+
+/* Line 1806 of yacc.c  */
 #line 514 "c-parse.y"
-    { skip_evaluation++; ;}
+    { skip_evaluation++; }
     break;
 
   case 58:
+
+/* Line 1806 of yacc.c  */
 #line 518 "c-parse.y"
-    { skip_evaluation++; ;}
+    { skip_evaluation++; }
     break;
 
   case 59:
+
+/* Line 1806 of yacc.c  */
 #line 522 "c-parse.y"
-    { skip_evaluation++; ;}
+    { skip_evaluation++; }
     break;
 
   case 61:
+
+/* Line 1806 of yacc.c  */
 #line 528 "c-parse.y"
-    { yyval.ttype = c_cast_expr (yyvsp[-2].ttype, yyvsp[0].ttype); ;}
+    { (yyval.ttype) = c_cast_expr ((yyvsp[(2) - (4)].ttype), (yyvsp[(4) - (4)].ttype)); }
     break;
 
   case 63:
+
+/* Line 1806 of yacc.c  */
 #line 534 "c-parse.y"
-    { yyval.ttype = parser_build_binary_op (yyvsp[-1].code, yyvsp[-2].ttype, yyvsp[0].ttype); ;}
+    { (yyval.ttype) = parser_build_binary_op ((yyvsp[(2) - (3)].code), (yyvsp[(1) - (3)].ttype), (yyvsp[(3) - (3)].ttype)); }
     break;
 
   case 64:
+
+/* Line 1806 of yacc.c  */
 #line 536 "c-parse.y"
-    { yyval.ttype = parser_build_binary_op (yyvsp[-1].code, yyvsp[-2].ttype, yyvsp[0].ttype); ;}
+    { (yyval.ttype) = parser_build_binary_op ((yyvsp[(2) - (3)].code), (yyvsp[(1) - (3)].ttype), (yyvsp[(3) - (3)].ttype)); }
     break;
 
   case 65:
+
+/* Line 1806 of yacc.c  */
 #line 538 "c-parse.y"
-    { yyval.ttype = parser_build_binary_op (yyvsp[-1].code, yyvsp[-2].ttype, yyvsp[0].ttype); ;}
+    { (yyval.ttype) = parser_build_binary_op ((yyvsp[(2) - (3)].code), (yyvsp[(1) - (3)].ttype), (yyvsp[(3) - (3)].ttype)); }
     break;
 
   case 66:
+
+/* Line 1806 of yacc.c  */
 #line 540 "c-parse.y"
-    { yyval.ttype = parser_build_binary_op (yyvsp[-1].code, yyvsp[-2].ttype, yyvsp[0].ttype); ;}
+    { (yyval.ttype) = parser_build_binary_op ((yyvsp[(2) - (3)].code), (yyvsp[(1) - (3)].ttype), (yyvsp[(3) - (3)].ttype)); }
     break;
 
   case 67:
+
+/* Line 1806 of yacc.c  */
 #line 542 "c-parse.y"
-    { yyval.ttype = parser_build_binary_op (yyvsp[-1].code, yyvsp[-2].ttype, yyvsp[0].ttype); ;}
+    { (yyval.ttype) = parser_build_binary_op ((yyvsp[(2) - (3)].code), (yyvsp[(1) - (3)].ttype), (yyvsp[(3) - (3)].ttype)); }
     break;
 
   case 68:
+
+/* Line 1806 of yacc.c  */
 #line 544 "c-parse.y"
-    { yyval.ttype = parser_build_binary_op (yyvsp[-1].code, yyvsp[-2].ttype, yyvsp[0].ttype); ;}
+    { (yyval.ttype) = parser_build_binary_op ((yyvsp[(2) - (3)].code), (yyvsp[(1) - (3)].ttype), (yyvsp[(3) - (3)].ttype)); }
     break;
 
   case 69:
+
+/* Line 1806 of yacc.c  */
 #line 546 "c-parse.y"
-    { yyval.ttype = parser_build_binary_op (yyvsp[-1].code, yyvsp[-2].ttype, yyvsp[0].ttype); ;}
+    { (yyval.ttype) = parser_build_binary_op ((yyvsp[(2) - (3)].code), (yyvsp[(1) - (3)].ttype), (yyvsp[(3) - (3)].ttype)); }
     break;
 
   case 70:
+
+/* Line 1806 of yacc.c  */
 #line 548 "c-parse.y"
-    { yyval.ttype = parser_build_binary_op (yyvsp[-1].code, yyvsp[-2].ttype, yyvsp[0].ttype); ;}
+    { (yyval.ttype) = parser_build_binary_op ((yyvsp[(2) - (3)].code), (yyvsp[(1) - (3)].ttype), (yyvsp[(3) - (3)].ttype)); }
     break;
 
   case 71:
+
+/* Line 1806 of yacc.c  */
 #line 550 "c-parse.y"
-    { yyval.ttype = parser_build_binary_op (yyvsp[-1].code, yyvsp[-2].ttype, yyvsp[0].ttype); ;}
+    { (yyval.ttype) = parser_build_binary_op ((yyvsp[(2) - (3)].code), (yyvsp[(1) - (3)].ttype), (yyvsp[(3) - (3)].ttype)); }
     break;
 
   case 72:
+
+/* Line 1806 of yacc.c  */
 #line 552 "c-parse.y"
-    { yyval.ttype = parser_build_binary_op (yyvsp[-1].code, yyvsp[-2].ttype, yyvsp[0].ttype); ;}
+    { (yyval.ttype) = parser_build_binary_op ((yyvsp[(2) - (3)].code), (yyvsp[(1) - (3)].ttype), (yyvsp[(3) - (3)].ttype)); }
     break;
 
   case 73:
+
+/* Line 1806 of yacc.c  */
 #line 554 "c-parse.y"
-    { yyval.ttype = parser_build_binary_op (yyvsp[-1].code, yyvsp[-2].ttype, yyvsp[0].ttype); ;}
+    { (yyval.ttype) = parser_build_binary_op ((yyvsp[(2) - (3)].code), (yyvsp[(1) - (3)].ttype), (yyvsp[(3) - (3)].ttype)); }
     break;
 
   case 74:
+
+/* Line 1806 of yacc.c  */
 #line 556 "c-parse.y"
-    { yyval.ttype = parser_build_binary_op (yyvsp[-1].code, yyvsp[-2].ttype, yyvsp[0].ttype); ;}
+    { (yyval.ttype) = parser_build_binary_op ((yyvsp[(2) - (3)].code), (yyvsp[(1) - (3)].ttype), (yyvsp[(3) - (3)].ttype)); }
     break;
 
   case 75:
+
+/* Line 1806 of yacc.c  */
 #line 558 "c-parse.y"
-    { yyvsp[-1].ttype = c_common_truthvalue_conversion
-		    (default_conversion (yyvsp[-1].ttype));
-		  skip_evaluation += yyvsp[-1].ttype == boolean_false_node; ;}
+    { (yyvsp[(1) - (2)].ttype) = c_common_truthvalue_conversion
+		    (default_conversion ((yyvsp[(1) - (2)].ttype)));
+		  skip_evaluation += (yyvsp[(1) - (2)].ttype) == boolean_false_node; }
     break;
 
   case 76:
+
+/* Line 1806 of yacc.c  */
 #line 562 "c-parse.y"
-    { skip_evaluation -= yyvsp[-3].ttype == boolean_false_node;
-		  yyval.ttype = parser_build_binary_op (TRUTH_ANDIF_EXPR, yyvsp[-3].ttype, yyvsp[0].ttype); ;}
+    { skip_evaluation -= (yyvsp[(1) - (4)].ttype) == boolean_false_node;
+		  (yyval.ttype) = parser_build_binary_op (TRUTH_ANDIF_EXPR, (yyvsp[(1) - (4)].ttype), (yyvsp[(4) - (4)].ttype)); }
     break;
 
   case 77:
+
+/* Line 1806 of yacc.c  */
 #line 565 "c-parse.y"
-    { yyvsp[-1].ttype = c_common_truthvalue_conversion
-		    (default_conversion (yyvsp[-1].ttype));
-		  skip_evaluation += yyvsp[-1].ttype == boolean_true_node; ;}
+    { (yyvsp[(1) - (2)].ttype) = c_common_truthvalue_conversion
+		    (default_conversion ((yyvsp[(1) - (2)].ttype)));
+		  skip_evaluation += (yyvsp[(1) - (2)].ttype) == boolean_true_node; }
     break;
 
   case 78:
+
+/* Line 1806 of yacc.c  */
 #line 569 "c-parse.y"
-    { skip_evaluation -= yyvsp[-3].ttype == boolean_true_node;
-		  yyval.ttype = parser_build_binary_op (TRUTH_ORIF_EXPR, yyvsp[-3].ttype, yyvsp[0].ttype); ;}
+    { skip_evaluation -= (yyvsp[(1) - (4)].ttype) == boolean_true_node;
+		  (yyval.ttype) = parser_build_binary_op (TRUTH_ORIF_EXPR, (yyvsp[(1) - (4)].ttype), (yyvsp[(4) - (4)].ttype)); }
     break;
 
   case 79:
+
+/* Line 1806 of yacc.c  */
 #line 572 "c-parse.y"
-    { yyvsp[-1].ttype = c_common_truthvalue_conversion
-		    (default_conversion (yyvsp[-1].ttype));
-		  skip_evaluation += yyvsp[-1].ttype == boolean_false_node; ;}
+    { (yyvsp[(1) - (2)].ttype) = c_common_truthvalue_conversion
+		    (default_conversion ((yyvsp[(1) - (2)].ttype)));
+		  skip_evaluation += (yyvsp[(1) - (2)].ttype) == boolean_false_node; }
     break;
 
   case 80:
+
+/* Line 1806 of yacc.c  */
 #line 576 "c-parse.y"
-    { skip_evaluation += ((yyvsp[-4].ttype == boolean_true_node)
-				      - (yyvsp[-4].ttype == boolean_false_node)); ;}
+    { skip_evaluation += (((yyvsp[(1) - (5)].ttype) == boolean_true_node)
+				      - ((yyvsp[(1) - (5)].ttype) == boolean_false_node)); }
     break;
 
   case 81:
+
+/* Line 1806 of yacc.c  */
 #line 579 "c-parse.y"
-    { skip_evaluation -= yyvsp[-6].ttype == boolean_true_node;
-		  yyval.ttype = build_conditional_expr (yyvsp[-6].ttype, yyvsp[-3].ttype, yyvsp[0].ttype); ;}
+    { skip_evaluation -= (yyvsp[(1) - (7)].ttype) == boolean_true_node;
+		  (yyval.ttype) = build_conditional_expr ((yyvsp[(1) - (7)].ttype), (yyvsp[(4) - (7)].ttype), (yyvsp[(7) - (7)].ttype)); }
     break;
 
   case 82:
+
+/* Line 1806 of yacc.c  */
 #line 582 "c-parse.y"
     { if (pedantic)
 		    pedwarn ("ISO C forbids omitting the middle term of a ?: expression");
 		  /* Make sure first operand is calculated only once.  */
-		  yyvsp[0].ttype = save_expr (yyvsp[-1].ttype);
-		  yyvsp[-1].ttype = c_common_truthvalue_conversion
-		    (default_conversion (yyvsp[0].ttype));
-		  skip_evaluation += yyvsp[-1].ttype == boolean_true_node; ;}
+		  (yyvsp[(2) - (2)].ttype) = save_expr ((yyvsp[(1) - (2)].ttype));
+		  (yyvsp[(1) - (2)].ttype) = c_common_truthvalue_conversion
+		    (default_conversion ((yyvsp[(2) - (2)].ttype)));
+		  skip_evaluation += (yyvsp[(1) - (2)].ttype) == boolean_true_node; }
     break;
 
   case 83:
+
+/* Line 1806 of yacc.c  */
 #line 590 "c-parse.y"
-    { skip_evaluation -= yyvsp[-4].ttype == boolean_true_node;
-		  yyval.ttype = build_conditional_expr (yyvsp[-4].ttype, yyvsp[-3].ttype, yyvsp[0].ttype); ;}
+    { skip_evaluation -= (yyvsp[(1) - (5)].ttype) == boolean_true_node;
+		  (yyval.ttype) = build_conditional_expr ((yyvsp[(1) - (5)].ttype), (yyvsp[(2) - (5)].ttype), (yyvsp[(5) - (5)].ttype)); }
     break;
 
   case 84:
+
+/* Line 1806 of yacc.c  */
 #line 593 "c-parse.y"
     { char class;
-		  yyval.ttype = build_modify_expr (yyvsp[-2].ttype, NOP_EXPR, yyvsp[0].ttype);
-		  class = TREE_CODE_CLASS (TREE_CODE (yyval.ttype));
+		  (yyval.ttype) = build_modify_expr ((yyvsp[(1) - (3)].ttype), NOP_EXPR, (yyvsp[(3) - (3)].ttype));
+		  class = TREE_CODE_CLASS (TREE_CODE ((yyval.ttype)));
 		  if (IS_EXPR_CODE_CLASS (class))
-		    C_SET_EXP_ORIGINAL_CODE (yyval.ttype, MODIFY_EXPR);
-		;}
+		    C_SET_EXP_ORIGINAL_CODE ((yyval.ttype), MODIFY_EXPR);
+		}
     break;
 
   case 85:
+
+/* Line 1806 of yacc.c  */
 #line 600 "c-parse.y"
     { char class;
-		  yyval.ttype = build_modify_expr (yyvsp[-2].ttype, yyvsp[-1].code, yyvsp[0].ttype);
+		  (yyval.ttype) = build_modify_expr ((yyvsp[(1) - (3)].ttype), (yyvsp[(2) - (3)].code), (yyvsp[(3) - (3)].ttype));
 		  /* This inhibits warnings in
 		     c_common_truthvalue_conversion.  */
-		  class = TREE_CODE_CLASS (TREE_CODE (yyval.ttype));
+		  class = TREE_CODE_CLASS (TREE_CODE ((yyval.ttype)));
 		  if (IS_EXPR_CODE_CLASS (class))
-		    C_SET_EXP_ORIGINAL_CODE (yyval.ttype, ERROR_MARK);
-		;}
+		    C_SET_EXP_ORIGINAL_CODE ((yyval.ttype), ERROR_MARK);
+		}
     break;
 
   case 86:
+
+/* Line 1806 of yacc.c  */
 #line 612 "c-parse.y"
     {
 		  if (yychar == YYEMPTY)
 		    yychar = YYLEX;
-		  yyval.ttype = build_external_ref (yyvsp[0].ttype, yychar == '(');
-		;}
+		  (yyval.ttype) = build_external_ref ((yyvsp[(1) - (1)].ttype), yychar == '(');
+		}
     break;
 
   case 88:
+
+/* Line 1806 of yacc.c  */
 #line 619 "c-parse.y"
-    { yyval.ttype = fix_string_type (yyval.ttype); ;}
+    { (yyval.ttype) = fix_string_type ((yyval.ttype)); }
     break;
 
   case 89:
+
+/* Line 1806 of yacc.c  */
 #line 621 "c-parse.y"
-    { yyval.ttype = fname_decl (C_RID_CODE (yyval.ttype), yyval.ttype); ;}
+    { (yyval.ttype) = fname_decl (C_RID_CODE ((yyval.ttype)), (yyval.ttype)); }
     break;
 
   case 90:
+
+/* Line 1806 of yacc.c  */
 #line 623 "c-parse.y"
     { start_init (NULL_TREE, NULL, 0);
-		  yyvsp[-2].ttype = groktypename (yyvsp[-2].ttype);
-		  really_start_incremental_init (yyvsp[-2].ttype); ;}
+		  (yyvsp[(2) - (4)].ttype) = groktypename ((yyvsp[(2) - (4)].ttype));
+		  really_start_incremental_init ((yyvsp[(2) - (4)].ttype)); }
     break;
 
   case 91:
+
+/* Line 1806 of yacc.c  */
 #line 627 "c-parse.y"
     { tree constructor = pop_init_level (0);
-		  tree type = yyvsp[-5].ttype;
+		  tree type = (yyvsp[(2) - (7)].ttype);
 		  finish_init ();
 
 		  if (pedantic && ! flag_isoc99)
 		    pedwarn ("ISO C89 forbids compound literals");
-		  yyval.ttype = build_compound_literal (type, constructor);
-		;}
+		  (yyval.ttype) = build_compound_literal (type, constructor);
+		}
     break;
 
   case 92:
+
+/* Line 1806 of yacc.c  */
 #line 636 "c-parse.y"
-    { char class = TREE_CODE_CLASS (TREE_CODE (yyvsp[-1].ttype));
+    { char class = TREE_CODE_CLASS (TREE_CODE ((yyvsp[(2) - (3)].ttype)));
 		  if (IS_EXPR_CODE_CLASS (class))
-		    C_SET_EXP_ORIGINAL_CODE (yyvsp[-1].ttype, ERROR_MARK);
-		  yyval.ttype = yyvsp[-1].ttype; ;}
+		    C_SET_EXP_ORIGINAL_CODE ((yyvsp[(2) - (3)].ttype), ERROR_MARK);
+		  (yyval.ttype) = (yyvsp[(2) - (3)].ttype); }
     break;
 
   case 93:
+
+/* Line 1806 of yacc.c  */
 #line 641 "c-parse.y"
-    { yyval.ttype = error_mark_node; ;}
+    { (yyval.ttype) = error_mark_node; }
     break;
 
   case 94:
+
+/* Line 1806 of yacc.c  */
 #line 643 "c-parse.y"
     { tree saved_last_tree;
 
@@ -3137,1200 +3615,1582 @@
 		     pedwarn ("ISO C forbids braced-groups within expressions");
 		  pop_label_level ();
 
-		  saved_last_tree = COMPOUND_BODY (yyvsp[-2].ttype);
-		  RECHAIN_STMTS (yyvsp[-2].ttype, COMPOUND_BODY (yyvsp[-2].ttype));
+		  saved_last_tree = COMPOUND_BODY ((yyvsp[(1) - (3)].ttype));
+		  RECHAIN_STMTS ((yyvsp[(1) - (3)].ttype), COMPOUND_BODY ((yyvsp[(1) - (3)].ttype)));
 		  last_tree = saved_last_tree;
 		  TREE_CHAIN (last_tree) = NULL_TREE;
 		  if (!last_expr_type)
 		    last_expr_type = void_type_node;
-		  yyval.ttype = build1 (STMT_EXPR, last_expr_type, yyvsp[-2].ttype);
-		  TREE_SIDE_EFFECTS (yyval.ttype) = 1;
-		;}
+		  (yyval.ttype) = build1 (STMT_EXPR, last_expr_type, (yyvsp[(1) - (3)].ttype));
+		  TREE_SIDE_EFFECTS ((yyval.ttype)) = 1;
+		}
     break;
 
   case 95:
+
+/* Line 1806 of yacc.c  */
 #line 659 "c-parse.y"
     {
 		  pop_label_level ();
-		  last_tree = COMPOUND_BODY (yyvsp[-2].ttype);
+		  last_tree = COMPOUND_BODY ((yyvsp[(1) - (3)].ttype));
 		  TREE_CHAIN (last_tree) = NULL_TREE;
-		  yyval.ttype = error_mark_node;
-		;}
+		  (yyval.ttype) = error_mark_node;
+		}
     break;
 
   case 96:
+
+/* Line 1806 of yacc.c  */
 #line 666 "c-parse.y"
-    { yyval.ttype = build_function_call (yyvsp[-3].ttype, yyvsp[-1].ttype); ;}
+    { (yyval.ttype) = build_function_call ((yyvsp[(1) - (4)].ttype), (yyvsp[(3) - (4)].ttype)); }
     break;
 
   case 97:
+
+/* Line 1806 of yacc.c  */
 #line 668 "c-parse.y"
-    { yyval.ttype = build_va_arg (yyvsp[-3].ttype, groktypename (yyvsp[-1].ttype)); ;}
+    { (yyval.ttype) = build_va_arg ((yyvsp[(3) - (6)].ttype), groktypename ((yyvsp[(5) - (6)].ttype))); }
     break;
 
   case 98:
+
+/* Line 1806 of yacc.c  */
 #line 671 "c-parse.y"
     {
                   tree c;
 
-                  c = fold (yyvsp[-5].ttype);
+                  c = fold ((yyvsp[(3) - (8)].ttype));
                   STRIP_NOPS (c);
                   if (TREE_CODE (c) != INTEGER_CST)
                     error ("first argument to __builtin_choose_expr not a constant");
-                  yyval.ttype = integer_zerop (c) ? yyvsp[-1].ttype : yyvsp[-3].ttype;
-		;}
+                  (yyval.ttype) = integer_zerop (c) ? (yyvsp[(7) - (8)].ttype) : (yyvsp[(5) - (8)].ttype);
+		}
     break;
 
   case 99:
+
+/* Line 1806 of yacc.c  */
 #line 681 "c-parse.y"
     {
 		  tree e1, e2;
 
-		  e1 = TYPE_MAIN_VARIANT (groktypename (yyvsp[-3].ttype));
-		  e2 = TYPE_MAIN_VARIANT (groktypename (yyvsp[-1].ttype));
+		  e1 = TYPE_MAIN_VARIANT (groktypename ((yyvsp[(3) - (6)].ttype)));
+		  e2 = TYPE_MAIN_VARIANT (groktypename ((yyvsp[(5) - (6)].ttype)));
 
-		  yyval.ttype = comptypes (e1, e2)
+		  (yyval.ttype) = comptypes (e1, e2)
 		    ? build_int_2 (1, 0) : build_int_2 (0, 0);
-		;}
+		}
     break;
 
   case 100:
+
+/* Line 1806 of yacc.c  */
 #line 691 "c-parse.y"
-    { yyval.ttype = build_array_ref (yyvsp[-3].ttype, yyvsp[-1].ttype); ;}
+    { (yyval.ttype) = build_array_ref ((yyvsp[(1) - (4)].ttype), (yyvsp[(3) - (4)].ttype)); }
     break;
 
   case 101:
+
+/* Line 1806 of yacc.c  */
 #line 693 "c-parse.y"
     {
-		      yyval.ttype = build_component_ref (yyvsp[-2].ttype, yyvsp[0].ttype);
-		;}
+		      (yyval.ttype) = build_component_ref ((yyvsp[(1) - (3)].ttype), (yyvsp[(3) - (3)].ttype));
+		}
     break;
 
   case 102:
+
+/* Line 1806 of yacc.c  */
 #line 697 "c-parse.y"
     {
-                  tree expr = build_indirect_ref (yyvsp[-2].ttype, "->");
+                  tree expr = build_indirect_ref ((yyvsp[(1) - (3)].ttype), "->");
 
-			yyval.ttype = build_component_ref (expr, yyvsp[0].ttype);
-		;}
+			(yyval.ttype) = build_component_ref (expr, (yyvsp[(3) - (3)].ttype));
+		}
     break;
 
   case 103:
+
+/* Line 1806 of yacc.c  */
 #line 703 "c-parse.y"
-    { yyval.ttype = build_unary_op (POSTINCREMENT_EXPR, yyvsp[-1].ttype, 0); ;}
+    { (yyval.ttype) = build_unary_op (POSTINCREMENT_EXPR, (yyvsp[(1) - (2)].ttype), 0); }
     break;
 
   case 104:
+
+/* Line 1806 of yacc.c  */
 #line 705 "c-parse.y"
-    { yyval.ttype = build_unary_op (POSTDECREMENT_EXPR, yyvsp[-1].ttype, 0); ;}
+    { (yyval.ttype) = build_unary_op (POSTDECREMENT_EXPR, (yyvsp[(1) - (2)].ttype), 0); }
     break;
 
   case 105:
+
+/* Line 1806 of yacc.c  */
 #line 711 "c-parse.y"
     {
 	  parsing_iso_function_signature = false; /* Reset after decls.  */
-	;}
+	}
     break;
 
   case 106:
+
+/* Line 1806 of yacc.c  */
 #line 718 "c-parse.y"
     {
 	  if (warn_traditional && !in_system_header
 	      && parsing_iso_function_signature)
 	    warning ("traditional C rejects ISO C style function definitions");
 	  parsing_iso_function_signature = false; /* Reset after warning.  */
-	;}
+	}
     break;
 
   case 108:
+
+/* Line 1806 of yacc.c  */
 #line 732 "c-parse.y"
-    { ;}
+    { }
     break;
 
   case 113:
+
+/* Line 1806 of yacc.c  */
 #line 748 "c-parse.y"
-    { POP_DECLSPEC_STACK; ;}
+    { POP_DECLSPEC_STACK; }
     break;
 
   case 114:
+
+/* Line 1806 of yacc.c  */
 #line 750 "c-parse.y"
-    { POP_DECLSPEC_STACK; ;}
+    { POP_DECLSPEC_STACK; }
     break;
 
   case 115:
+
+/* Line 1806 of yacc.c  */
 #line 752 "c-parse.y"
-    { shadow_tag_warned (yyvsp[-1].ttype, 1);
-		  pedwarn ("empty declaration"); ;}
+    { shadow_tag_warned ((yyvsp[(1) - (2)].ttype), 1);
+		  pedwarn ("empty declaration"); }
     break;
 
   case 116:
+
+/* Line 1806 of yacc.c  */
 #line 755 "c-parse.y"
-    { pedwarn ("empty declaration"); ;}
+    { pedwarn ("empty declaration"); }
     break;
 
   case 117:
+
+/* Line 1806 of yacc.c  */
 #line 764 "c-parse.y"
-    { ;}
+    { }
     break;
 
   case 118:
+
+/* Line 1806 of yacc.c  */
 #line 772 "c-parse.y"
     { pending_xref_error ();
 		  PUSH_DECLSPEC_STACK;
-		  split_specs_attrs (yyvsp[0].ttype,
+		  split_specs_attrs ((yyvsp[(0) - (0)].ttype),
 				     &current_declspecs, &prefix_attributes);
-		  all_prefix_attributes = prefix_attributes; ;}
+		  all_prefix_attributes = prefix_attributes; }
     break;
 
   case 119:
+
+/* Line 1806 of yacc.c  */
 #line 783 "c-parse.y"
-    { all_prefix_attributes = chainon (yyvsp[0].ttype, prefix_attributes); ;}
+    { all_prefix_attributes = chainon ((yyvsp[(1) - (1)].ttype), prefix_attributes); }
     break;
 
   case 120:
+
+/* Line 1806 of yacc.c  */
 #line 788 "c-parse.y"
-    { POP_DECLSPEC_STACK; ;}
+    { POP_DECLSPEC_STACK; }
     break;
 
   case 121:
+
+/* Line 1806 of yacc.c  */
 #line 790 "c-parse.y"
-    { POP_DECLSPEC_STACK; ;}
+    { POP_DECLSPEC_STACK; }
     break;
 
   case 122:
+
+/* Line 1806 of yacc.c  */
 #line 792 "c-parse.y"
-    { POP_DECLSPEC_STACK; ;}
+    { POP_DECLSPEC_STACK; }
     break;
 
   case 123:
+
+/* Line 1806 of yacc.c  */
 #line 794 "c-parse.y"
-    { POP_DECLSPEC_STACK; ;}
+    { POP_DECLSPEC_STACK; }
     break;
 
   case 124:
+
+/* Line 1806 of yacc.c  */
 #line 796 "c-parse.y"
-    { shadow_tag (yyvsp[-1].ttype); ;}
+    { shadow_tag ((yyvsp[(1) - (2)].ttype)); }
     break;
 
   case 125:
+
+/* Line 1806 of yacc.c  */
 #line 798 "c-parse.y"
-    { RESTORE_EXT_FLAGS (yyvsp[-1].ttype); ;}
+    { RESTORE_EXT_FLAGS ((yyvsp[(1) - (2)].ttype)); }
     break;
 
   case 126:
+
+/* Line 1806 of yacc.c  */
 #line 855 "c-parse.y"
-    { yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, NULL_TREE);
-		  TREE_STATIC (yyval.ttype) = 1; ;}
+    { (yyval.ttype) = tree_cons (NULL_TREE, (yyvsp[(1) - (1)].ttype), NULL_TREE);
+		  TREE_STATIC ((yyval.ttype)) = 1; }
     break;
 
   case 127:
+
+/* Line 1806 of yacc.c  */
 #line 858 "c-parse.y"
-    { yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyvsp[-1].ttype);
-		  TREE_STATIC (yyval.ttype) = 1; ;}
+    { (yyval.ttype) = tree_cons (NULL_TREE, (yyvsp[(2) - (2)].ttype), (yyvsp[(1) - (2)].ttype));
+		  TREE_STATIC ((yyval.ttype)) = 1; }
     break;
 
   case 128:
+
+/* Line 1806 of yacc.c  */
 #line 861 "c-parse.y"
-    { yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyvsp[-1].ttype);
-		  TREE_STATIC (yyval.ttype) = 1; ;}
+    { (yyval.ttype) = tree_cons (NULL_TREE, (yyvsp[(2) - (2)].ttype), (yyvsp[(1) - (2)].ttype));
+		  TREE_STATIC ((yyval.ttype)) = 1; }
     break;
 
   case 129:
+
+/* Line 1806 of yacc.c  */
 #line 867 "c-parse.y"
-    { yyval.ttype = tree_cons (yyvsp[0].ttype, NULL_TREE, yyvsp[-1].ttype);
-		  TREE_STATIC (yyval.ttype) = TREE_STATIC (yyvsp[-1].ttype); ;}
+    { (yyval.ttype) = tree_cons ((yyvsp[(2) - (2)].ttype), NULL_TREE, (yyvsp[(1) - (2)].ttype));
+		  TREE_STATIC ((yyval.ttype)) = TREE_STATIC ((yyvsp[(1) - (2)].ttype)); }
     break;
 
   case 130:
+
+/* Line 1806 of yacc.c  */
 #line 873 "c-parse.y"
-    { yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyvsp[-1].ttype);
-		  TREE_STATIC (yyval.ttype) = 1; ;}
+    { (yyval.ttype) = tree_cons (NULL_TREE, (yyvsp[(2) - (2)].ttype), (yyvsp[(1) - (2)].ttype));
+		  TREE_STATIC ((yyval.ttype)) = 1; }
     break;
 
   case 131:
+
+/* Line 1806 of yacc.c  */
 #line 876 "c-parse.y"
-    { yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyvsp[-1].ttype);
-		  TREE_STATIC (yyval.ttype) = 1; ;}
+    { (yyval.ttype) = tree_cons (NULL_TREE, (yyvsp[(2) - (2)].ttype), (yyvsp[(1) - (2)].ttype));
+		  TREE_STATIC ((yyval.ttype)) = 1; }
     break;
 
   case 132:
+
+/* Line 1806 of yacc.c  */
 #line 882 "c-parse.y"
-    { yyval.ttype = tree_cons (yyvsp[0].ttype, NULL_TREE, NULL_TREE);
-		  TREE_STATIC (yyval.ttype) = 0; ;}
+    { (yyval.ttype) = tree_cons ((yyvsp[(1) - (1)].ttype), NULL_TREE, NULL_TREE);
+		  TREE_STATIC ((yyval.ttype)) = 0; }
     break;
 
   case 133:
+
+/* Line 1806 of yacc.c  */
 #line 885 "c-parse.y"
-    { yyval.ttype = tree_cons (yyvsp[0].ttype, NULL_TREE, yyvsp[-1].ttype);
-		  TREE_STATIC (yyval.ttype) = TREE_STATIC (yyvsp[-1].ttype); ;}
+    { (yyval.ttype) = tree_cons ((yyvsp[(2) - (2)].ttype), NULL_TREE, (yyvsp[(1) - (2)].ttype));
+		  TREE_STATIC ((yyval.ttype)) = TREE_STATIC ((yyvsp[(1) - (2)].ttype)); }
     break;
 
   case 134:
+
+/* Line 1806 of yacc.c  */
 #line 891 "c-parse.y"
-    { yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, NULL_TREE);
-		  TREE_STATIC (yyval.ttype) = 1; ;}
+    { (yyval.ttype) = tree_cons (NULL_TREE, (yyvsp[(1) - (1)].ttype), NULL_TREE);
+		  TREE_STATIC ((yyval.ttype)) = 1; }
     break;
 
   case 135:
+
+/* Line 1806 of yacc.c  */
 #line 894 "c-parse.y"
-    { yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyvsp[-1].ttype);
-		  TREE_STATIC (yyval.ttype) = 1; ;}
+    { (yyval.ttype) = tree_cons (NULL_TREE, (yyvsp[(2) - (2)].ttype), (yyvsp[(1) - (2)].ttype));
+		  TREE_STATIC ((yyval.ttype)) = 1; }
     break;
 
   case 136:
+
+/* Line 1806 of yacc.c  */
 #line 897 "c-parse.y"
-    { yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyvsp[-1].ttype);
-		  TREE_STATIC (yyval.ttype) = 1; ;}
+    { (yyval.ttype) = tree_cons (NULL_TREE, (yyvsp[(2) - (2)].ttype), (yyvsp[(1) - (2)].ttype));
+		  TREE_STATIC ((yyval.ttype)) = 1; }
     break;
 
   case 137:
+
+/* Line 1806 of yacc.c  */
 #line 900 "c-parse.y"
-    { yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyvsp[-1].ttype);
-		  TREE_STATIC (yyval.ttype) = 1; ;}
+    { (yyval.ttype) = tree_cons (NULL_TREE, (yyvsp[(2) - (2)].ttype), (yyvsp[(1) - (2)].ttype));
+		  TREE_STATIC ((yyval.ttype)) = 1; }
     break;
 
   case 138:
+
+/* Line 1806 of yacc.c  */
 #line 903 "c-parse.y"
-    { yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyvsp[-1].ttype);
-		  TREE_STATIC (yyval.ttype) = 1; ;}
+    { (yyval.ttype) = tree_cons (NULL_TREE, (yyvsp[(2) - (2)].ttype), (yyvsp[(1) - (2)].ttype));
+		  TREE_STATIC ((yyval.ttype)) = 1; }
     break;
 
   case 139:
+
+/* Line 1806 of yacc.c  */
 #line 906 "c-parse.y"
-    { yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyvsp[-1].ttype);
-		  TREE_STATIC (yyval.ttype) = 1; ;}
+    { (yyval.ttype) = tree_cons (NULL_TREE, (yyvsp[(2) - (2)].ttype), (yyvsp[(1) - (2)].ttype));
+		  TREE_STATIC ((yyval.ttype)) = 1; }
     break;
 
   case 140:
+
+/* Line 1806 of yacc.c  */
 #line 909 "c-parse.y"
-    { yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyvsp[-1].ttype);
-		  TREE_STATIC (yyval.ttype) = 1; ;}
+    { (yyval.ttype) = tree_cons (NULL_TREE, (yyvsp[(2) - (2)].ttype), (yyvsp[(1) - (2)].ttype));
+		  TREE_STATIC ((yyval.ttype)) = 1; }
     break;
 
   case 141:
+
+/* Line 1806 of yacc.c  */
 #line 915 "c-parse.y"
-    { yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, NULL_TREE);
-		  TREE_STATIC (yyval.ttype) = 1; ;}
+    { (yyval.ttype) = tree_cons (NULL_TREE, (yyvsp[(1) - (1)].ttype), NULL_TREE);
+		  TREE_STATIC ((yyval.ttype)) = 1; }
     break;
 
   case 142:
+
+/* Line 1806 of yacc.c  */
 #line 918 "c-parse.y"
-    { yyval.ttype = tree_cons (yyvsp[0].ttype, NULL_TREE, yyvsp[-1].ttype);
-		  TREE_STATIC (yyval.ttype) = TREE_STATIC (yyvsp[-1].ttype); ;}
+    { (yyval.ttype) = tree_cons ((yyvsp[(2) - (2)].ttype), NULL_TREE, (yyvsp[(1) - (2)].ttype));
+		  TREE_STATIC ((yyval.ttype)) = TREE_STATIC ((yyvsp[(1) - (2)].ttype)); }
     break;
 
   case 143:
+
+/* Line 1806 of yacc.c  */
 #line 921 "c-parse.y"
-    { yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyvsp[-1].ttype);
-		  TREE_STATIC (yyval.ttype) = 1; ;}
+    { (yyval.ttype) = tree_cons (NULL_TREE, (yyvsp[(2) - (2)].ttype), (yyvsp[(1) - (2)].ttype));
+		  TREE_STATIC ((yyval.ttype)) = 1; }
     break;
 
   case 144:
+
+/* Line 1806 of yacc.c  */
 #line 924 "c-parse.y"
-    { yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyvsp[-1].ttype);
-		  TREE_STATIC (yyval.ttype) = 1; ;}
+    { (yyval.ttype) = tree_cons (NULL_TREE, (yyvsp[(2) - (2)].ttype), (yyvsp[(1) - (2)].ttype));
+		  TREE_STATIC ((yyval.ttype)) = 1; }
     break;
 
   case 145:
+
+/* Line 1806 of yacc.c  */
 #line 927 "c-parse.y"
-    { yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyvsp[-1].ttype);
-		  TREE_STATIC (yyval.ttype) = 1; ;}
+    { (yyval.ttype) = tree_cons (NULL_TREE, (yyvsp[(2) - (2)].ttype), (yyvsp[(1) - (2)].ttype));
+		  TREE_STATIC ((yyval.ttype)) = 1; }
     break;
 
   case 146:
+
+/* Line 1806 of yacc.c  */
 #line 930 "c-parse.y"
-    { yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyvsp[-1].ttype);
-		  TREE_STATIC (yyval.ttype) = 1; ;}
+    { (yyval.ttype) = tree_cons (NULL_TREE, (yyvsp[(2) - (2)].ttype), (yyvsp[(1) - (2)].ttype));
+		  TREE_STATIC ((yyval.ttype)) = 1; }
     break;
 
   case 147:
+
+/* Line 1806 of yacc.c  */
 #line 936 "c-parse.y"
-    { yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyvsp[-1].ttype);
-		  TREE_STATIC (yyval.ttype) = 1; ;}
+    { (yyval.ttype) = tree_cons (NULL_TREE, (yyvsp[(2) - (2)].ttype), (yyvsp[(1) - (2)].ttype));
+		  TREE_STATIC ((yyval.ttype)) = 1; }
     break;
 
   case 148:
+
+/* Line 1806 of yacc.c  */
 #line 939 "c-parse.y"
-    { yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyvsp[-1].ttype);
-		  TREE_STATIC (yyval.ttype) = 1; ;}
+    { (yyval.ttype) = tree_cons (NULL_TREE, (yyvsp[(2) - (2)].ttype), (yyvsp[(1) - (2)].ttype));
+		  TREE_STATIC ((yyval.ttype)) = 1; }
     break;
 
   case 149:
+
+/* Line 1806 of yacc.c  */
 #line 942 "c-parse.y"
-    { yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyvsp[-1].ttype);
-		  TREE_STATIC (yyval.ttype) = 1; ;}
+    { (yyval.ttype) = tree_cons (NULL_TREE, (yyvsp[(2) - (2)].ttype), (yyvsp[(1) - (2)].ttype));
+		  TREE_STATIC ((yyval.ttype)) = 1; }
     break;
 
   case 150:
+
+/* Line 1806 of yacc.c  */
 #line 945 "c-parse.y"
-    { yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyvsp[-1].ttype);
-		  TREE_STATIC (yyval.ttype) = 1; ;}
+    { (yyval.ttype) = tree_cons (NULL_TREE, (yyvsp[(2) - (2)].ttype), (yyvsp[(1) - (2)].ttype));
+		  TREE_STATIC ((yyval.ttype)) = 1; }
     break;
 
   case 151:
+
+/* Line 1806 of yacc.c  */
 #line 948 "c-parse.y"
-    { yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyvsp[-1].ttype);
-		  TREE_STATIC (yyval.ttype) = 1; ;}
+    { (yyval.ttype) = tree_cons (NULL_TREE, (yyvsp[(2) - (2)].ttype), (yyvsp[(1) - (2)].ttype));
+		  TREE_STATIC ((yyval.ttype)) = 1; }
     break;
 
   case 152:
+
+/* Line 1806 of yacc.c  */
 #line 951 "c-parse.y"
-    { yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyvsp[-1].ttype);
-		  TREE_STATIC (yyval.ttype) = 1; ;}
+    { (yyval.ttype) = tree_cons (NULL_TREE, (yyvsp[(2) - (2)].ttype), (yyvsp[(1) - (2)].ttype));
+		  TREE_STATIC ((yyval.ttype)) = 1; }
     break;
 
   case 153:
+
+/* Line 1806 of yacc.c  */
 #line 957 "c-parse.y"
-    { yyval.ttype = tree_cons (yyvsp[0].ttype, NULL_TREE, yyvsp[-1].ttype);
-		  TREE_STATIC (yyval.ttype) = TREE_STATIC (yyvsp[-1].ttype); ;}
+    { (yyval.ttype) = tree_cons ((yyvsp[(2) - (2)].ttype), NULL_TREE, (yyvsp[(1) - (2)].ttype));
+		  TREE_STATIC ((yyval.ttype)) = TREE_STATIC ((yyvsp[(1) - (2)].ttype)); }
     break;
 
   case 154:
+
+/* Line 1806 of yacc.c  */
 #line 960 "c-parse.y"
-    { yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyvsp[-1].ttype);
-		  TREE_STATIC (yyval.ttype) = 1; ;}
+    { (yyval.ttype) = tree_cons (NULL_TREE, (yyvsp[(2) - (2)].ttype), (yyvsp[(1) - (2)].ttype));
+		  TREE_STATIC ((yyval.ttype)) = 1; }
     break;
 
   case 155:
+
+/* Line 1806 of yacc.c  */
 #line 963 "c-parse.y"
-    { yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyvsp[-1].ttype);
-		  TREE_STATIC (yyval.ttype) = 1; ;}
+    { (yyval.ttype) = tree_cons (NULL_TREE, (yyvsp[(2) - (2)].ttype), (yyvsp[(1) - (2)].ttype));
+		  TREE_STATIC ((yyval.ttype)) = 1; }
     break;
 
   case 156:
+
+/* Line 1806 of yacc.c  */
 #line 966 "c-parse.y"
-    { yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyvsp[-1].ttype);
-		  TREE_STATIC (yyval.ttype) = 1; ;}
+    { (yyval.ttype) = tree_cons (NULL_TREE, (yyvsp[(2) - (2)].ttype), (yyvsp[(1) - (2)].ttype));
+		  TREE_STATIC ((yyval.ttype)) = 1; }
     break;
 
   case 157:
+
+/* Line 1806 of yacc.c  */
 #line 969 "c-parse.y"
-    { yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyvsp[-1].ttype);
-		  TREE_STATIC (yyval.ttype) = 1; ;}
+    { (yyval.ttype) = tree_cons (NULL_TREE, (yyvsp[(2) - (2)].ttype), (yyvsp[(1) - (2)].ttype));
+		  TREE_STATIC ((yyval.ttype)) = 1; }
     break;
 
   case 158:
+
+/* Line 1806 of yacc.c  */
 #line 975 "c-parse.y"
-    { yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, NULL_TREE);
-		  TREE_STATIC (yyval.ttype) = 0; ;}
+    { (yyval.ttype) = tree_cons (NULL_TREE, (yyvsp[(1) - (1)].ttype), NULL_TREE);
+		  TREE_STATIC ((yyval.ttype)) = 0; }
     break;
 
   case 159:
+
+/* Line 1806 of yacc.c  */
 #line 978 "c-parse.y"
-    { yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyvsp[-1].ttype);
-		  TREE_STATIC (yyval.ttype) = 1; ;}
+    { (yyval.ttype) = tree_cons (NULL_TREE, (yyvsp[(2) - (2)].ttype), (yyvsp[(1) - (2)].ttype));
+		  TREE_STATIC ((yyval.ttype)) = 1; }
     break;
 
   case 160:
+
+/* Line 1806 of yacc.c  */
 #line 981 "c-parse.y"
-    { yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyvsp[-1].ttype);
-		  TREE_STATIC (yyval.ttype) = 1; ;}
+    { (yyval.ttype) = tree_cons (NULL_TREE, (yyvsp[(2) - (2)].ttype), (yyvsp[(1) - (2)].ttype));
+		  TREE_STATIC ((yyval.ttype)) = 1; }
     break;
 
   case 161:
+
+/* Line 1806 of yacc.c  */
 #line 984 "c-parse.y"
-    { if (extra_warnings && TREE_STATIC (yyvsp[-1].ttype))
+    { if (extra_warnings && TREE_STATIC ((yyvsp[(1) - (2)].ttype)))
 		    warning ("`%s' is not at beginning of declaration",
-			     IDENTIFIER_POINTER (yyvsp[0].ttype));
-		  yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyvsp[-1].ttype);
-		  TREE_STATIC (yyval.ttype) = TREE_STATIC (yyvsp[-1].ttype); ;}
+			     IDENTIFIER_POINTER ((yyvsp[(2) - (2)].ttype)));
+		  (yyval.ttype) = tree_cons (NULL_TREE, (yyvsp[(2) - (2)].ttype), (yyvsp[(1) - (2)].ttype));
+		  TREE_STATIC ((yyval.ttype)) = TREE_STATIC ((yyvsp[(1) - (2)].ttype)); }
     break;
 
   case 162:
+
+/* Line 1806 of yacc.c  */
 #line 990 "c-parse.y"
-    { if (extra_warnings && TREE_STATIC (yyvsp[-1].ttype))
+    { if (extra_warnings && TREE_STATIC ((yyvsp[(1) - (2)].ttype)))
 		    warning ("`%s' is not at beginning of declaration",
-			     IDENTIFIER_POINTER (yyvsp[0].ttype));
-		  yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyvsp[-1].ttype);
-		  TREE_STATIC (yyval.ttype) = TREE_STATIC (yyvsp[-1].ttype); ;}
+			     IDENTIFIER_POINTER ((yyvsp[(2) - (2)].ttype)));
+		  (yyval.ttype) = tree_cons (NULL_TREE, (yyvsp[(2) - (2)].ttype), (yyvsp[(1) - (2)].ttype));
+		  TREE_STATIC ((yyval.ttype)) = TREE_STATIC ((yyvsp[(1) - (2)].ttype)); }
     break;
 
   case 163:
+
+/* Line 1806 of yacc.c  */
 #line 996 "c-parse.y"
-    { if (extra_warnings && TREE_STATIC (yyvsp[-1].ttype))
+    { if (extra_warnings && TREE_STATIC ((yyvsp[(1) - (2)].ttype)))
 		    warning ("`%s' is not at beginning of declaration",
-			     IDENTIFIER_POINTER (yyvsp[0].ttype));
-		  yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyvsp[-1].ttype);
-		  TREE_STATIC (yyval.ttype) = TREE_STATIC (yyvsp[-1].ttype); ;}
+			     IDENTIFIER_POINTER ((yyvsp[(2) - (2)].ttype)));
+		  (yyval.ttype) = tree_cons (NULL_TREE, (yyvsp[(2) - (2)].ttype), (yyvsp[(1) - (2)].ttype));
+		  TREE_STATIC ((yyval.ttype)) = TREE_STATIC ((yyvsp[(1) - (2)].ttype)); }
     break;
 
   case 164:
+
+/* Line 1806 of yacc.c  */
 #line 1002 "c-parse.y"
-    { if (extra_warnings && TREE_STATIC (yyvsp[-1].ttype))
+    { if (extra_warnings && TREE_STATIC ((yyvsp[(1) - (2)].ttype)))
 		    warning ("`%s' is not at beginning of declaration",
-			     IDENTIFIER_POINTER (yyvsp[0].ttype));
-		  yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyvsp[-1].ttype);
-		  TREE_STATIC (yyval.ttype) = TREE_STATIC (yyvsp[-1].ttype); ;}
+			     IDENTIFIER_POINTER ((yyvsp[(2) - (2)].ttype)));
+		  (yyval.ttype) = tree_cons (NULL_TREE, (yyvsp[(2) - (2)].ttype), (yyvsp[(1) - (2)].ttype));
+		  TREE_STATIC ((yyval.ttype)) = TREE_STATIC ((yyvsp[(1) - (2)].ttype)); }
     break;
 
   case 165:
+
+/* Line 1806 of yacc.c  */
 #line 1011 "c-parse.y"
-    { yyval.ttype = tree_cons (yyvsp[0].ttype, NULL_TREE, yyvsp[-1].ttype);
-		  TREE_STATIC (yyval.ttype) = TREE_STATIC (yyvsp[-1].ttype); ;}
+    { (yyval.ttype) = tree_cons ((yyvsp[(2) - (2)].ttype), NULL_TREE, (yyvsp[(1) - (2)].ttype));
+		  TREE_STATIC ((yyval.ttype)) = TREE_STATIC ((yyvsp[(1) - (2)].ttype)); }
     break;
 
   case 166:
+
+/* Line 1806 of yacc.c  */
 #line 1017 "c-parse.y"
-    { yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyvsp[-1].ttype);
-		  TREE_STATIC (yyval.ttype) = 1; ;}
+    { (yyval.ttype) = tree_cons (NULL_TREE, (yyvsp[(2) - (2)].ttype), (yyvsp[(1) - (2)].ttype));
+		  TREE_STATIC ((yyval.ttype)) = 1; }
     break;
 
   case 167:
+
+/* Line 1806 of yacc.c  */
 #line 1020 "c-parse.y"
-    { yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyvsp[-1].ttype);
-		  TREE_STATIC (yyval.ttype) = 1; ;}
+    { (yyval.ttype) = tree_cons (NULL_TREE, (yyvsp[(2) - (2)].ttype), (yyvsp[(1) - (2)].ttype));
+		  TREE_STATIC ((yyval.ttype)) = 1; }
     break;
 
   case 168:
+
+/* Line 1806 of yacc.c  */
 #line 1023 "c-parse.y"
-    { if (extra_warnings && TREE_STATIC (yyvsp[-1].ttype))
+    { if (extra_warnings && TREE_STATIC ((yyvsp[(1) - (2)].ttype)))
 		    warning ("`%s' is not at beginning of declaration",
-			     IDENTIFIER_POINTER (yyvsp[0].ttype));
-		  yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyvsp[-1].ttype);
-		  TREE_STATIC (yyval.ttype) = TREE_STATIC (yyvsp[-1].ttype); ;}
+			     IDENTIFIER_POINTER ((yyvsp[(2) - (2)].ttype)));
+		  (yyval.ttype) = tree_cons (NULL_TREE, (yyvsp[(2) - (2)].ttype), (yyvsp[(1) - (2)].ttype));
+		  TREE_STATIC ((yyval.ttype)) = TREE_STATIC ((yyvsp[(1) - (2)].ttype)); }
     break;
 
   case 169:
+
+/* Line 1806 of yacc.c  */
 #line 1029 "c-parse.y"
-    { if (extra_warnings && TREE_STATIC (yyvsp[-1].ttype))
+    { if (extra_warnings && TREE_STATIC ((yyvsp[(1) - (2)].ttype)))
 		    warning ("`%s' is not at beginning of declaration",
-			     IDENTIFIER_POINTER (yyvsp[0].ttype));
-		  yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyvsp[-1].ttype);
-		  TREE_STATIC (yyval.ttype) = TREE_STATIC (yyvsp[-1].ttype); ;}
+			     IDENTIFIER_POINTER ((yyvsp[(2) - (2)].ttype)));
+		  (yyval.ttype) = tree_cons (NULL_TREE, (yyvsp[(2) - (2)].ttype), (yyvsp[(1) - (2)].ttype));
+		  TREE_STATIC ((yyval.ttype)) = TREE_STATIC ((yyvsp[(1) - (2)].ttype)); }
     break;
 
   case 170:
+
+/* Line 1806 of yacc.c  */
 #line 1035 "c-parse.y"
-    { if (extra_warnings && TREE_STATIC (yyvsp[-1].ttype))
+    { if (extra_warnings && TREE_STATIC ((yyvsp[(1) - (2)].ttype)))
 		    warning ("`%s' is not at beginning of declaration",
-			     IDENTIFIER_POINTER (yyvsp[0].ttype));
-		  yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyvsp[-1].ttype);
-		  TREE_STATIC (yyval.ttype) = TREE_STATIC (yyvsp[-1].ttype); ;}
+			     IDENTIFIER_POINTER ((yyvsp[(2) - (2)].ttype)));
+		  (yyval.ttype) = tree_cons (NULL_TREE, (yyvsp[(2) - (2)].ttype), (yyvsp[(1) - (2)].ttype));
+		  TREE_STATIC ((yyval.ttype)) = TREE_STATIC ((yyvsp[(1) - (2)].ttype)); }
     break;
 
   case 171:
+
+/* Line 1806 of yacc.c  */
 #line 1041 "c-parse.y"
-    { if (extra_warnings && TREE_STATIC (yyvsp[-1].ttype))
+    { if (extra_warnings && TREE_STATIC ((yyvsp[(1) - (2)].ttype)))
 		    warning ("`%s' is not at beginning of declaration",
-			     IDENTIFIER_POINTER (yyvsp[0].ttype));
-		  yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyvsp[-1].ttype);
-		  TREE_STATIC (yyval.ttype) = TREE_STATIC (yyvsp[-1].ttype); ;}
+			     IDENTIFIER_POINTER ((yyvsp[(2) - (2)].ttype)));
+		  (yyval.ttype) = tree_cons (NULL_TREE, (yyvsp[(2) - (2)].ttype), (yyvsp[(1) - (2)].ttype));
+		  TREE_STATIC ((yyval.ttype)) = TREE_STATIC ((yyvsp[(1) - (2)].ttype)); }
     break;
 
   case 172:
+
+/* Line 1806 of yacc.c  */
 #line 1050 "c-parse.y"
-    { yyval.ttype = tree_cons (yyvsp[0].ttype, NULL_TREE, yyvsp[-1].ttype);
-		  TREE_STATIC (yyval.ttype) = TREE_STATIC (yyvsp[-1].ttype); ;}
+    { (yyval.ttype) = tree_cons ((yyvsp[(2) - (2)].ttype), NULL_TREE, (yyvsp[(1) - (2)].ttype));
+		  TREE_STATIC ((yyval.ttype)) = TREE_STATIC ((yyvsp[(1) - (2)].ttype)); }
     break;
 
   case 173:
+
+/* Line 1806 of yacc.c  */
 #line 1056 "c-parse.y"
-    { yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyvsp[-1].ttype);
-		  TREE_STATIC (yyval.ttype) = 1; ;}
+    { (yyval.ttype) = tree_cons (NULL_TREE, (yyvsp[(2) - (2)].ttype), (yyvsp[(1) - (2)].ttype));
+		  TREE_STATIC ((yyval.ttype)) = 1; }
     break;
 
   case 174:
+
+/* Line 1806 of yacc.c  */
 #line 1059 "c-parse.y"
-    { yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyvsp[-1].ttype);
-		  TREE_STATIC (yyval.ttype) = 1; ;}
+    { (yyval.ttype) = tree_cons (NULL_TREE, (yyvsp[(2) - (2)].ttype), (yyvsp[(1) - (2)].ttype));
+		  TREE_STATIC ((yyval.ttype)) = 1; }
     break;
 
   case 175:
+
+/* Line 1806 of yacc.c  */
 #line 1062 "c-parse.y"
-    { yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyvsp[-1].ttype);
-		  TREE_STATIC (yyval.ttype) = 1; ;}
+    { (yyval.ttype) = tree_cons (NULL_TREE, (yyvsp[(2) - (2)].ttype), (yyvsp[(1) - (2)].ttype));
+		  TREE_STATIC ((yyval.ttype)) = 1; }
     break;
 
   case 176:
+
+/* Line 1806 of yacc.c  */
 #line 1065 "c-parse.y"
-    { yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyvsp[-1].ttype);
-		  TREE_STATIC (yyval.ttype) = 1; ;}
+    { (yyval.ttype) = tree_cons (NULL_TREE, (yyvsp[(2) - (2)].ttype), (yyvsp[(1) - (2)].ttype));
+		  TREE_STATIC ((yyval.ttype)) = 1; }
     break;
 
   case 177:
+
+/* Line 1806 of yacc.c  */
 #line 1068 "c-parse.y"
-    { yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyvsp[-1].ttype);
-		  TREE_STATIC (yyval.ttype) = 1; ;}
+    { (yyval.ttype) = tree_cons (NULL_TREE, (yyvsp[(2) - (2)].ttype), (yyvsp[(1) - (2)].ttype));
+		  TREE_STATIC ((yyval.ttype)) = 1; }
     break;
 
   case 178:
+
+/* Line 1806 of yacc.c  */
 #line 1071 "c-parse.y"
-    { yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyvsp[-1].ttype);
-		  TREE_STATIC (yyval.ttype) = 1; ;}
+    { (yyval.ttype) = tree_cons (NULL_TREE, (yyvsp[(2) - (2)].ttype), (yyvsp[(1) - (2)].ttype));
+		  TREE_STATIC ((yyval.ttype)) = 1; }
     break;
 
   case 179:
+
+/* Line 1806 of yacc.c  */
 #line 1074 "c-parse.y"
-    { if (extra_warnings && TREE_STATIC (yyvsp[-1].ttype))
+    { if (extra_warnings && TREE_STATIC ((yyvsp[(1) - (2)].ttype)))
 		    warning ("`%s' is not at beginning of declaration",
-			     IDENTIFIER_POINTER (yyvsp[0].ttype));
-		  yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyvsp[-1].ttype);
-		  TREE_STATIC (yyval.ttype) = TREE_STATIC (yyvsp[-1].ttype); ;}
+			     IDENTIFIER_POINTER ((yyvsp[(2) - (2)].ttype)));
+		  (yyval.ttype) = tree_cons (NULL_TREE, (yyvsp[(2) - (2)].ttype), (yyvsp[(1) - (2)].ttype));
+		  TREE_STATIC ((yyval.ttype)) = TREE_STATIC ((yyvsp[(1) - (2)].ttype)); }
     break;
 
   case 180:
+
+/* Line 1806 of yacc.c  */
 #line 1080 "c-parse.y"
-    { if (extra_warnings && TREE_STATIC (yyvsp[-1].ttype))
+    { if (extra_warnings && TREE_STATIC ((yyvsp[(1) - (2)].ttype)))
 		    warning ("`%s' is not at beginning of declaration",
-			     IDENTIFIER_POINTER (yyvsp[0].ttype));
-		  yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyvsp[-1].ttype);
-		  TREE_STATIC (yyval.ttype) = TREE_STATIC (yyvsp[-1].ttype); ;}
+			     IDENTIFIER_POINTER ((yyvsp[(2) - (2)].ttype)));
+		  (yyval.ttype) = tree_cons (NULL_TREE, (yyvsp[(2) - (2)].ttype), (yyvsp[(1) - (2)].ttype));
+		  TREE_STATIC ((yyval.ttype)) = TREE_STATIC ((yyvsp[(1) - (2)].ttype)); }
     break;
 
   case 181:
+
+/* Line 1806 of yacc.c  */
 #line 1086 "c-parse.y"
-    { if (extra_warnings && TREE_STATIC (yyvsp[-1].ttype))
+    { if (extra_warnings && TREE_STATIC ((yyvsp[(1) - (2)].ttype)))
 		    warning ("`%s' is not at beginning of declaration",
-			     IDENTIFIER_POINTER (yyvsp[0].ttype));
-		  yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyvsp[-1].ttype);
-		  TREE_STATIC (yyval.ttype) = TREE_STATIC (yyvsp[-1].ttype); ;}
+			     IDENTIFIER_POINTER ((yyvsp[(2) - (2)].ttype)));
+		  (yyval.ttype) = tree_cons (NULL_TREE, (yyvsp[(2) - (2)].ttype), (yyvsp[(1) - (2)].ttype));
+		  TREE_STATIC ((yyval.ttype)) = TREE_STATIC ((yyvsp[(1) - (2)].ttype)); }
     break;
 
   case 182:
+
+/* Line 1806 of yacc.c  */
 #line 1092 "c-parse.y"
-    { if (extra_warnings && TREE_STATIC (yyvsp[-1].ttype))
+    { if (extra_warnings && TREE_STATIC ((yyvsp[(1) - (2)].ttype)))
 		    warning ("`%s' is not at beginning of declaration",
-			     IDENTIFIER_POINTER (yyvsp[0].ttype));
-		  yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyvsp[-1].ttype);
-		  TREE_STATIC (yyval.ttype) = TREE_STATIC (yyvsp[-1].ttype); ;}
+			     IDENTIFIER_POINTER ((yyvsp[(2) - (2)].ttype)));
+		  (yyval.ttype) = tree_cons (NULL_TREE, (yyvsp[(2) - (2)].ttype), (yyvsp[(1) - (2)].ttype));
+		  TREE_STATIC ((yyval.ttype)) = TREE_STATIC ((yyvsp[(1) - (2)].ttype)); }
     break;
 
   case 183:
+
+/* Line 1806 of yacc.c  */
 #line 1101 "c-parse.y"
-    { yyval.ttype = tree_cons (yyvsp[0].ttype, NULL_TREE, yyvsp[-1].ttype);
-		  TREE_STATIC (yyval.ttype) = TREE_STATIC (yyvsp[-1].ttype); ;}
+    { (yyval.ttype) = tree_cons ((yyvsp[(2) - (2)].ttype), NULL_TREE, (yyvsp[(1) - (2)].ttype));
+		  TREE_STATIC ((yyval.ttype)) = TREE_STATIC ((yyvsp[(1) - (2)].ttype)); }
     break;
 
   case 184:
+
+/* Line 1806 of yacc.c  */
 #line 1104 "c-parse.y"
-    { yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyvsp[-1].ttype);
-		  TREE_STATIC (yyval.ttype) = 1; ;}
+    { (yyval.ttype) = tree_cons (NULL_TREE, (yyvsp[(2) - (2)].ttype), (yyvsp[(1) - (2)].ttype));
+		  TREE_STATIC ((yyval.ttype)) = 1; }
     break;
 
   case 185:
+
+/* Line 1806 of yacc.c  */
 #line 1107 "c-parse.y"
-    { yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyvsp[-1].ttype);
-		  TREE_STATIC (yyval.ttype) = 1; ;}
+    { (yyval.ttype) = tree_cons (NULL_TREE, (yyvsp[(2) - (2)].ttype), (yyvsp[(1) - (2)].ttype));
+		  TREE_STATIC ((yyval.ttype)) = 1; }
     break;
 
   case 186:
+
+/* Line 1806 of yacc.c  */
 #line 1110 "c-parse.y"
-    { yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyvsp[-1].ttype);
-		  TREE_STATIC (yyval.ttype) = 1; ;}
+    { (yyval.ttype) = tree_cons (NULL_TREE, (yyvsp[(2) - (2)].ttype), (yyvsp[(1) - (2)].ttype));
+		  TREE_STATIC ((yyval.ttype)) = 1; }
     break;
 
   case 187:
+
+/* Line 1806 of yacc.c  */
 #line 1113 "c-parse.y"
-    { yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyvsp[-1].ttype);
-		  TREE_STATIC (yyval.ttype) = 1; ;}
+    { (yyval.ttype) = tree_cons (NULL_TREE, (yyvsp[(2) - (2)].ttype), (yyvsp[(1) - (2)].ttype));
+		  TREE_STATIC ((yyval.ttype)) = 1; }
     break;
 
   case 188:
+
+/* Line 1806 of yacc.c  */
 #line 1119 "c-parse.y"
-    { yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyvsp[-1].ttype);
-		  TREE_STATIC (yyval.ttype) = 1; ;}
+    { (yyval.ttype) = tree_cons (NULL_TREE, (yyvsp[(2) - (2)].ttype), (yyvsp[(1) - (2)].ttype));
+		  TREE_STATIC ((yyval.ttype)) = 1; }
     break;
 
   case 189:
+
+/* Line 1806 of yacc.c  */
 #line 1122 "c-parse.y"
-    { yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyvsp[-1].ttype);
-		  TREE_STATIC (yyval.ttype) = 1; ;}
+    { (yyval.ttype) = tree_cons (NULL_TREE, (yyvsp[(2) - (2)].ttype), (yyvsp[(1) - (2)].ttype));
+		  TREE_STATIC ((yyval.ttype)) = 1; }
     break;
 
   case 190:
+
+/* Line 1806 of yacc.c  */
 #line 1125 "c-parse.y"
-    { yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyvsp[-1].ttype);
-		  TREE_STATIC (yyval.ttype) = 1; ;}
+    { (yyval.ttype) = tree_cons (NULL_TREE, (yyvsp[(2) - (2)].ttype), (yyvsp[(1) - (2)].ttype));
+		  TREE_STATIC ((yyval.ttype)) = 1; }
     break;
 
   case 191:
+
+/* Line 1806 of yacc.c  */
 #line 1128 "c-parse.y"
-    { yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyvsp[-1].ttype);
-		  TREE_STATIC (yyval.ttype) = 1; ;}
+    { (yyval.ttype) = tree_cons (NULL_TREE, (yyvsp[(2) - (2)].ttype), (yyvsp[(1) - (2)].ttype));
+		  TREE_STATIC ((yyval.ttype)) = 1; }
     break;
 
   case 192:
+
+/* Line 1806 of yacc.c  */
 #line 1131 "c-parse.y"
-    { yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyvsp[-1].ttype);
-		  TREE_STATIC (yyval.ttype) = 1; ;}
+    { (yyval.ttype) = tree_cons (NULL_TREE, (yyvsp[(2) - (2)].ttype), (yyvsp[(1) - (2)].ttype));
+		  TREE_STATIC ((yyval.ttype)) = 1; }
     break;
 
   case 193:
+
+/* Line 1806 of yacc.c  */
 #line 1134 "c-parse.y"
-    { yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyvsp[-1].ttype);
-		  TREE_STATIC (yyval.ttype) = 1; ;}
+    { (yyval.ttype) = tree_cons (NULL_TREE, (yyvsp[(2) - (2)].ttype), (yyvsp[(1) - (2)].ttype));
+		  TREE_STATIC ((yyval.ttype)) = 1; }
     break;
 
   case 194:
+
+/* Line 1806 of yacc.c  */
 #line 1137 "c-parse.y"
-    { if (extra_warnings && TREE_STATIC (yyvsp[-1].ttype))
+    { if (extra_warnings && TREE_STATIC ((yyvsp[(1) - (2)].ttype)))
 		    warning ("`%s' is not at beginning of declaration",
-			     IDENTIFIER_POINTER (yyvsp[0].ttype));
-		  yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyvsp[-1].ttype);
-		  TREE_STATIC (yyval.ttype) = TREE_STATIC (yyvsp[-1].ttype); ;}
+			     IDENTIFIER_POINTER ((yyvsp[(2) - (2)].ttype)));
+		  (yyval.ttype) = tree_cons (NULL_TREE, (yyvsp[(2) - (2)].ttype), (yyvsp[(1) - (2)].ttype));
+		  TREE_STATIC ((yyval.ttype)) = TREE_STATIC ((yyvsp[(1) - (2)].ttype)); }
     break;
 
   case 195:
+
+/* Line 1806 of yacc.c  */
 #line 1143 "c-parse.y"
-    { if (extra_warnings && TREE_STATIC (yyvsp[-1].ttype))
+    { if (extra_warnings && TREE_STATIC ((yyvsp[(1) - (2)].ttype)))
 		    warning ("`%s' is not at beginning of declaration",
-			     IDENTIFIER_POINTER (yyvsp[0].ttype));
-		  yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyvsp[-1].ttype);
-		  TREE_STATIC (yyval.ttype) = TREE_STATIC (yyvsp[-1].ttype); ;}
+			     IDENTIFIER_POINTER ((yyvsp[(2) - (2)].ttype)));
+		  (yyval.ttype) = tree_cons (NULL_TREE, (yyvsp[(2) - (2)].ttype), (yyvsp[(1) - (2)].ttype));
+		  TREE_STATIC ((yyval.ttype)) = TREE_STATIC ((yyvsp[(1) - (2)].ttype)); }
     break;
 
   case 196:
+
+/* Line 1806 of yacc.c  */
 #line 1149 "c-parse.y"
-    { if (extra_warnings && TREE_STATIC (yyvsp[-1].ttype))
+    { if (extra_warnings && TREE_STATIC ((yyvsp[(1) - (2)].ttype)))
 		    warning ("`%s' is not at beginning of declaration",
-			     IDENTIFIER_POINTER (yyvsp[0].ttype));
-		  yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyvsp[-1].ttype);
-		  TREE_STATIC (yyval.ttype) = TREE_STATIC (yyvsp[-1].ttype); ;}
+			     IDENTIFIER_POINTER ((yyvsp[(2) - (2)].ttype)));
+		  (yyval.ttype) = tree_cons (NULL_TREE, (yyvsp[(2) - (2)].ttype), (yyvsp[(1) - (2)].ttype));
+		  TREE_STATIC ((yyval.ttype)) = TREE_STATIC ((yyvsp[(1) - (2)].ttype)); }
     break;
 
   case 197:
+
+/* Line 1806 of yacc.c  */
 #line 1155 "c-parse.y"
-    { if (extra_warnings && TREE_STATIC (yyvsp[-1].ttype))
+    { if (extra_warnings && TREE_STATIC ((yyvsp[(1) - (2)].ttype)))
 		    warning ("`%s' is not at beginning of declaration",
-			     IDENTIFIER_POINTER (yyvsp[0].ttype));
-		  yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyvsp[-1].ttype);
-		  TREE_STATIC (yyval.ttype) = TREE_STATIC (yyvsp[-1].ttype); ;}
+			     IDENTIFIER_POINTER ((yyvsp[(2) - (2)].ttype)));
+		  (yyval.ttype) = tree_cons (NULL_TREE, (yyvsp[(2) - (2)].ttype), (yyvsp[(1) - (2)].ttype));
+		  TREE_STATIC ((yyval.ttype)) = TREE_STATIC ((yyvsp[(1) - (2)].ttype)); }
     break;
 
   case 198:
+
+/* Line 1806 of yacc.c  */
 #line 1164 "c-parse.y"
-    { yyval.ttype = tree_cons (yyvsp[0].ttype, NULL_TREE, yyvsp[-1].ttype);
-		  TREE_STATIC (yyval.ttype) = TREE_STATIC (yyvsp[-1].ttype); ;}
+    { (yyval.ttype) = tree_cons ((yyvsp[(2) - (2)].ttype), NULL_TREE, (yyvsp[(1) - (2)].ttype));
+		  TREE_STATIC ((yyval.ttype)) = TREE_STATIC ((yyvsp[(1) - (2)].ttype)); }
     break;
 
   case 199:
+
+/* Line 1806 of yacc.c  */
 #line 1167 "c-parse.y"
-    { yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyvsp[-1].ttype);
-		  TREE_STATIC (yyval.ttype) = 1; ;}
+    { (yyval.ttype) = tree_cons (NULL_TREE, (yyvsp[(2) - (2)].ttype), (yyvsp[(1) - (2)].ttype));
+		  TREE_STATIC ((yyval.ttype)) = 1; }
     break;
 
   case 200:
+
+/* Line 1806 of yacc.c  */
 #line 1170 "c-parse.y"
-    { yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyvsp[-1].ttype);
-		  TREE_STATIC (yyval.ttype) = 1; ;}
+    { (yyval.ttype) = tree_cons (NULL_TREE, (yyvsp[(2) - (2)].ttype), (yyvsp[(1) - (2)].ttype));
+		  TREE_STATIC ((yyval.ttype)) = 1; }
     break;
 
   case 201:
+
+/* Line 1806 of yacc.c  */
 #line 1173 "c-parse.y"
-    { yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyvsp[-1].ttype);
-		  TREE_STATIC (yyval.ttype) = 1; ;}
+    { (yyval.ttype) = tree_cons (NULL_TREE, (yyvsp[(2) - (2)].ttype), (yyvsp[(1) - (2)].ttype));
+		  TREE_STATIC ((yyval.ttype)) = 1; }
     break;
 
   case 202:
+
+/* Line 1806 of yacc.c  */
 #line 1176 "c-parse.y"
-    { yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyvsp[-1].ttype);
-		  TREE_STATIC (yyval.ttype) = 1; ;}
+    { (yyval.ttype) = tree_cons (NULL_TREE, (yyvsp[(2) - (2)].ttype), (yyvsp[(1) - (2)].ttype));
+		  TREE_STATIC ((yyval.ttype)) = 1; }
     break;
 
   case 259:
+
+/* Line 1806 of yacc.c  */
 #line 1264 "c-parse.y"
-    { yyval.ttype = NULL_TREE; ;}
+    { (yyval.ttype) = NULL_TREE; }
     break;
 
   case 260:
+
+/* Line 1806 of yacc.c  */
 #line 1266 "c-parse.y"
-    { yyval.ttype = yyvsp[0].ttype; ;}
+    { (yyval.ttype) = (yyvsp[(1) - (1)].ttype); }
     break;
 
   case 264:
+
+/* Line 1806 of yacc.c  */
 #line 1301 "c-parse.y"
-    { OBJC_NEED_RAW_IDENTIFIER (1);	;}
+    { OBJC_NEED_RAW_IDENTIFIER (1);	}
     break;
 
   case 267:
+
+/* Line 1806 of yacc.c  */
 #line 1311 "c-parse.y"
     { /* For a typedef name, record the meaning, not the name.
 		     In case of `foo foo, bar;'.  */
-		  yyval.ttype = lookup_name (yyvsp[0].ttype); ;}
+		  (yyval.ttype) = lookup_name ((yyvsp[(1) - (1)].ttype)); }
     break;
 
   case 268:
+
+/* Line 1806 of yacc.c  */
 #line 1315 "c-parse.y"
-    { skip_evaluation--; yyval.ttype = TREE_TYPE (yyvsp[-1].ttype); ;}
+    { skip_evaluation--; (yyval.ttype) = TREE_TYPE ((yyvsp[(3) - (4)].ttype)); }
     break;
 
   case 269:
+
+/* Line 1806 of yacc.c  */
 #line 1317 "c-parse.y"
-    { skip_evaluation--; yyval.ttype = groktypename (yyvsp[-1].ttype); ;}
+    { skip_evaluation--; (yyval.ttype) = groktypename ((yyvsp[(3) - (4)].ttype)); }
     break;
 
   case 274:
+
+/* Line 1806 of yacc.c  */
 #line 1334 "c-parse.y"
-    { yyval.ttype = NULL_TREE; ;}
+    { (yyval.ttype) = NULL_TREE; }
     break;
 
   case 275:
+
+/* Line 1806 of yacc.c  */
 #line 1336 "c-parse.y"
-    { yyval.ttype = yyvsp[-1].ttype; ;}
+    { (yyval.ttype) = (yyvsp[(3) - (4)].ttype); }
     break;
 
   case 276:
+
+/* Line 1806 of yacc.c  */
 #line 1341 "c-parse.y"
-    { yyval.ttype = start_decl (yyvsp[-3].ttype, current_declspecs, 1,
-					  chainon (yyvsp[-1].ttype, all_prefix_attributes));
-		  start_init (yyval.ttype, yyvsp[-2].ttype, global_bindings_p ()); ;}
+    { (yyval.ttype) = start_decl ((yyvsp[(1) - (4)].ttype), current_declspecs, 1,
+					  chainon ((yyvsp[(3) - (4)].ttype), all_prefix_attributes));
+		  start_init ((yyval.ttype), (yyvsp[(2) - (4)].ttype), global_bindings_p ()); }
     break;
 
   case 277:
+
+/* Line 1806 of yacc.c  */
 #line 1346 "c-parse.y"
     { finish_init ();
-		  finish_decl (yyvsp[-1].ttype, yyvsp[0].ttype, yyvsp[-4].ttype); ;}
+		  finish_decl ((yyvsp[(5) - (6)].ttype), (yyvsp[(6) - (6)].ttype), (yyvsp[(2) - (6)].ttype)); }
     break;
 
   case 278:
+
+/* Line 1806 of yacc.c  */
 #line 1349 "c-parse.y"
-    { tree d = start_decl (yyvsp[-2].ttype, current_declspecs, 0,
-				       chainon (yyvsp[0].ttype, all_prefix_attributes));
-		  finish_decl (d, NULL_TREE, yyvsp[-1].ttype);
-                ;}
+    { tree d = start_decl ((yyvsp[(1) - (3)].ttype), current_declspecs, 0,
+				       chainon ((yyvsp[(3) - (3)].ttype), all_prefix_attributes));
+		  finish_decl (d, NULL_TREE, (yyvsp[(2) - (3)].ttype));
+                }
     break;
 
   case 279:
+
+/* Line 1806 of yacc.c  */
 #line 1357 "c-parse.y"
-    { yyval.ttype = start_decl (yyvsp[-3].ttype, current_declspecs, 1,
-					  chainon (yyvsp[-1].ttype, all_prefix_attributes));
-		  start_init (yyval.ttype, yyvsp[-2].ttype, global_bindings_p ()); ;}
+    { (yyval.ttype) = start_decl ((yyvsp[(1) - (4)].ttype), current_declspecs, 1,
+					  chainon ((yyvsp[(3) - (4)].ttype), all_prefix_attributes));
+		  start_init ((yyval.ttype), (yyvsp[(2) - (4)].ttype), global_bindings_p ()); }
     break;
 
   case 280:
+
+/* Line 1806 of yacc.c  */
 #line 1362 "c-parse.y"
     { finish_init ();
-		  finish_decl (yyvsp[-1].ttype, yyvsp[0].ttype, yyvsp[-4].ttype); ;}
+		  finish_decl ((yyvsp[(5) - (6)].ttype), (yyvsp[(6) - (6)].ttype), (yyvsp[(2) - (6)].ttype)); }
     break;
 
   case 281:
+
+/* Line 1806 of yacc.c  */
 #line 1365 "c-parse.y"
-    { tree d = start_decl (yyvsp[-2].ttype, current_declspecs, 0,
-				       chainon (yyvsp[0].ttype, all_prefix_attributes));
-		  finish_decl (d, NULL_TREE, yyvsp[-1].ttype); ;}
+    { tree d = start_decl ((yyvsp[(1) - (3)].ttype), current_declspecs, 0,
+				       chainon ((yyvsp[(3) - (3)].ttype), all_prefix_attributes));
+		  finish_decl (d, NULL_TREE, (yyvsp[(2) - (3)].ttype)); }
     break;
 
   case 282:
+
+/* Line 1806 of yacc.c  */
 #line 1373 "c-parse.y"
-    { yyval.ttype = NULL_TREE; ;}
+    { (yyval.ttype) = NULL_TREE; }
     break;
 
   case 283:
+
+/* Line 1806 of yacc.c  */
 #line 1375 "c-parse.y"
-    { yyval.ttype = yyvsp[0].ttype; ;}
+    { (yyval.ttype) = (yyvsp[(1) - (1)].ttype); }
     break;
 
   case 284:
+
+/* Line 1806 of yacc.c  */
 #line 1380 "c-parse.y"
-    { yyval.ttype = yyvsp[0].ttype; ;}
+    { (yyval.ttype) = (yyvsp[(1) - (1)].ttype); }
     break;
 
   case 285:
+
+/* Line 1806 of yacc.c  */
 #line 1382 "c-parse.y"
-    { yyval.ttype = chainon (yyvsp[-1].ttype, yyvsp[0].ttype); ;}
+    { (yyval.ttype) = chainon ((yyvsp[(1) - (2)].ttype), (yyvsp[(2) - (2)].ttype)); }
     break;
 
   case 286:
+
+/* Line 1806 of yacc.c  */
 #line 1387 "c-parse.y"
-    { yyval.ttype = yyvsp[-2].ttype; ;}
+    { (yyval.ttype) = (yyvsp[(4) - (6)].ttype); }
     break;
 
   case 287:
+
+/* Line 1806 of yacc.c  */
 #line 1392 "c-parse.y"
-    { yyval.ttype = yyvsp[0].ttype; ;}
+    { (yyval.ttype) = (yyvsp[(1) - (1)].ttype); }
     break;
 
   case 288:
+
+/* Line 1806 of yacc.c  */
 #line 1394 "c-parse.y"
-    { yyval.ttype = chainon (yyvsp[-2].ttype, yyvsp[0].ttype); ;}
+    { (yyval.ttype) = chainon ((yyvsp[(1) - (3)].ttype), (yyvsp[(3) - (3)].ttype)); }
     break;
 
   case 289:
+
+/* Line 1806 of yacc.c  */
 #line 1399 "c-parse.y"
-    { yyval.ttype = NULL_TREE; ;}
+    { (yyval.ttype) = NULL_TREE; }
     break;
 
   case 290:
+
+/* Line 1806 of yacc.c  */
 #line 1401 "c-parse.y"
-    { yyval.ttype = build_tree_list (yyvsp[0].ttype, NULL_TREE); ;}
+    { (yyval.ttype) = build_tree_list ((yyvsp[(1) - (1)].ttype), NULL_TREE); }
     break;
 
   case 291:
+
+/* Line 1806 of yacc.c  */
 #line 1403 "c-parse.y"
-    { yyval.ttype = build_tree_list (yyvsp[-3].ttype, build_tree_list (NULL_TREE, yyvsp[-1].ttype)); ;}
+    { (yyval.ttype) = build_tree_list ((yyvsp[(1) - (4)].ttype), build_tree_list (NULL_TREE, (yyvsp[(3) - (4)].ttype))); }
     break;
 
   case 292:
+
+/* Line 1806 of yacc.c  */
 #line 1405 "c-parse.y"
-    { yyval.ttype = build_tree_list (yyvsp[-5].ttype, tree_cons (NULL_TREE, yyvsp[-3].ttype, yyvsp[-1].ttype)); ;}
+    { (yyval.ttype) = build_tree_list ((yyvsp[(1) - (6)].ttype), tree_cons (NULL_TREE, (yyvsp[(3) - (6)].ttype), (yyvsp[(5) - (6)].ttype))); }
     break;
 
   case 293:
+
+/* Line 1806 of yacc.c  */
 #line 1407 "c-parse.y"
-    { yyval.ttype = build_tree_list (yyvsp[-3].ttype, yyvsp[-1].ttype); ;}
+    { (yyval.ttype) = build_tree_list ((yyvsp[(1) - (4)].ttype), (yyvsp[(3) - (4)].ttype)); }
     break;
 
   case 301:
+
+/* Line 1806 of yacc.c  */
 #line 1430 "c-parse.y"
-    { really_start_incremental_init (NULL_TREE); ;}
+    { really_start_incremental_init (NULL_TREE); }
     break;
 
   case 302:
+
+/* Line 1806 of yacc.c  */
 #line 1432 "c-parse.y"
-    { yyval.ttype = pop_init_level (0); ;}
+    { (yyval.ttype) = pop_init_level (0); }
     break;
 
   case 303:
+
+/* Line 1806 of yacc.c  */
 #line 1434 "c-parse.y"
-    { yyval.ttype = error_mark_node; ;}
+    { (yyval.ttype) = error_mark_node; }
     break;
 
   case 304:
+
+/* Line 1806 of yacc.c  */
 #line 1440 "c-parse.y"
     { if (pedantic)
-		    pedwarn ("ISO C forbids empty initializer braces"); ;}
+		    pedwarn ("ISO C forbids empty initializer braces"); }
     break;
 
   case 308:
+
+/* Line 1806 of yacc.c  */
 #line 1454 "c-parse.y"
     { if (pedantic && ! flag_isoc99)
-		    pedwarn ("ISO C89 forbids specifying subobject to initialize"); ;}
+		    pedwarn ("ISO C89 forbids specifying subobject to initialize"); }
     break;
 
   case 309:
+
+/* Line 1806 of yacc.c  */
 #line 1457 "c-parse.y"
     { if (pedantic)
-		    pedwarn ("obsolete use of designated initializer without `='"); ;}
+		    pedwarn ("obsolete use of designated initializer without `='"); }
     break;
 
   case 310:
+
+/* Line 1806 of yacc.c  */
 #line 1460 "c-parse.y"
-    { set_init_label (yyvsp[-1].ttype);
+    { set_init_label ((yyvsp[(1) - (2)].ttype));
 		  if (pedantic)
-		    pedwarn ("obsolete use of designated initializer with `:'"); ;}
+		    pedwarn ("obsolete use of designated initializer with `:'"); }
     break;
 
   case 311:
+
+/* Line 1806 of yacc.c  */
 #line 1464 "c-parse.y"
-    {;}
+    {}
     break;
 
   case 313:
+
+/* Line 1806 of yacc.c  */
 #line 1470 "c-parse.y"
-    { push_init_level (0); ;}
+    { push_init_level (0); }
     break;
 
   case 314:
+
+/* Line 1806 of yacc.c  */
 #line 1472 "c-parse.y"
-    { process_init_element (pop_init_level (0)); ;}
+    { process_init_element (pop_init_level (0)); }
     break;
 
   case 315:
+
+/* Line 1806 of yacc.c  */
 #line 1474 "c-parse.y"
-    { process_init_element (yyvsp[0].ttype); ;}
+    { process_init_element ((yyvsp[(1) - (1)].ttype)); }
     break;
 
   case 319:
+
+/* Line 1806 of yacc.c  */
 #line 1485 "c-parse.y"
-    { set_init_label (yyvsp[0].ttype); ;}
+    { set_init_label ((yyvsp[(2) - (2)].ttype)); }
     break;
 
   case 320:
+
+/* Line 1806 of yacc.c  */
 #line 1487 "c-parse.y"
-    { set_init_index (yyvsp[-3].ttype, yyvsp[-1].ttype);
+    { set_init_index ((yyvsp[(2) - (5)].ttype), (yyvsp[(4) - (5)].ttype));
 		  if (pedantic)
-		    pedwarn ("ISO C forbids specifying range of elements to initialize"); ;}
+		    pedwarn ("ISO C forbids specifying range of elements to initialize"); }
     break;
 
   case 321:
+
+/* Line 1806 of yacc.c  */
 #line 1491 "c-parse.y"
-    { set_init_index (yyvsp[-1].ttype, NULL_TREE); ;}
+    { set_init_index ((yyvsp[(2) - (3)].ttype), NULL_TREE); }
     break;
 
   case 322:
+
+/* Line 1806 of yacc.c  */
 #line 1496 "c-parse.y"
     { if (pedantic)
 		    pedwarn ("ISO C forbids nested functions");
 
 		  push_function_context ();
-		  if (! start_function (current_declspecs, yyvsp[0].ttype,
+		  if (! start_function (current_declspecs, (yyvsp[(1) - (1)].ttype),
 					all_prefix_attributes))
 		    {
 		      pop_function_context ();
 		      YYERROR1;
 		    }
 		  parsing_iso_function_signature = false; /* Don't warn about nested functions.  */
-		;}
+		}
     break;
 
   case 323:
+
+/* Line 1806 of yacc.c  */
 #line 1509 "c-parse.y"
-    { store_parm_decls (); ;}
+    { store_parm_decls (); }
     break;
 
   case 324:
+
+/* Line 1806 of yacc.c  */
 #line 1517 "c-parse.y"
     { tree decl = current_function_decl;
-		  DECL_SOURCE_FILE (decl) = yyvsp[-2].filename;
-		  DECL_SOURCE_LINE (decl) = yyvsp[-1].lineno;
+		  DECL_SOURCE_FILE (decl) = (yyvsp[(5) - (7)].filename);
+		  DECL_SOURCE_LINE (decl) = (yyvsp[(6) - (7)].lineno);
 		  finish_function (1, 1);
 		  pop_function_context ();
-		  add_decl_stmt (decl); ;}
+		  add_decl_stmt (decl); }
     break;
 
   case 325:
+
+/* Line 1806 of yacc.c  */
 #line 1527 "c-parse.y"
     { if (pedantic)
 		    pedwarn ("ISO C forbids nested functions");
 
 		  push_function_context ();
-		  if (! start_function (current_declspecs, yyvsp[0].ttype,
+		  if (! start_function (current_declspecs, (yyvsp[(1) - (1)].ttype),
 					all_prefix_attributes))
 		    {
 		      pop_function_context ();
 		      YYERROR1;
 		    }
 		  parsing_iso_function_signature = false; /* Don't warn about nested functions.  */
-		;}
+		}
     break;
 
   case 326:
+
+/* Line 1806 of yacc.c  */
 #line 1540 "c-parse.y"
-    { store_parm_decls (); ;}
+    { store_parm_decls (); }
     break;
 
   case 327:
+
+/* Line 1806 of yacc.c  */
 #line 1548 "c-parse.y"
     { tree decl = current_function_decl;
-		  DECL_SOURCE_FILE (decl) = yyvsp[-2].filename;
-		  DECL_SOURCE_LINE (decl) = yyvsp[-1].lineno;
+		  DECL_SOURCE_FILE (decl) = (yyvsp[(5) - (7)].filename);
+		  DECL_SOURCE_LINE (decl) = (yyvsp[(6) - (7)].lineno);
 		  finish_function (1, 1);
 		  pop_function_context ();
-		  add_decl_stmt (decl); ;}
+		  add_decl_stmt (decl); }
     break;
 
   case 330:
+
+/* Line 1806 of yacc.c  */
 #line 1568 "c-parse.y"
-    { yyval.ttype = yyvsp[-2].ttype ? tree_cons (yyvsp[-2].ttype, yyvsp[-1].ttype, NULL_TREE) : yyvsp[-1].ttype; ;}
+    { (yyval.ttype) = (yyvsp[(2) - (4)].ttype) ? tree_cons ((yyvsp[(2) - (4)].ttype), (yyvsp[(3) - (4)].ttype), NULL_TREE) : (yyvsp[(3) - (4)].ttype); }
     break;
 
   case 331:
+
+/* Line 1806 of yacc.c  */
 #line 1570 "c-parse.y"
-    { yyval.ttype = build_nt (CALL_EXPR, yyvsp[-2].ttype, yyvsp[0].ttype, NULL_TREE); ;}
+    { (yyval.ttype) = build_nt (CALL_EXPR, (yyvsp[(1) - (3)].ttype), (yyvsp[(3) - (3)].ttype), NULL_TREE); }
     break;
 
   case 332:
+
+/* Line 1806 of yacc.c  */
 #line 1575 "c-parse.y"
-    { yyval.ttype = set_array_declarator_type (yyvsp[0].ttype, yyvsp[-1].ttype, 0); ;}
+    { (yyval.ttype) = set_array_declarator_type ((yyvsp[(2) - (2)].ttype), (yyvsp[(1) - (2)].ttype), 0); }
     break;
 
   case 333:
+
+/* Line 1806 of yacc.c  */
 #line 1577 "c-parse.y"
-    { yyval.ttype = make_pointer_declarator (yyvsp[-1].ttype, yyvsp[0].ttype); ;}
+    { (yyval.ttype) = make_pointer_declarator ((yyvsp[(2) - (3)].ttype), (yyvsp[(3) - (3)].ttype)); }
     break;
 
   case 337:
+
+/* Line 1806 of yacc.c  */
 #line 1592 "c-parse.y"
-    { yyval.ttype = build_nt (CALL_EXPR, yyvsp[-2].ttype, yyvsp[0].ttype, NULL_TREE); ;}
+    { (yyval.ttype) = build_nt (CALL_EXPR, (yyvsp[(1) - (3)].ttype), (yyvsp[(3) - (3)].ttype), NULL_TREE); }
     break;
 
   case 338:
+
+/* Line 1806 of yacc.c  */
 #line 1597 "c-parse.y"
-    { yyval.ttype = set_array_declarator_type (yyvsp[0].ttype, yyvsp[-1].ttype, 0); ;}
+    { (yyval.ttype) = set_array_declarator_type ((yyvsp[(2) - (2)].ttype), (yyvsp[(1) - (2)].ttype), 0); }
     break;
 
   case 340:
+
+/* Line 1806 of yacc.c  */
 #line 1603 "c-parse.y"
-    { yyval.ttype = build_nt (CALL_EXPR, yyvsp[-2].ttype, yyvsp[0].ttype, NULL_TREE); ;}
+    { (yyval.ttype) = build_nt (CALL_EXPR, (yyvsp[(1) - (3)].ttype), (yyvsp[(3) - (3)].ttype), NULL_TREE); }
     break;
 
   case 341:
+
+/* Line 1806 of yacc.c  */
 #line 1608 "c-parse.y"
-    { yyval.ttype = set_array_declarator_type (yyvsp[0].ttype, yyvsp[-1].ttype, 0); ;}
+    { (yyval.ttype) = set_array_declarator_type ((yyvsp[(2) - (2)].ttype), (yyvsp[(1) - (2)].ttype), 0); }
     break;
 
   case 342:
+
+/* Line 1806 of yacc.c  */
 #line 1610 "c-parse.y"
-    { yyval.ttype = make_pointer_declarator (yyvsp[-1].ttype, yyvsp[0].ttype); ;}
+    { (yyval.ttype) = make_pointer_declarator ((yyvsp[(2) - (3)].ttype), (yyvsp[(3) - (3)].ttype)); }
     break;
 
   case 343:
+
+/* Line 1806 of yacc.c  */
 #line 1612 "c-parse.y"
-    { yyval.ttype = make_pointer_declarator (yyvsp[-1].ttype, yyvsp[0].ttype); ;}
+    { (yyval.ttype) = make_pointer_declarator ((yyvsp[(2) - (3)].ttype), (yyvsp[(3) - (3)].ttype)); }
     break;
 
   case 344:
+
+/* Line 1806 of yacc.c  */
 #line 1614 "c-parse.y"
-    { yyval.ttype = yyvsp[-2].ttype ? tree_cons (yyvsp[-2].ttype, yyvsp[-1].ttype, NULL_TREE) : yyvsp[-1].ttype; ;}
+    { (yyval.ttype) = (yyvsp[(2) - (4)].ttype) ? tree_cons ((yyvsp[(2) - (4)].ttype), (yyvsp[(3) - (4)].ttype), NULL_TREE) : (yyvsp[(3) - (4)].ttype); }
     break;
 
   case 345:
+
+/* Line 1806 of yacc.c  */
 #line 1622 "c-parse.y"
-    { yyval.ttype = build_nt (CALL_EXPR, yyvsp[-2].ttype, yyvsp[0].ttype, NULL_TREE); ;}
+    { (yyval.ttype) = build_nt (CALL_EXPR, (yyvsp[(1) - (3)].ttype), (yyvsp[(3) - (3)].ttype), NULL_TREE); }
     break;
 
   case 346:
+
+/* Line 1806 of yacc.c  */
 #line 1627 "c-parse.y"
-    { yyval.ttype = yyvsp[-2].ttype ? tree_cons (yyvsp[-2].ttype, yyvsp[-1].ttype, NULL_TREE) : yyvsp[-1].ttype; ;}
+    { (yyval.ttype) = (yyvsp[(2) - (4)].ttype) ? tree_cons ((yyvsp[(2) - (4)].ttype), (yyvsp[(3) - (4)].ttype), NULL_TREE) : (yyvsp[(3) - (4)].ttype); }
     break;
 
   case 347:
+
+/* Line 1806 of yacc.c  */
 #line 1629 "c-parse.y"
-    { yyval.ttype = make_pointer_declarator (yyvsp[-1].ttype, yyvsp[0].ttype); ;}
+    { (yyval.ttype) = make_pointer_declarator ((yyvsp[(2) - (3)].ttype), (yyvsp[(3) - (3)].ttype)); }
     break;
 
   case 348:
+
+/* Line 1806 of yacc.c  */
 #line 1631 "c-parse.y"
-    { yyval.ttype = set_array_declarator_type (yyvsp[0].ttype, yyvsp[-1].ttype, 0); ;}
+    { (yyval.ttype) = set_array_declarator_type ((yyvsp[(2) - (2)].ttype), (yyvsp[(1) - (2)].ttype), 0); }
     break;
 
   case 350:
+
+/* Line 1806 of yacc.c  */
 #line 1637 "c-parse.y"
-    { yyval.ttype = NULL_TREE; ;}
+    { (yyval.ttype) = NULL_TREE; }
     break;
 
   case 351:
+
+/* Line 1806 of yacc.c  */
 #line 1639 "c-parse.y"
-    { yyval.ttype = yyvsp[0].ttype; ;}
+    { (yyval.ttype) = (yyvsp[(2) - (2)].ttype); }
     break;
 
   case 352:
+
+/* Line 1806 of yacc.c  */
 #line 1644 "c-parse.y"
-    { yyval.ttype = NULL_TREE; ;}
+    { (yyval.ttype) = NULL_TREE; }
     break;
 
   case 353:
+
+/* Line 1806 of yacc.c  */
 #line 1646 "c-parse.y"
-    { yyval.ttype = yyvsp[0].ttype; ;}
+    { (yyval.ttype) = (yyvsp[(2) - (2)].ttype); }
     break;
 
   case 354:
+
+/* Line 1806 of yacc.c  */
 #line 1651 "c-parse.y"
-    { yyval.ttype = NULL_TREE; ;}
+    { (yyval.ttype) = NULL_TREE; }
     break;
 
   case 355:
+
+/* Line 1806 of yacc.c  */
 #line 1653 "c-parse.y"
-    { yyval.ttype = yyvsp[0].ttype; ;}
+    { (yyval.ttype) = (yyvsp[(2) - (2)].ttype); }
     break;
 
   case 356:
+
+/* Line 1806 of yacc.c  */
 #line 1664 "c-parse.y"
-    { yyval.ttype = start_struct (RECORD_TYPE, yyvsp[-1].ttype);
+    { (yyval.ttype) = start_struct (RECORD_TYPE, (yyvsp[(2) - (3)].ttype));
 		  /* Start scope of tag before parsing components.  */
-		;}
+		}
     break;
 
   case 357:
+
+/* Line 1806 of yacc.c  */
 #line 1668 "c-parse.y"
-    { yyval.ttype = finish_struct (yyvsp[-3].ttype, yyvsp[-2].ttype, chainon (yyvsp[-6].ttype, yyvsp[0].ttype)); ;}
+    { (yyval.ttype) = finish_struct ((yyvsp[(4) - (7)].ttype), (yyvsp[(5) - (7)].ttype), chainon ((yyvsp[(1) - (7)].ttype), (yyvsp[(7) - (7)].ttype))); }
     break;
 
   case 358:
+
+/* Line 1806 of yacc.c  */
 #line 1670 "c-parse.y"
-    { yyval.ttype = finish_struct (start_struct (RECORD_TYPE, NULL_TREE),
-				      yyvsp[-2].ttype, chainon (yyvsp[-4].ttype, yyvsp[0].ttype));
-		;}
+    { (yyval.ttype) = finish_struct (start_struct (RECORD_TYPE, NULL_TREE),
+				      (yyvsp[(3) - (5)].ttype), chainon ((yyvsp[(1) - (5)].ttype), (yyvsp[(5) - (5)].ttype)));
+		}
     break;
 
   case 359:
+
+/* Line 1806 of yacc.c  */
 #line 1674 "c-parse.y"
-    { yyval.ttype = start_struct (UNION_TYPE, yyvsp[-1].ttype); ;}
+    { (yyval.ttype) = start_struct (UNION_TYPE, (yyvsp[(2) - (3)].ttype)); }
     break;
 
   case 360:
+
+/* Line 1806 of yacc.c  */
 #line 1676 "c-parse.y"
-    { yyval.ttype = finish_struct (yyvsp[-3].ttype, yyvsp[-2].ttype, chainon (yyvsp[-6].ttype, yyvsp[0].ttype)); ;}
+    { (yyval.ttype) = finish_struct ((yyvsp[(4) - (7)].ttype), (yyvsp[(5) - (7)].ttype), chainon ((yyvsp[(1) - (7)].ttype), (yyvsp[(7) - (7)].ttype))); }
     break;
 
   case 361:
+
+/* Line 1806 of yacc.c  */
 #line 1678 "c-parse.y"
-    { yyval.ttype = finish_struct (start_struct (UNION_TYPE, NULL_TREE),
-				      yyvsp[-2].ttype, chainon (yyvsp[-4].ttype, yyvsp[0].ttype));
-		;}
+    { (yyval.ttype) = finish_struct (start_struct (UNION_TYPE, NULL_TREE),
+				      (yyvsp[(3) - (5)].ttype), chainon ((yyvsp[(1) - (5)].ttype), (yyvsp[(5) - (5)].ttype)));
+		}
     break;
 
   case 362:
+
+/* Line 1806 of yacc.c  */
 #line 1682 "c-parse.y"
-    { yyval.ttype = start_enum (yyvsp[-1].ttype); ;}
+    { (yyval.ttype) = start_enum ((yyvsp[(2) - (3)].ttype)); }
     break;
 
   case 363:
+
+/* Line 1806 of yacc.c  */
 #line 1684 "c-parse.y"
-    { yyval.ttype = finish_enum (yyvsp[-4].ttype, nreverse (yyvsp[-3].ttype),
-				    chainon (yyvsp[-7].ttype, yyvsp[0].ttype)); ;}
+    { (yyval.ttype) = finish_enum ((yyvsp[(4) - (8)].ttype), nreverse ((yyvsp[(5) - (8)].ttype)),
+				    chainon ((yyvsp[(1) - (8)].ttype), (yyvsp[(8) - (8)].ttype))); }
     break;
 
   case 364:
+
+/* Line 1806 of yacc.c  */
 #line 1687 "c-parse.y"
-    { yyval.ttype = start_enum (NULL_TREE); ;}
+    { (yyval.ttype) = start_enum (NULL_TREE); }
     break;
 
   case 365:
+
+/* Line 1806 of yacc.c  */
 #line 1689 "c-parse.y"
-    { yyval.ttype = finish_enum (yyvsp[-4].ttype, nreverse (yyvsp[-3].ttype),
-				    chainon (yyvsp[-6].ttype, yyvsp[0].ttype)); ;}
+    { (yyval.ttype) = finish_enum ((yyvsp[(3) - (7)].ttype), nreverse ((yyvsp[(4) - (7)].ttype)),
+				    chainon ((yyvsp[(1) - (7)].ttype), (yyvsp[(7) - (7)].ttype))); }
     break;
 
   case 366:
+
+/* Line 1806 of yacc.c  */
 #line 1695 "c-parse.y"
-    { yyval.ttype = xref_tag (RECORD_TYPE, yyvsp[0].ttype); ;}
+    { (yyval.ttype) = xref_tag (RECORD_TYPE, (yyvsp[(2) - (2)].ttype)); }
     break;
 
   case 367:
+
+/* Line 1806 of yacc.c  */
 #line 1697 "c-parse.y"
-    { yyval.ttype = xref_tag (UNION_TYPE, yyvsp[0].ttype); ;}
+    { (yyval.ttype) = xref_tag (UNION_TYPE, (yyvsp[(2) - (2)].ttype)); }
     break;
 
   case 368:
+
+/* Line 1806 of yacc.c  */
 #line 1699 "c-parse.y"
-    { yyval.ttype = xref_tag (ENUMERAL_TYPE, yyvsp[0].ttype);
+    { (yyval.ttype) = xref_tag (ENUMERAL_TYPE, (yyvsp[(2) - (2)].ttype));
 		  /* In ISO C, enumerated types can be referred to
 		     only if already defined.  */
-		  if (pedantic && !COMPLETE_TYPE_P (yyval.ttype))
-		    pedwarn ("ISO C forbids forward references to `enum' types"); ;}
+		  if (pedantic && !COMPLETE_TYPE_P ((yyval.ttype)))
+		    pedwarn ("ISO C forbids forward references to `enum' types"); }
     break;
 
   case 372:
+
+/* Line 1806 of yacc.c  */
 #line 1714 "c-parse.y"
     { if (pedantic && ! flag_isoc99)
-		    pedwarn ("comma at end of enumerator list"); ;}
+		    pedwarn ("comma at end of enumerator list"); }
     break;
 
   case 373:
+
+/* Line 1806 of yacc.c  */
 #line 1720 "c-parse.y"
-    { yyval.ttype = yyvsp[0].ttype; ;}
+    { (yyval.ttype) = (yyvsp[(1) - (1)].ttype); }
     break;
 
   case 374:
+
+/* Line 1806 of yacc.c  */
 #line 1722 "c-parse.y"
-    { yyval.ttype = chainon (yyvsp[-1].ttype, yyvsp[0].ttype);
-		  pedwarn ("no semicolon at end of struct or union"); ;}
+    { (yyval.ttype) = chainon ((yyvsp[(1) - (2)].ttype), (yyvsp[(2) - (2)].ttype));
+		  pedwarn ("no semicolon at end of struct or union"); }
     break;
 
   case 375:
+
+/* Line 1806 of yacc.c  */
 #line 1727 "c-parse.y"
-    { yyval.ttype = NULL_TREE; ;}
+    { (yyval.ttype) = NULL_TREE; }
     break;
 
   case 376:
+
+/* Line 1806 of yacc.c  */
 #line 1729 "c-parse.y"
-    { yyval.ttype = chainon (yyvsp[-2].ttype, yyvsp[-1].ttype); ;}
+    { (yyval.ttype) = chainon ((yyvsp[(1) - (3)].ttype), (yyvsp[(2) - (3)].ttype)); }
     break;
 
   case 377:
+
+/* Line 1806 of yacc.c  */
 #line 1731 "c-parse.y"
     { if (pedantic)
-		    pedwarn ("extra semicolon in struct or union specified"); ;}
+		    pedwarn ("extra semicolon in struct or union specified"); }
     break;
 
   case 378:
+
+/* Line 1806 of yacc.c  */
 #line 1737 "c-parse.y"
-    { yyval.ttype = yyvsp[0].ttype;
-		  POP_DECLSPEC_STACK; ;}
+    { (yyval.ttype) = (yyvsp[(3) - (3)].ttype);
+		  POP_DECLSPEC_STACK; }
     break;
 
   case 379:
+
+/* Line 1806 of yacc.c  */
 #line 1740 "c-parse.y"
     {
 		  /* Support for unnamed structs or unions as members of
@@ -4339,303 +5199,399 @@
 		  if (pedantic)
 		    pedwarn ("ISO C doesn't support unnamed structs/unions");
 
-		  yyval.ttype = grokfield(yyvsp[-1].filename, yyvsp[0].lineno, NULL, current_declspecs, NULL_TREE);
-		  POP_DECLSPEC_STACK; ;}
+		  (yyval.ttype) = grokfield((yyvsp[(3) - (4)].filename), (yyvsp[(4) - (4)].lineno), NULL, current_declspecs, NULL_TREE);
+		  POP_DECLSPEC_STACK; }
     break;
 
   case 380:
+
+/* Line 1806 of yacc.c  */
 #line 1750 "c-parse.y"
-    { yyval.ttype = yyvsp[0].ttype;
-		  POP_DECLSPEC_STACK; ;}
+    { (yyval.ttype) = (yyvsp[(3) - (3)].ttype);
+		  POP_DECLSPEC_STACK; }
     break;
 
   case 381:
+
+/* Line 1806 of yacc.c  */
 #line 1753 "c-parse.y"
     { if (pedantic)
 		    pedwarn ("ISO C forbids member declarations with no members");
-		  shadow_tag(yyvsp[0].ttype);
-		  yyval.ttype = NULL_TREE; ;}
+		  shadow_tag((yyvsp[(1) - (1)].ttype));
+		  (yyval.ttype) = NULL_TREE; }
     break;
 
   case 382:
+
+/* Line 1806 of yacc.c  */
 #line 1758 "c-parse.y"
-    { yyval.ttype = NULL_TREE; ;}
+    { (yyval.ttype) = NULL_TREE; }
     break;
 
   case 383:
+
+/* Line 1806 of yacc.c  */
 #line 1760 "c-parse.y"
-    { yyval.ttype = yyvsp[0].ttype;
-		  RESTORE_EXT_FLAGS (yyvsp[-1].ttype); ;}
+    { (yyval.ttype) = (yyvsp[(2) - (2)].ttype);
+		  RESTORE_EXT_FLAGS ((yyvsp[(1) - (2)].ttype)); }
     break;
 
   case 385:
+
+/* Line 1806 of yacc.c  */
 #line 1767 "c-parse.y"
-    { yyval.ttype = chainon (yyvsp[-3].ttype, yyvsp[0].ttype); ;}
+    { (yyval.ttype) = chainon ((yyvsp[(1) - (4)].ttype), (yyvsp[(4) - (4)].ttype)); }
     break;
 
   case 387:
+
+/* Line 1806 of yacc.c  */
 #line 1773 "c-parse.y"
-    { yyval.ttype = chainon (yyvsp[-3].ttype, yyvsp[0].ttype); ;}
+    { (yyval.ttype) = chainon ((yyvsp[(1) - (4)].ttype), (yyvsp[(4) - (4)].ttype)); }
     break;
 
   case 388:
+
+/* Line 1806 of yacc.c  */
 #line 1778 "c-parse.y"
-    { yyval.ttype = grokfield (yyvsp[-3].filename, yyvsp[-2].lineno, yyvsp[-1].ttype, current_declspecs, NULL_TREE);
-		  decl_attributes (&yyval.ttype, chainon (yyvsp[0].ttype, all_prefix_attributes), 0); ;}
+    { (yyval.ttype) = grokfield ((yyvsp[(1) - (4)].filename), (yyvsp[(2) - (4)].lineno), (yyvsp[(3) - (4)].ttype), current_declspecs, NULL_TREE);
+		  decl_attributes (&(yyval.ttype), chainon ((yyvsp[(4) - (4)].ttype), all_prefix_attributes), 0); }
     break;
 
   case 389:
+
+/* Line 1806 of yacc.c  */
 #line 1782 "c-parse.y"
-    { yyval.ttype = grokfield (yyvsp[-5].filename, yyvsp[-4].lineno, yyvsp[-3].ttype, current_declspecs, yyvsp[-1].ttype);
-		  decl_attributes (&yyval.ttype, chainon (yyvsp[0].ttype, all_prefix_attributes), 0); ;}
+    { (yyval.ttype) = grokfield ((yyvsp[(1) - (6)].filename), (yyvsp[(2) - (6)].lineno), (yyvsp[(3) - (6)].ttype), current_declspecs, (yyvsp[(5) - (6)].ttype));
+		  decl_attributes (&(yyval.ttype), chainon ((yyvsp[(6) - (6)].ttype), all_prefix_attributes), 0); }
     break;
 
   case 390:
+
+/* Line 1806 of yacc.c  */
 #line 1785 "c-parse.y"
-    { yyval.ttype = grokfield (yyvsp[-4].filename, yyvsp[-3].lineno, NULL_TREE, current_declspecs, yyvsp[-1].ttype);
-		  decl_attributes (&yyval.ttype, chainon (yyvsp[0].ttype, all_prefix_attributes), 0); ;}
+    { (yyval.ttype) = grokfield ((yyvsp[(1) - (5)].filename), (yyvsp[(2) - (5)].lineno), NULL_TREE, current_declspecs, (yyvsp[(4) - (5)].ttype));
+		  decl_attributes (&(yyval.ttype), chainon ((yyvsp[(5) - (5)].ttype), all_prefix_attributes), 0); }
     break;
 
   case 391:
+
+/* Line 1806 of yacc.c  */
 #line 1791 "c-parse.y"
-    { yyval.ttype = grokfield (yyvsp[-3].filename, yyvsp[-2].lineno, yyvsp[-1].ttype, current_declspecs, NULL_TREE);
-		  decl_attributes (&yyval.ttype, chainon (yyvsp[0].ttype, all_prefix_attributes), 0); ;}
+    { (yyval.ttype) = grokfield ((yyvsp[(1) - (4)].filename), (yyvsp[(2) - (4)].lineno), (yyvsp[(3) - (4)].ttype), current_declspecs, NULL_TREE);
+		  decl_attributes (&(yyval.ttype), chainon ((yyvsp[(4) - (4)].ttype), all_prefix_attributes), 0); }
     break;
 
   case 392:
+
+/* Line 1806 of yacc.c  */
 #line 1795 "c-parse.y"
-    { yyval.ttype = grokfield (yyvsp[-5].filename, yyvsp[-4].lineno, yyvsp[-3].ttype, current_declspecs, yyvsp[-1].ttype);
-		  decl_attributes (&yyval.ttype, chainon (yyvsp[0].ttype, all_prefix_attributes), 0); ;}
+    { (yyval.ttype) = grokfield ((yyvsp[(1) - (6)].filename), (yyvsp[(2) - (6)].lineno), (yyvsp[(3) - (6)].ttype), current_declspecs, (yyvsp[(5) - (6)].ttype));
+		  decl_attributes (&(yyval.ttype), chainon ((yyvsp[(6) - (6)].ttype), all_prefix_attributes), 0); }
     break;
 
   case 393:
+
+/* Line 1806 of yacc.c  */
 #line 1798 "c-parse.y"
-    { yyval.ttype = grokfield (yyvsp[-4].filename, yyvsp[-3].lineno, NULL_TREE, current_declspecs, yyvsp[-1].ttype);
-		  decl_attributes (&yyval.ttype, chainon (yyvsp[0].ttype, all_prefix_attributes), 0); ;}
+    { (yyval.ttype) = grokfield ((yyvsp[(1) - (5)].filename), (yyvsp[(2) - (5)].lineno), NULL_TREE, current_declspecs, (yyvsp[(4) - (5)].ttype));
+		  decl_attributes (&(yyval.ttype), chainon ((yyvsp[(5) - (5)].ttype), all_prefix_attributes), 0); }
     break;
 
   case 395:
+
+/* Line 1806 of yacc.c  */
 #line 1810 "c-parse.y"
-    { if (yyvsp[-2].ttype == error_mark_node)
-		    yyval.ttype = yyvsp[-2].ttype;
+    { if ((yyvsp[(1) - (3)].ttype) == error_mark_node)
+		    (yyval.ttype) = (yyvsp[(1) - (3)].ttype);
 		  else
-		    yyval.ttype = chainon (yyvsp[0].ttype, yyvsp[-2].ttype); ;}
+		    (yyval.ttype) = chainon ((yyvsp[(3) - (3)].ttype), (yyvsp[(1) - (3)].ttype)); }
     break;
 
   case 396:
+
+/* Line 1806 of yacc.c  */
 #line 1815 "c-parse.y"
-    { yyval.ttype = error_mark_node; ;}
+    { (yyval.ttype) = error_mark_node; }
     break;
 
   case 397:
+
+/* Line 1806 of yacc.c  */
 #line 1821 "c-parse.y"
-    { yyval.ttype = build_enumerator (yyvsp[0].ttype, NULL_TREE); ;}
+    { (yyval.ttype) = build_enumerator ((yyvsp[(1) - (1)].ttype), NULL_TREE); }
     break;
 
   case 398:
+
+/* Line 1806 of yacc.c  */
 #line 1823 "c-parse.y"
-    { yyval.ttype = build_enumerator (yyvsp[-2].ttype, yyvsp[0].ttype); ;}
+    { (yyval.ttype) = build_enumerator ((yyvsp[(1) - (3)].ttype), (yyvsp[(3) - (3)].ttype)); }
     break;
 
   case 399:
+
+/* Line 1806 of yacc.c  */
 #line 1828 "c-parse.y"
     { pending_xref_error ();
-		  yyval.ttype = yyvsp[0].ttype; ;}
+		  (yyval.ttype) = (yyvsp[(1) - (1)].ttype); }
     break;
 
   case 400:
+
+/* Line 1806 of yacc.c  */
 #line 1831 "c-parse.y"
-    { yyval.ttype = build_tree_list (yyvsp[-1].ttype, yyvsp[0].ttype); ;}
+    { (yyval.ttype) = build_tree_list ((yyvsp[(2) - (3)].ttype), (yyvsp[(3) - (3)].ttype)); }
     break;
 
   case 401:
+
+/* Line 1806 of yacc.c  */
 #line 1836 "c-parse.y"
-    { yyval.ttype = NULL_TREE; ;}
+    { (yyval.ttype) = NULL_TREE; }
     break;
 
   case 403:
+
+/* Line 1806 of yacc.c  */
 #line 1842 "c-parse.y"
-    { yyval.ttype = build_tree_list (build_tree_list (current_declspecs,
+    { (yyval.ttype) = build_tree_list (build_tree_list (current_declspecs,
 							 NULL_TREE),
-					all_prefix_attributes); ;}
+					all_prefix_attributes); }
     break;
 
   case 404:
+
+/* Line 1806 of yacc.c  */
 #line 1846 "c-parse.y"
-    { yyval.ttype = build_tree_list (build_tree_list (current_declspecs,
-							 yyvsp[0].ttype),
-					all_prefix_attributes); ;}
+    { (yyval.ttype) = build_tree_list (build_tree_list (current_declspecs,
+							 (yyvsp[(1) - (1)].ttype)),
+					all_prefix_attributes); }
     break;
 
   case 405:
+
+/* Line 1806 of yacc.c  */
 #line 1850 "c-parse.y"
-    { yyval.ttype = build_tree_list (build_tree_list (current_declspecs,
-							 yyvsp[-1].ttype),
-					chainon (yyvsp[0].ttype, all_prefix_attributes)); ;}
+    { (yyval.ttype) = build_tree_list (build_tree_list (current_declspecs,
+							 (yyvsp[(1) - (2)].ttype)),
+					chainon ((yyvsp[(2) - (2)].ttype), all_prefix_attributes)); }
     break;
 
   case 409:
+
+/* Line 1806 of yacc.c  */
 #line 1863 "c-parse.y"
-    { yyval.ttype = make_pointer_declarator (yyvsp[-1].ttype, yyvsp[0].ttype); ;}
+    { (yyval.ttype) = make_pointer_declarator ((yyvsp[(2) - (3)].ttype), (yyvsp[(3) - (3)].ttype)); }
     break;
 
   case 410:
+
+/* Line 1806 of yacc.c  */
 #line 1868 "c-parse.y"
-    { yyval.ttype = make_pointer_declarator (yyvsp[0].ttype, NULL_TREE); ;}
+    { (yyval.ttype) = make_pointer_declarator ((yyvsp[(2) - (2)].ttype), NULL_TREE); }
     break;
 
   case 411:
+
+/* Line 1806 of yacc.c  */
 #line 1870 "c-parse.y"
-    { yyval.ttype = make_pointer_declarator (yyvsp[-1].ttype, yyvsp[0].ttype); ;}
+    { (yyval.ttype) = make_pointer_declarator ((yyvsp[(2) - (3)].ttype), (yyvsp[(3) - (3)].ttype)); }
     break;
 
   case 412:
+
+/* Line 1806 of yacc.c  */
 #line 1875 "c-parse.y"
-    { yyval.ttype = yyvsp[-2].ttype ? tree_cons (yyvsp[-2].ttype, yyvsp[-1].ttype, NULL_TREE) : yyvsp[-1].ttype; ;}
+    { (yyval.ttype) = (yyvsp[(2) - (4)].ttype) ? tree_cons ((yyvsp[(2) - (4)].ttype), (yyvsp[(3) - (4)].ttype), NULL_TREE) : (yyvsp[(3) - (4)].ttype); }
     break;
 
   case 413:
+
+/* Line 1806 of yacc.c  */
 #line 1877 "c-parse.y"
-    { yyval.ttype = build_nt (CALL_EXPR, yyvsp[-2].ttype, yyvsp[0].ttype, NULL_TREE); ;}
+    { (yyval.ttype) = build_nt (CALL_EXPR, (yyvsp[(1) - (3)].ttype), (yyvsp[(3) - (3)].ttype), NULL_TREE); }
     break;
 
   case 414:
+
+/* Line 1806 of yacc.c  */
 #line 1879 "c-parse.y"
-    { yyval.ttype = set_array_declarator_type (yyvsp[0].ttype, yyvsp[-1].ttype, 1); ;}
+    { (yyval.ttype) = set_array_declarator_type ((yyvsp[(2) - (2)].ttype), (yyvsp[(1) - (2)].ttype), 1); }
     break;
 
   case 415:
+
+/* Line 1806 of yacc.c  */
 #line 1881 "c-parse.y"
-    { yyval.ttype = build_nt (CALL_EXPR, NULL_TREE, yyvsp[0].ttype, NULL_TREE); ;}
+    { (yyval.ttype) = build_nt (CALL_EXPR, NULL_TREE, (yyvsp[(2) - (2)].ttype), NULL_TREE); }
     break;
 
   case 416:
+
+/* Line 1806 of yacc.c  */
 #line 1883 "c-parse.y"
-    { yyval.ttype = set_array_declarator_type (yyvsp[0].ttype, NULL_TREE, 1); ;}
+    { (yyval.ttype) = set_array_declarator_type ((yyvsp[(1) - (1)].ttype), NULL_TREE, 1); }
     break;
 
   case 417:
+
+/* Line 1806 of yacc.c  */
 #line 1890 "c-parse.y"
-    { yyval.ttype = build_array_declarator (yyvsp[-1].ttype, yyvsp[-2].ttype, 0, 0); ;}
+    { (yyval.ttype) = build_array_declarator ((yyvsp[(3) - (4)].ttype), (yyvsp[(2) - (4)].ttype), 0, 0); }
     break;
 
   case 418:
+
+/* Line 1806 of yacc.c  */
 #line 1892 "c-parse.y"
-    { yyval.ttype = build_array_declarator (NULL_TREE, yyvsp[-1].ttype, 0, 0); ;}
+    { (yyval.ttype) = build_array_declarator (NULL_TREE, (yyvsp[(2) - (3)].ttype), 0, 0); }
     break;
 
   case 419:
+
+/* Line 1806 of yacc.c  */
 #line 1894 "c-parse.y"
-    { yyval.ttype = build_array_declarator (NULL_TREE, yyvsp[-2].ttype, 0, 1); ;}
+    { (yyval.ttype) = build_array_declarator (NULL_TREE, (yyvsp[(2) - (4)].ttype), 0, 1); }
     break;
 
   case 420:
+
+/* Line 1806 of yacc.c  */
 #line 1896 "c-parse.y"
-    { yyval.ttype = build_array_declarator (yyvsp[-1].ttype, yyvsp[-2].ttype, 1, 0); ;}
+    { (yyval.ttype) = build_array_declarator ((yyvsp[(4) - (5)].ttype), (yyvsp[(3) - (5)].ttype), 1, 0); }
     break;
 
   case 421:
+
+/* Line 1806 of yacc.c  */
 #line 1899 "c-parse.y"
-    { yyval.ttype = build_array_declarator (yyvsp[-1].ttype, yyvsp[-3].ttype, 1, 0); ;}
+    { (yyval.ttype) = build_array_declarator ((yyvsp[(4) - (5)].ttype), (yyvsp[(2) - (5)].ttype), 1, 0); }
     break;
 
   case 424:
+
+/* Line 1806 of yacc.c  */
 #line 1912 "c-parse.y"
     {
 		  pedwarn ("deprecated use of label at end of compound statement");
-		;}
+		}
     break;
 
   case 432:
+
+/* Line 1806 of yacc.c  */
 #line 1929 "c-parse.y"
     { if (pedantic && !flag_isoc99)
-		    pedwarn ("ISO C89 forbids mixed declarations and code"); ;}
+		    pedwarn ("ISO C89 forbids mixed declarations and code"); }
     break;
 
   case 447:
+
+/* Line 1806 of yacc.c  */
 #line 1959 "c-parse.y"
     { pushlevel (0);
 		  clear_last_expr ();
 		  add_scope_stmt (/*begin_p=*/1, /*partial_p=*/0);
-		;}
+		}
     break;
 
   case 448:
+
+/* Line 1806 of yacc.c  */
 #line 1966 "c-parse.y"
-    { yyval.ttype = add_scope_stmt (/*begin_p=*/0, /*partial_p=*/0); ;}
+    { (yyval.ttype) = add_scope_stmt (/*begin_p=*/0, /*partial_p=*/0); }
     break;
 
   case 449:
+
+/* Line 1806 of yacc.c  */
 #line 1971 "c-parse.y"
     { if (flag_isoc99)
 		    {
-		      yyval.ttype = c_begin_compound_stmt ();
+		      (yyval.ttype) = c_begin_compound_stmt ();
 		      pushlevel (0);
 		      clear_last_expr ();
 		      add_scope_stmt (/*begin_p=*/1, /*partial_p=*/0);
 		    }
 		  else
-		    yyval.ttype = NULL_TREE;
-		;}
+		    (yyval.ttype) = NULL_TREE;
+		}
     break;
 
   case 450:
+
+/* Line 1806 of yacc.c  */
 #line 1987 "c-parse.y"
     { if (flag_isoc99)
 		    {
 		      tree scope_stmt = add_scope_stmt (/*begin_p=*/0, /*partial_p=*/0);
-		      yyval.ttype = poplevel (kept_level_p (), 0, 0);
+		      (yyval.ttype) = poplevel (kept_level_p (), 0, 0);
 		      SCOPE_STMT_BLOCK (TREE_PURPOSE (scope_stmt))
 			= SCOPE_STMT_BLOCK (TREE_VALUE (scope_stmt))
-			= yyval.ttype;
+			= (yyval.ttype);
 		    }
 		  else
-		    yyval.ttype = NULL_TREE; ;}
+		    (yyval.ttype) = NULL_TREE; }
     break;
 
   case 452:
+
+/* Line 1806 of yacc.c  */
 #line 2004 "c-parse.y"
     { if (pedantic)
-		    pedwarn ("ISO C forbids label declarations"); ;}
+		    pedwarn ("ISO C forbids label declarations"); }
     break;
 
   case 455:
+
+/* Line 1806 of yacc.c  */
 #line 2015 "c-parse.y"
     { tree link;
-		  for (link = yyvsp[-1].ttype; link; link = TREE_CHAIN (link))
+		  for (link = (yyvsp[(2) - (3)].ttype); link; link = TREE_CHAIN (link))
 		    {
 		      tree label = shadow_label (TREE_VALUE (link));
 		      C_DECLARED_LABEL_FLAG (label) = 1;
 		      add_decl_stmt (label);
 		    }
-		;}
+		}
     break;
 
   case 456:
+
+/* Line 1806 of yacc.c  */
 #line 2029 "c-parse.y"
-    {;}
+    {}
     break;
 
   case 458:
+
+/* Line 1806 of yacc.c  */
 #line 2033 "c-parse.y"
     { compstmt_count++;
-                      yyval.ttype = c_begin_compound_stmt (); ;}
+                      (yyval.ttype) = c_begin_compound_stmt (); }
     break;
 
   case 459:
+
+/* Line 1806 of yacc.c  */
 #line 2038 "c-parse.y"
-    { yyval.ttype = convert (void_type_node, integer_zero_node); ;}
+    { (yyval.ttype) = convert (void_type_node, integer_zero_node); }
     break;
 
   case 460:
+
+/* Line 1806 of yacc.c  */
 #line 2040 "c-parse.y"
-    { yyval.ttype = poplevel (kept_level_p (), 1, 0);
-		  SCOPE_STMT_BLOCK (TREE_PURPOSE (yyvsp[0].ttype))
-		    = SCOPE_STMT_BLOCK (TREE_VALUE (yyvsp[0].ttype))
-		    = yyval.ttype; ;}
+    { (yyval.ttype) = poplevel (kept_level_p (), 1, 0);
+		  SCOPE_STMT_BLOCK (TREE_PURPOSE ((yyvsp[(5) - (5)].ttype)))
+		    = SCOPE_STMT_BLOCK (TREE_VALUE ((yyvsp[(5) - (5)].ttype)))
+		    = (yyval.ttype); }
     break;
 
   case 463:
+
+/* Line 1806 of yacc.c  */
 #line 2053 "c-parse.y"
     { if (current_function_decl == 0)
 		    {
@@ -4649,401 +5605,519 @@
 		  keep_next_level ();
 		  push_label_level ();
 		  compstmt_count++;
-		  yyval.ttype = add_stmt (build_stmt (COMPOUND_STMT, last_tree));
+		  (yyval.ttype) = add_stmt (build_stmt (COMPOUND_STMT, last_tree));
 		  last_expr_type = NULL_TREE;
-		;}
+		}
     break;
 
   case 464:
+
+/* Line 1806 of yacc.c  */
 #line 2071 "c-parse.y"
-    { RECHAIN_STMTS (yyvsp[-1].ttype, COMPOUND_BODY (yyvsp[-1].ttype));
+    { RECHAIN_STMTS ((yyvsp[(1) - (2)].ttype), COMPOUND_BODY ((yyvsp[(1) - (2)].ttype)));
 		  last_expr_type = NULL_TREE;
-                  yyval.ttype = yyvsp[-1].ttype; ;}
+                  (yyval.ttype) = (yyvsp[(1) - (2)].ttype); }
     break;
 
   case 465:
+
+/* Line 1806 of yacc.c  */
 #line 2079 "c-parse.y"
-    { c_finish_then (); ;}
+    { c_finish_then (); }
     break;
 
   case 467:
+
+/* Line 1806 of yacc.c  */
 #line 2096 "c-parse.y"
-    { yyval.ttype = c_begin_if_stmt (); ;}
+    { (yyval.ttype) = c_begin_if_stmt (); }
     break;
 
   case 468:
+
+/* Line 1806 of yacc.c  */
 #line 2098 "c-parse.y"
-    { c_expand_start_cond (c_common_truthvalue_conversion (yyvsp[-1].ttype),
-				       compstmt_count,yyvsp[-3].ttype);
-		  yyval.itype = stmt_count;
-		  if_stmt_file = yyvsp[-7].filename;
-		  if_stmt_line = yyvsp[-6].lineno; ;}
+    { c_expand_start_cond (c_common_truthvalue_conversion ((yyvsp[(4) - (5)].ttype)),
+				       compstmt_count,(yyvsp[(2) - (5)].ttype));
+		  (yyval.itype) = stmt_count;
+		  if_stmt_file = (yyvsp[(-2) - (5)].filename);
+		  if_stmt_line = (yyvsp[(-1) - (5)].lineno); }
     break;
 
   case 469:
+
+/* Line 1806 of yacc.c  */
 #line 2110 "c-parse.y"
     { stmt_count++;
 		  compstmt_count++;
-		  yyval.ttype
+		  (yyval.ttype)
 		    = add_stmt (build_stmt (DO_STMT, NULL_TREE,
 					    NULL_TREE));
 		  /* In the event that a parse error prevents
 		     parsing the complete do-statement, set the
 		     condition now.  Otherwise, we can get crashes at
 		     RTL-generation time.  */
-		  DO_COND (yyval.ttype) = error_mark_node; ;}
+		  DO_COND ((yyval.ttype)) = error_mark_node; }
     break;
 
   case 470:
+
+/* Line 1806 of yacc.c  */
 #line 2121 "c-parse.y"
-    { yyval.ttype = yyvsp[-2].ttype;
-		  RECHAIN_STMTS (yyval.ttype, DO_BODY (yyval.ttype)); ;}
+    { (yyval.ttype) = (yyvsp[(2) - (4)].ttype);
+		  RECHAIN_STMTS ((yyval.ttype), DO_BODY ((yyval.ttype))); }
     break;
 
   case 471:
+
+/* Line 1806 of yacc.c  */
 #line 2129 "c-parse.y"
     { if (yychar == YYEMPTY)
 		    yychar = YYLEX;
-		  yyval.filename = input_filename; ;}
+		  (yyval.filename) = input_filename; }
     break;
 
   case 472:
+
+/* Line 1806 of yacc.c  */
 #line 2135 "c-parse.y"
     { if (yychar == YYEMPTY)
 		    yychar = YYLEX;
-		  yyval.lineno = lineno; ;}
+		  (yyval.lineno) = lineno; }
     break;
 
   case 475:
+
+/* Line 1806 of yacc.c  */
 #line 2148 "c-parse.y"
     { if (flag_isoc99)
-		    RECHAIN_STMTS (yyvsp[-2].ttype, COMPOUND_BODY (yyvsp[-2].ttype)); ;}
+		    RECHAIN_STMTS ((yyvsp[(1) - (3)].ttype), COMPOUND_BODY ((yyvsp[(1) - (3)].ttype))); }
     break;
 
   case 476:
+
+/* Line 1806 of yacc.c  */
 #line 2154 "c-parse.y"
-    { if (yyvsp[0].ttype)
+    { if ((yyvsp[(3) - (3)].ttype))
 		    {
-		      STMT_LINENO (yyvsp[0].ttype) = yyvsp[-1].lineno;
+		      STMT_LINENO ((yyvsp[(3) - (3)].ttype)) = (yyvsp[(2) - (3)].lineno);
 		      /* ??? We currently have no way of recording
 			 the filename for a statement.  This probably
 			 matters little in practice at the moment,
 			 but I suspect that problems will occur when
 			 doing inlining at the tree level.  */
 		    }
-		;}
+		}
     break;
 
   case 477:
+
+/* Line 1806 of yacc.c  */
 #line 2168 "c-parse.y"
-    { if (yyvsp[0].ttype)
+    { if ((yyvsp[(3) - (3)].ttype))
 		    {
-		      STMT_LINENO (yyvsp[0].ttype) = yyvsp[-1].lineno;
+		      STMT_LINENO ((yyvsp[(3) - (3)].ttype)) = (yyvsp[(2) - (3)].lineno);
 		    }
-		;}
+		}
     break;
 
   case 478:
+
+/* Line 1806 of yacc.c  */
 #line 2177 "c-parse.y"
     { c_expand_start_else ();
-		  yyvsp[-1].itype = stmt_count; ;}
+		  (yyvsp[(1) - (2)].itype) = stmt_count; }
     break;
 
   case 479:
+
+/* Line 1806 of yacc.c  */
 #line 2180 "c-parse.y"
     { c_finish_else ();
 		  c_expand_end_cond ();
-		  if (extra_warnings && stmt_count == yyvsp[-3].itype)
-		    warning ("empty body in an else-statement"); ;}
+		  if (extra_warnings && stmt_count == (yyvsp[(1) - (4)].itype))
+		    warning ("empty body in an else-statement"); }
     break;
 
   case 480:
+
+/* Line 1806 of yacc.c  */
 #line 2185 "c-parse.y"
     { c_expand_end_cond ();
 		  /* This warning is here instead of in simple_if, because we
 		     do not want a warning if an empty if is followed by an
 		     else statement.  Increment stmt_count so we don't
 		     give a second error if this is a nested `if'.  */
-		  if (extra_warnings && stmt_count++ == yyvsp[0].itype)
+		  if (extra_warnings && stmt_count++ == (yyvsp[(1) - (1)].itype))
 		    warning_with_file_and_line (if_stmt_file, if_stmt_line,
-						"empty body in an if-statement"); ;}
+						"empty body in an if-statement"); }
     break;
 
   case 481:
+
+/* Line 1806 of yacc.c  */
 #line 2197 "c-parse.y"
-    { c_expand_end_cond (); ;}
+    { c_expand_end_cond (); }
     break;
 
   case 482:
+
+/* Line 1806 of yacc.c  */
 #line 2207 "c-parse.y"
     { stmt_count++;
-		  yyval.ttype = c_begin_while_stmt (); ;}
+		  (yyval.ttype) = c_begin_while_stmt (); }
     break;
 
   case 483:
+
+/* Line 1806 of yacc.c  */
 #line 2210 "c-parse.y"
-    { yyvsp[-1].ttype = c_common_truthvalue_conversion (yyvsp[-1].ttype);
+    { (yyvsp[(4) - (5)].ttype) = c_common_truthvalue_conversion ((yyvsp[(4) - (5)].ttype));
 		  c_finish_while_stmt_cond
-		    (c_common_truthvalue_conversion (yyvsp[-1].ttype), yyvsp[-3].ttype);
-		  yyval.ttype = add_stmt (yyvsp[-3].ttype); ;}
+		    (c_common_truthvalue_conversion ((yyvsp[(4) - (5)].ttype)), (yyvsp[(2) - (5)].ttype));
+		  (yyval.ttype) = add_stmt ((yyvsp[(2) - (5)].ttype)); }
     break;
 
   case 484:
+
+/* Line 1806 of yacc.c  */
 #line 2215 "c-parse.y"
-    { RECHAIN_STMTS (yyvsp[-1].ttype, WHILE_BODY (yyvsp[-1].ttype)); ;}
+    { RECHAIN_STMTS ((yyvsp[(6) - (7)].ttype), WHILE_BODY ((yyvsp[(6) - (7)].ttype))); }
     break;
 
   case 485:
+
+/* Line 1806 of yacc.c  */
 #line 2218 "c-parse.y"
-    { DO_COND (yyvsp[-4].ttype) = c_common_truthvalue_conversion (yyvsp[-2].ttype); ;}
+    { DO_COND ((yyvsp[(1) - (5)].ttype)) = c_common_truthvalue_conversion ((yyvsp[(3) - (5)].ttype)); }
     break;
 
   case 486:
+
+/* Line 1806 of yacc.c  */
 #line 2220 "c-parse.y"
-    { ;}
+    { }
     break;
 
   case 487:
+
+/* Line 1806 of yacc.c  */
 #line 2222 "c-parse.y"
-    { yyval.ttype = build_stmt (FOR_STMT, NULL_TREE, NULL_TREE,
+    { (yyval.ttype) = build_stmt (FOR_STMT, NULL_TREE, NULL_TREE,
 					  NULL_TREE, NULL_TREE);
-		  add_stmt (yyval.ttype); ;}
+		  add_stmt ((yyval.ttype)); }
     break;
 
   case 488:
+
+/* Line 1806 of yacc.c  */
 #line 2226 "c-parse.y"
     { stmt_count++;
-		  RECHAIN_STMTS (yyvsp[-2].ttype, FOR_INIT_STMT (yyvsp[-2].ttype)); ;}
+		  RECHAIN_STMTS ((yyvsp[(2) - (4)].ttype), FOR_INIT_STMT ((yyvsp[(2) - (4)].ttype))); }
     break;
 
   case 489:
+
+/* Line 1806 of yacc.c  */
 #line 2229 "c-parse.y"
-    { if (yyvsp[-1].ttype)
-		    FOR_COND (yyvsp[-5].ttype)
-		      = c_common_truthvalue_conversion (yyvsp[-1].ttype); ;}
+    { if ((yyvsp[(6) - (7)].ttype))
+		    FOR_COND ((yyvsp[(2) - (7)].ttype))
+		      = c_common_truthvalue_conversion ((yyvsp[(6) - (7)].ttype)); }
     break;
 
   case 490:
+
+/* Line 1806 of yacc.c  */
 #line 2233 "c-parse.y"
-    { FOR_EXPR (yyvsp[-8].ttype) = yyvsp[-1].ttype; ;}
+    { FOR_EXPR ((yyvsp[(2) - (10)].ttype)) = (yyvsp[(9) - (10)].ttype); }
     break;
 
   case 491:
+
+/* Line 1806 of yacc.c  */
 #line 2235 "c-parse.y"
-    { RECHAIN_STMTS (yyvsp[-10].ttype, FOR_BODY (yyvsp[-10].ttype)); ;}
+    { RECHAIN_STMTS ((yyvsp[(2) - (12)].ttype), FOR_BODY ((yyvsp[(2) - (12)].ttype))); }
     break;
 
   case 492:
+
+/* Line 1806 of yacc.c  */
 #line 2237 "c-parse.y"
     { stmt_count++;
-		  yyval.ttype = c_start_case (yyvsp[-1].ttype); ;}
+		  (yyval.ttype) = c_start_case ((yyvsp[(3) - (4)].ttype)); }
     break;
 
   case 493:
+
+/* Line 1806 of yacc.c  */
 #line 2240 "c-parse.y"
-    { c_finish_case (); ;}
+    { c_finish_case (); }
     break;
 
   case 494:
+
+/* Line 1806 of yacc.c  */
 #line 2245 "c-parse.y"
-    { add_stmt (build_stmt (EXPR_STMT, yyvsp[-1].ttype)); ;}
+    { add_stmt (build_stmt (EXPR_STMT, (yyvsp[(1) - (2)].ttype))); }
     break;
 
   case 495:
+
+/* Line 1806 of yacc.c  */
 #line 2247 "c-parse.y"
-    { check_for_loop_decls (); ;}
+    { check_for_loop_decls (); }
     break;
 
   case 496:
+
+/* Line 1806 of yacc.c  */
 #line 2253 "c-parse.y"
-    { stmt_count++; yyval.ttype = yyvsp[0].ttype; ;}
+    { stmt_count++; (yyval.ttype) = (yyvsp[(1) - (1)].ttype); }
     break;
 
   case 497:
+
+/* Line 1806 of yacc.c  */
 #line 2255 "c-parse.y"
     { stmt_count++;
-		  yyval.ttype = c_expand_expr_stmt (yyvsp[-1].ttype); ;}
+		  (yyval.ttype) = c_expand_expr_stmt ((yyvsp[(1) - (2)].ttype)); }
     break;
 
   case 498:
+
+/* Line 1806 of yacc.c  */
 #line 2258 "c-parse.y"
     { if (flag_isoc99)
-		    RECHAIN_STMTS (yyvsp[-2].ttype, COMPOUND_BODY (yyvsp[-2].ttype));
-		  yyval.ttype = NULL_TREE; ;}
+		    RECHAIN_STMTS ((yyvsp[(1) - (3)].ttype), COMPOUND_BODY ((yyvsp[(1) - (3)].ttype)));
+		  (yyval.ttype) = NULL_TREE; }
     break;
 
   case 499:
+
+/* Line 1806 of yacc.c  */
 #line 2262 "c-parse.y"
     { stmt_count++;
-		  yyval.ttype = add_stmt (build_break_stmt ()); ;}
+		  (yyval.ttype) = add_stmt (build_break_stmt ()); }
     break;
 
   case 500:
+
+/* Line 1806 of yacc.c  */
 #line 2265 "c-parse.y"
     { stmt_count++;
-		  yyval.ttype = add_stmt (build_continue_stmt ()); ;}
+		  (yyval.ttype) = add_stmt (build_continue_stmt ()); }
     break;
 
   case 501:
+
+/* Line 1806 of yacc.c  */
 #line 2268 "c-parse.y"
     { stmt_count++;
-		  yyval.ttype = c_expand_return (NULL_TREE); ;}
+		  (yyval.ttype) = c_expand_return (NULL_TREE); }
     break;
 
   case 502:
+
+/* Line 1806 of yacc.c  */
 #line 2271 "c-parse.y"
     { stmt_count++;
-		  yyval.ttype = c_expand_return (yyvsp[-1].ttype); ;}
+		  (yyval.ttype) = c_expand_return ((yyvsp[(2) - (3)].ttype)); }
     break;
 
   case 503:
+
+/* Line 1806 of yacc.c  */
 #line 2274 "c-parse.y"
     { stmt_count++;
-		  yyval.ttype = simple_asm_stmt (yyvsp[-2].ttype); ;}
+		  (yyval.ttype) = simple_asm_stmt ((yyvsp[(4) - (6)].ttype)); }
     break;
 
   case 504:
+
+/* Line 1806 of yacc.c  */
 #line 2278 "c-parse.y"
     { stmt_count++;
-		  yyval.ttype = build_asm_stmt (yyvsp[-6].ttype, yyvsp[-4].ttype, yyvsp[-2].ttype, NULL_TREE, NULL_TREE); ;}
+		  (yyval.ttype) = build_asm_stmt ((yyvsp[(2) - (8)].ttype), (yyvsp[(4) - (8)].ttype), (yyvsp[(6) - (8)].ttype), NULL_TREE, NULL_TREE); }
     break;
 
   case 505:
+
+/* Line 1806 of yacc.c  */
 #line 2283 "c-parse.y"
     { stmt_count++;
-		  yyval.ttype = build_asm_stmt (yyvsp[-8].ttype, yyvsp[-6].ttype, yyvsp[-4].ttype, yyvsp[-2].ttype, NULL_TREE); ;}
+		  (yyval.ttype) = build_asm_stmt ((yyvsp[(2) - (10)].ttype), (yyvsp[(4) - (10)].ttype), (yyvsp[(6) - (10)].ttype), (yyvsp[(8) - (10)].ttype), NULL_TREE); }
     break;
 
   case 506:
+
+/* Line 1806 of yacc.c  */
 #line 2288 "c-parse.y"
     { stmt_count++;
-		  yyval.ttype = build_asm_stmt (yyvsp[-10].ttype, yyvsp[-8].ttype, yyvsp[-6].ttype, yyvsp[-4].ttype, yyvsp[-2].ttype); ;}
+		  (yyval.ttype) = build_asm_stmt ((yyvsp[(2) - (12)].ttype), (yyvsp[(4) - (12)].ttype), (yyvsp[(6) - (12)].ttype), (yyvsp[(8) - (12)].ttype), (yyvsp[(10) - (12)].ttype)); }
     break;
 
   case 507:
+
+/* Line 1806 of yacc.c  */
 #line 2291 "c-parse.y"
     { tree decl;
 		  stmt_count++;
-		  decl = lookup_label (yyvsp[-1].ttype);
+		  decl = lookup_label ((yyvsp[(2) - (3)].ttype));
 		  if (decl != 0)
 		    {
 		      TREE_USED (decl) = 1;
-		      yyval.ttype = add_stmt (build_stmt (GOTO_STMT, decl));
+		      (yyval.ttype) = add_stmt (build_stmt (GOTO_STMT, decl));
 		    }
 		  else
-		    yyval.ttype = NULL_TREE;
-		;}
+		    (yyval.ttype) = NULL_TREE;
+		}
     break;
 
   case 508:
+
+/* Line 1806 of yacc.c  */
 #line 2303 "c-parse.y"
     { if (pedantic)
 		    pedwarn ("ISO C forbids `goto *expr;'");
 		  stmt_count++;
-		  yyvsp[-1].ttype = convert (ptr_type_node, yyvsp[-1].ttype);
-		  yyval.ttype = add_stmt (build_stmt (GOTO_STMT, yyvsp[-1].ttype)); ;}
+		  (yyvsp[(3) - (4)].ttype) = convert (ptr_type_node, (yyvsp[(3) - (4)].ttype));
+		  (yyval.ttype) = add_stmt (build_stmt (GOTO_STMT, (yyvsp[(3) - (4)].ttype))); }
     break;
 
   case 509:
+
+/* Line 1806 of yacc.c  */
 #line 2309 "c-parse.y"
-    { yyval.ttype = NULL_TREE; ;}
+    { (yyval.ttype) = NULL_TREE; }
     break;
 
   case 510:
+
+/* Line 1806 of yacc.c  */
 #line 2317 "c-parse.y"
     { stmt_count++;
-		  yyval.ttype = do_case (yyvsp[-1].ttype, NULL_TREE); ;}
+		  (yyval.ttype) = do_case ((yyvsp[(2) - (3)].ttype), NULL_TREE); }
     break;
 
   case 511:
+
+/* Line 1806 of yacc.c  */
 #line 2320 "c-parse.y"
     { stmt_count++;
-		  yyval.ttype = do_case (yyvsp[-3].ttype, yyvsp[-1].ttype); ;}
+		  (yyval.ttype) = do_case ((yyvsp[(2) - (5)].ttype), (yyvsp[(4) - (5)].ttype)); }
     break;
 
   case 512:
+
+/* Line 1806 of yacc.c  */
 #line 2323 "c-parse.y"
     { stmt_count++;
-		  yyval.ttype = do_case (NULL_TREE, NULL_TREE); ;}
+		  (yyval.ttype) = do_case (NULL_TREE, NULL_TREE); }
     break;
 
   case 513:
+
+/* Line 1806 of yacc.c  */
 #line 2326 "c-parse.y"
-    { tree label = define_label (yyvsp[-3].filename, yyvsp[-2].lineno, yyvsp[-4].ttype);
+    { tree label = define_label ((yyvsp[(2) - (5)].filename), (yyvsp[(3) - (5)].lineno), (yyvsp[(1) - (5)].ttype));
 		  stmt_count++;
 		  if (label)
 		    {
-		      decl_attributes (&label, yyvsp[0].ttype, 0);
-		      yyval.ttype = add_stmt (build_stmt (LABEL_STMT, label));
+		      decl_attributes (&label, (yyvsp[(5) - (5)].ttype), 0);
+		      (yyval.ttype) = add_stmt (build_stmt (LABEL_STMT, label));
 		    }
 		  else
-		    yyval.ttype = NULL_TREE;
-		;}
+		    (yyval.ttype) = NULL_TREE;
+		}
     break;
 
   case 514:
+
+/* Line 1806 of yacc.c  */
 #line 2342 "c-parse.y"
     { emit_line_note (input_filename, lineno);
-		  yyval.ttype = NULL_TREE; ;}
+		  (yyval.ttype) = NULL_TREE; }
     break;
 
   case 515:
+
+/* Line 1806 of yacc.c  */
 #line 2345 "c-parse.y"
-    { emit_line_note (input_filename, lineno); ;}
+    { emit_line_note (input_filename, lineno); }
     break;
 
   case 516:
+
+/* Line 1806 of yacc.c  */
 #line 2350 "c-parse.y"
-    { yyval.ttype = NULL_TREE; ;}
+    { (yyval.ttype) = NULL_TREE; }
     break;
 
   case 518:
+
+/* Line 1806 of yacc.c  */
 #line 2357 "c-parse.y"
-    { yyval.ttype = NULL_TREE; ;}
+    { (yyval.ttype) = NULL_TREE; }
     break;
 
   case 521:
+
+/* Line 1806 of yacc.c  */
 #line 2364 "c-parse.y"
-    { yyval.ttype = chainon (yyvsp[-2].ttype, yyvsp[0].ttype); ;}
+    { (yyval.ttype) = chainon ((yyvsp[(1) - (3)].ttype), (yyvsp[(3) - (3)].ttype)); }
     break;
 
   case 522:
+
+/* Line 1806 of yacc.c  */
 #line 2369 "c-parse.y"
-    { yyval.ttype = build_tree_list (build_tree_list (NULL_TREE, yyvsp[-3].ttype), yyvsp[-1].ttype); ;}
+    { (yyval.ttype) = build_tree_list (build_tree_list (NULL_TREE, (yyvsp[(1) - (4)].ttype)), (yyvsp[(3) - (4)].ttype)); }
     break;
 
   case 523:
+
+/* Line 1806 of yacc.c  */
 #line 2371 "c-parse.y"
-    { yyvsp[-5].ttype = build_string (IDENTIFIER_LENGTH (yyvsp[-5].ttype),
-				     IDENTIFIER_POINTER (yyvsp[-5].ttype));
-		  yyval.ttype = build_tree_list (build_tree_list (yyvsp[-5].ttype, yyvsp[-3].ttype), yyvsp[-1].ttype); ;}
+    { (yyvsp[(2) - (7)].ttype) = build_string (IDENTIFIER_LENGTH ((yyvsp[(2) - (7)].ttype)),
+				     IDENTIFIER_POINTER ((yyvsp[(2) - (7)].ttype)));
+		  (yyval.ttype) = build_tree_list (build_tree_list ((yyvsp[(2) - (7)].ttype), (yyvsp[(4) - (7)].ttype)), (yyvsp[(6) - (7)].ttype)); }
     break;
 
   case 524:
+
+/* Line 1806 of yacc.c  */
 #line 2378 "c-parse.y"
-    { yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, NULL_TREE); ;}
+    { (yyval.ttype) = tree_cons (NULL_TREE, (yyvsp[(1) - (1)].ttype), NULL_TREE); }
     break;
 
   case 525:
+
+/* Line 1806 of yacc.c  */
 #line 2380 "c-parse.y"
-    { yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyvsp[-2].ttype); ;}
+    { (yyval.ttype) = tree_cons (NULL_TREE, (yyvsp[(3) - (3)].ttype), (yyvsp[(1) - (3)].ttype)); }
     break;
 
   case 526:
+
+/* Line 1806 of yacc.c  */
 #line 2390 "c-parse.y"
     { pushlevel (0);
 		  clear_parm_order ();
-		  declare_parm_level (0); ;}
+		  declare_parm_level (0); }
     break;
 
   case 527:
+
+/* Line 1806 of yacc.c  */
 #line 2394 "c-parse.y"
-    { yyval.ttype = yyvsp[0].ttype;
+    { (yyval.ttype) = (yyvsp[(3) - (3)].ttype);
 		  parmlist_tags_warning ();
-		  poplevel (0, 0, 0); ;}
+		  poplevel (0, 0, 0); }
     break;
 
   case 529:
+
+/* Line 1806 of yacc.c  */
 #line 2402 "c-parse.y"
     { tree parm;
 		  if (pedantic)
@@ -5051,33 +6125,43 @@
 		  /* Mark the forward decls as such.  */
 		  for (parm = getdecls (); parm; parm = TREE_CHAIN (parm))
 		    TREE_ASM_WRITTEN (parm) = 1;
-		  clear_parm_order (); ;}
+		  clear_parm_order (); }
     break;
 
   case 530:
+
+/* Line 1806 of yacc.c  */
 #line 2410 "c-parse.y"
     { /* Dummy action so attributes are in known place
-		     on parser stack.  */ ;}
+		     on parser stack.  */ }
     break;
 
   case 531:
+
+/* Line 1806 of yacc.c  */
 #line 2413 "c-parse.y"
-    { yyval.ttype = yyvsp[0].ttype; ;}
+    { (yyval.ttype) = (yyvsp[(6) - (6)].ttype); }
     break;
 
   case 532:
+
+/* Line 1806 of yacc.c  */
 #line 2415 "c-parse.y"
-    { yyval.ttype = tree_cons (NULL_TREE, NULL_TREE, NULL_TREE); ;}
+    { (yyval.ttype) = tree_cons (NULL_TREE, NULL_TREE, NULL_TREE); }
     break;
 
   case 533:
+
+/* Line 1806 of yacc.c  */
 #line 2421 "c-parse.y"
-    { yyval.ttype = get_parm_info (0); ;}
+    { (yyval.ttype) = get_parm_info (0); }
     break;
 
   case 534:
+
+/* Line 1806 of yacc.c  */
 #line 2423 "c-parse.y"
-    { yyval.ttype = get_parm_info (0);
+    { (yyval.ttype) = get_parm_info (0);
 		  /* Gcc used to allow this as an extension.  However, it does
 		     not work for all targets, and thus has been disabled.
 		     Also, since func (...) and func () are indistinguishable,
@@ -5085,184 +6169,240 @@
 		     tries to verify that BUILT_IN_NEXT_ARG is being used
 		     correctly.  */
 		  error ("ISO C requires a named argument before `...'");
-		;}
+		}
     break;
 
   case 535:
+
+/* Line 1806 of yacc.c  */
 #line 2433 "c-parse.y"
-    { yyval.ttype = get_parm_info (1);
+    { (yyval.ttype) = get_parm_info (1);
 		  parsing_iso_function_signature = true;
-		;}
+		}
     break;
 
   case 536:
+
+/* Line 1806 of yacc.c  */
 #line 2437 "c-parse.y"
-    { yyval.ttype = get_parm_info (0); ;}
+    { (yyval.ttype) = get_parm_info (0); }
     break;
 
   case 537:
+
+/* Line 1806 of yacc.c  */
 #line 2442 "c-parse.y"
-    { push_parm_decl (yyvsp[0].ttype); ;}
+    { push_parm_decl ((yyvsp[(1) - (1)].ttype)); }
     break;
 
   case 538:
+
+/* Line 1806 of yacc.c  */
 #line 2444 "c-parse.y"
-    { push_parm_decl (yyvsp[0].ttype); ;}
+    { push_parm_decl ((yyvsp[(3) - (3)].ttype)); }
     break;
 
   case 539:
+
+/* Line 1806 of yacc.c  */
 #line 2451 "c-parse.y"
-    { yyval.ttype = build_tree_list (build_tree_list (current_declspecs,
-							 yyvsp[-1].ttype),
-					chainon (yyvsp[0].ttype, all_prefix_attributes));
-		  POP_DECLSPEC_STACK; ;}
+    { (yyval.ttype) = build_tree_list (build_tree_list (current_declspecs,
+							 (yyvsp[(3) - (4)].ttype)),
+					chainon ((yyvsp[(4) - (4)].ttype), all_prefix_attributes));
+		  POP_DECLSPEC_STACK; }
     break;
 
   case 540:
+
+/* Line 1806 of yacc.c  */
 #line 2456 "c-parse.y"
-    { yyval.ttype = build_tree_list (build_tree_list (current_declspecs,
-							 yyvsp[-1].ttype),
-					chainon (yyvsp[0].ttype, all_prefix_attributes));
-		  POP_DECLSPEC_STACK; ;}
+    { (yyval.ttype) = build_tree_list (build_tree_list (current_declspecs,
+							 (yyvsp[(3) - (4)].ttype)),
+					chainon ((yyvsp[(4) - (4)].ttype), all_prefix_attributes));
+		  POP_DECLSPEC_STACK; }
     break;
 
   case 541:
+
+/* Line 1806 of yacc.c  */
 #line 2461 "c-parse.y"
-    { yyval.ttype = yyvsp[0].ttype;
-		  POP_DECLSPEC_STACK; ;}
+    { (yyval.ttype) = (yyvsp[(3) - (3)].ttype);
+		  POP_DECLSPEC_STACK; }
     break;
 
   case 542:
+
+/* Line 1806 of yacc.c  */
 #line 2464 "c-parse.y"
-    { yyval.ttype = build_tree_list (build_tree_list (current_declspecs,
-							 yyvsp[-1].ttype),
-					chainon (yyvsp[0].ttype, all_prefix_attributes));
-		  POP_DECLSPEC_STACK; ;}
+    { (yyval.ttype) = build_tree_list (build_tree_list (current_declspecs,
+							 (yyvsp[(3) - (4)].ttype)),
+					chainon ((yyvsp[(4) - (4)].ttype), all_prefix_attributes));
+		  POP_DECLSPEC_STACK; }
     break;
 
   case 543:
+
+/* Line 1806 of yacc.c  */
 #line 2470 "c-parse.y"
-    { yyval.ttype = yyvsp[0].ttype;
-		  POP_DECLSPEC_STACK; ;}
+    { (yyval.ttype) = (yyvsp[(3) - (3)].ttype);
+		  POP_DECLSPEC_STACK; }
     break;
 
   case 544:
+
+/* Line 1806 of yacc.c  */
 #line 2478 "c-parse.y"
-    { yyval.ttype = build_tree_list (build_tree_list (current_declspecs,
-							 yyvsp[-1].ttype),
-					chainon (yyvsp[0].ttype, all_prefix_attributes));
-		  POP_DECLSPEC_STACK; ;}
+    { (yyval.ttype) = build_tree_list (build_tree_list (current_declspecs,
+							 (yyvsp[(3) - (4)].ttype)),
+					chainon ((yyvsp[(4) - (4)].ttype), all_prefix_attributes));
+		  POP_DECLSPEC_STACK; }
     break;
 
   case 545:
+
+/* Line 1806 of yacc.c  */
 #line 2483 "c-parse.y"
-    { yyval.ttype = build_tree_list (build_tree_list (current_declspecs,
-							 yyvsp[-1].ttype),
-					chainon (yyvsp[0].ttype, all_prefix_attributes));
-		  POP_DECLSPEC_STACK; ;}
+    { (yyval.ttype) = build_tree_list (build_tree_list (current_declspecs,
+							 (yyvsp[(3) - (4)].ttype)),
+					chainon ((yyvsp[(4) - (4)].ttype), all_prefix_attributes));
+		  POP_DECLSPEC_STACK; }
     break;
 
   case 546:
+
+/* Line 1806 of yacc.c  */
 #line 2488 "c-parse.y"
-    { yyval.ttype = yyvsp[0].ttype;
-		  POP_DECLSPEC_STACK; ;}
+    { (yyval.ttype) = (yyvsp[(3) - (3)].ttype);
+		  POP_DECLSPEC_STACK; }
     break;
 
   case 547:
+
+/* Line 1806 of yacc.c  */
 #line 2491 "c-parse.y"
-    { yyval.ttype = build_tree_list (build_tree_list (current_declspecs,
-							 yyvsp[-1].ttype),
-					chainon (yyvsp[0].ttype, all_prefix_attributes));
-		  POP_DECLSPEC_STACK; ;}
+    { (yyval.ttype) = build_tree_list (build_tree_list (current_declspecs,
+							 (yyvsp[(3) - (4)].ttype)),
+					chainon ((yyvsp[(4) - (4)].ttype), all_prefix_attributes));
+		  POP_DECLSPEC_STACK; }
     break;
 
   case 548:
+
+/* Line 1806 of yacc.c  */
 #line 2497 "c-parse.y"
-    { yyval.ttype = yyvsp[0].ttype;
-		  POP_DECLSPEC_STACK; ;}
+    { (yyval.ttype) = (yyvsp[(3) - (3)].ttype);
+		  POP_DECLSPEC_STACK; }
     break;
 
   case 549:
+
+/* Line 1806 of yacc.c  */
 #line 2503 "c-parse.y"
-    { prefix_attributes = chainon (prefix_attributes, yyvsp[-3].ttype);
-		  all_prefix_attributes = prefix_attributes; ;}
+    { prefix_attributes = chainon (prefix_attributes, (yyvsp[(-2) - (1)].ttype));
+		  all_prefix_attributes = prefix_attributes; }
     break;
 
   case 550:
+
+/* Line 1806 of yacc.c  */
 #line 2512 "c-parse.y"
     { pushlevel (0);
 		  clear_parm_order ();
-		  declare_parm_level (1); ;}
+		  declare_parm_level (1); }
     break;
 
   case 551:
+
+/* Line 1806 of yacc.c  */
 #line 2516 "c-parse.y"
-    { yyval.ttype = yyvsp[0].ttype;
+    { (yyval.ttype) = (yyvsp[(3) - (3)].ttype);
 		  parmlist_tags_warning ();
-		  poplevel (0, 0, 0); ;}
+		  poplevel (0, 0, 0); }
     break;
 
   case 553:
+
+/* Line 1806 of yacc.c  */
 #line 2524 "c-parse.y"
     { tree t;
-		  for (t = yyvsp[-1].ttype; t; t = TREE_CHAIN (t))
+		  for (t = (yyvsp[(1) - (2)].ttype); t; t = TREE_CHAIN (t))
 		    if (TREE_VALUE (t) == NULL_TREE)
 		      error ("`...' in old-style identifier list");
-		  yyval.ttype = tree_cons (NULL_TREE, NULL_TREE, yyvsp[-1].ttype);
+		  (yyval.ttype) = tree_cons (NULL_TREE, NULL_TREE, (yyvsp[(1) - (2)].ttype));
 
 		  /* Make sure we have a parmlist after attributes.  */
-		  if (yyvsp[-3].ttype != 0
-		      && (TREE_CODE (yyval.ttype) != TREE_LIST
-			  || TREE_PURPOSE (yyval.ttype) == 0
-			  || TREE_CODE (TREE_PURPOSE (yyval.ttype)) != PARM_DECL))
+		  if ((yyvsp[(-1) - (2)].ttype) != 0
+		      && (TREE_CODE ((yyval.ttype)) != TREE_LIST
+			  || TREE_PURPOSE ((yyval.ttype)) == 0
+			  || TREE_CODE (TREE_PURPOSE ((yyval.ttype))) != PARM_DECL))
 		    YYERROR1;
-		;}
+		}
     break;
 
   case 554:
+
+/* Line 1806 of yacc.c  */
 #line 2542 "c-parse.y"
-    { yyval.ttype = build_tree_list (NULL_TREE, yyvsp[0].ttype); ;}
+    { (yyval.ttype) = build_tree_list (NULL_TREE, (yyvsp[(1) - (1)].ttype)); }
     break;
 
   case 555:
+
+/* Line 1806 of yacc.c  */
 #line 2544 "c-parse.y"
-    { yyval.ttype = chainon (yyvsp[-2].ttype, build_tree_list (NULL_TREE, yyvsp[0].ttype)); ;}
+    { (yyval.ttype) = chainon ((yyvsp[(1) - (3)].ttype), build_tree_list (NULL_TREE, (yyvsp[(3) - (3)].ttype))); }
     break;
 
   case 556:
+
+/* Line 1806 of yacc.c  */
 #line 2550 "c-parse.y"
-    { yyval.ttype = build_tree_list (NULL_TREE, yyvsp[0].ttype); ;}
+    { (yyval.ttype) = build_tree_list (NULL_TREE, (yyvsp[(1) - (1)].ttype)); }
     break;
 
   case 557:
+
+/* Line 1806 of yacc.c  */
 #line 2552 "c-parse.y"
-    { yyval.ttype = chainon (yyvsp[-2].ttype, build_tree_list (NULL_TREE, yyvsp[0].ttype)); ;}
+    { (yyval.ttype) = chainon ((yyvsp[(1) - (3)].ttype), build_tree_list (NULL_TREE, (yyvsp[(3) - (3)].ttype))); }
     break;
 
   case 558:
+
+/* Line 1806 of yacc.c  */
 #line 2557 "c-parse.y"
-    { yyval.ttype = SAVE_EXT_FLAGS();
+    { (yyval.ttype) = SAVE_EXT_FLAGS();
 		  pedantic = 0;
 		  warn_pointer_arith = 0;
 		  warn_traditional = 0;
-		  flag_iso = 0; ;}
+		  flag_iso = 0; }
     break;
 
 
-    }
-
-/* Line 991 of yacc.c.  */
-#line 5255 "c-p15339.c"
-
-  yyvsp -= yylen;
-  yyssp -= yylen;
 
+/* Line 1806 of yacc.c  */
+#line 6385 "c-p5137.c"
+      default: break;
+    }
+  /* User semantic actions sometimes alter yychar, and that requires
+     that yytoken be updated with the new translation.  We take the
+     approach of translating immediately before every use of yytoken.
+     One alternative is translating here after every semantic action,
+     but that translation would be missed if the semantic action invokes
+     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or
+     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an
+     incorrect destructor might then be invoked immediately.  In the
+     case of YYERROR or YYBACKUP, subsequent parser actions might lead
+     to an incorrect destructor call or verbose syntax error message
+     before the lookahead is translated.  */
+  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
 
+  YYPOPSTACK (yylen);
+  yylen = 0;
   YY_STACK_PRINT (yyss, yyssp);
 
   *++yyvsp = yyval;
 
-
   /* Now `shift' the result of the reduction.  Determine what state
      that goes to, based on the state we popped back to and the rule
      number reduced by.  */
@@ -5282,58 +6422,48 @@
 | yyerrlab -- here on detecting error |
 `------------------------------------*/
 yyerrlab:
+  /* Make sure we have latest lookahead translation.  See comments at
+     user semantic actions for why this is necessary.  */
+  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);
+
   /* If not already recovering from an error, report this error.  */
   if (!yyerrstatus)
     {
       ++yynerrs;
-#if YYERROR_VERBOSE
-      yyn = yypact[yystate];
-
-      if (YYPACT_NINF < yyn && yyn < YYLAST)
-	{
-	  YYSIZE_T yysize = 0;
-	  int yytype = YYTRANSLATE (yychar);
-	  char *yymsg;
-	  int yyx, yycount;
-
-	  yycount = 0;
-	  /* Start YYX at -YYN if negative to avoid negative indexes in
-	     YYCHECK.  */
-	  for (yyx = yyn < 0 ? -yyn : 0;
-	       yyx < (int) (sizeof (yytname) / sizeof (char *)); yyx++)
-	    if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
-	      yysize += yystrlen (yytname[yyx]) + 15, yycount++;
-	  yysize += yystrlen ("syntax error, unexpected ") + 1;
-	  yysize += yystrlen (yytname[yytype]);
-	  yymsg = (char *) YYSTACK_ALLOC (yysize);
-	  if (yymsg != 0)
-	    {
-	      char *yyp = yystpcpy (yymsg, "syntax error, unexpected ");
-	      yyp = yystpcpy (yyp, yytname[yytype]);
-
-	      if (yycount < 5)
-		{
-		  yycount = 0;
-		  for (yyx = yyn < 0 ? -yyn : 0;
-		       yyx < (int) (sizeof (yytname) / sizeof (char *));
-		       yyx++)
-		    if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
-		      {
-			const char *yyq = ! yycount ? ", expecting " : " or ";
-			yyp = yystpcpy (yyp, yyq);
-			yyp = yystpcpy (yyp, yytname[yyx]);
-			yycount++;
-		      }
-		}
-	      yyerror (yymsg);
-	      YYSTACK_FREE (yymsg);
-	    }
-	  else
-	    yyerror ("syntax error; also virtual memory exhausted");
-	}
-      else
-#endif /* YYERROR_VERBOSE */
-	yyerror ("syntax error");
+#if ! YYERROR_VERBOSE
+      yyerror (YY_("syntax error"));
+#else
+# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \
+                                        yyssp, yytoken)
+      {
+        char const *yymsgp = YY_("syntax error");
+        int yysyntax_error_status;
+        yysyntax_error_status = YYSYNTAX_ERROR;
+        if (yysyntax_error_status == 0)
+          yymsgp = yymsg;
+        else if (yysyntax_error_status == 1)
+          {
+            if (yymsg != yymsgbuf)
+              YYSTACK_FREE (yymsg);
+            yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);
+            if (!yymsg)
+              {
+                yymsg = yymsgbuf;
+                yymsg_alloc = sizeof yymsgbuf;
+                yysyntax_error_status = 2;
+              }
+            else
+              {
+                yysyntax_error_status = YYSYNTAX_ERROR;
+                yymsgp = yymsg;
+              }
+          }
+        yyerror (yymsgp);
+        if (yysyntax_error_status == 2)
+          goto yyexhaustedlab;
+      }
+# undef YYSYNTAX_ERROR
+#endif
     }
 
 
@@ -5343,58 +6473,55 @@
       /* If just tried and failed to reuse lookahead token after an
 	 error, discard it.  */
 
-      /* Return failure if at end of input.  */
-      if (yychar == YYEOF)
-        {
-	  /* Pop the error token.  */
-          YYPOPSTACK;
-	  /* Pop the rest of the stack.  */
-	  while (yyss < yyssp)
-	    {
-	      YYDSYMPRINTF ("Error: popping", yystos[*yyssp], yyvsp, yylsp);
-	      yydestruct (yystos[*yyssp], yyvsp);
-	      YYPOPSTACK;
-	    }
-	  YYABORT;
-        }
-
-      YYDSYMPRINTF ("Error: discarding", yytoken, &yylval, &yylloc);
-      yydestruct (yytoken, &yylval);
-      yychar = YYEMPTY;
-
+      if (yychar <= YYEOF)
+	{
+	  /* Return failure if at end of input.  */
+	  if (yychar == YYEOF)
+	    YYABORT;
+	}
+      else
+	{
+	  yydestruct ("Error: discarding",
+		      yytoken, &yylval);
+	  yychar = YYEMPTY;
+	}
     }
 
   /* Else will try to reuse lookahead token after shifting the error
      token.  */
-  goto yyerrlab2;
-
-
-/*----------------------------------------------------.
-| yyerrlab1 -- error raised explicitly by an action.  |
-`----------------------------------------------------*/
-yyerrlab1:
-
-  /* Suppress GCC warning that yyerrlab1 is unused when no action
-     invokes YYERROR.  */
-#if defined (__GNUC_MINOR__) && 2093 <= (__GNUC__ * 1000 + __GNUC_MINOR__) \
-    && !defined __cplusplus
-  __attribute__ ((__unused__))
-#endif
+  goto yyerrlab1;
 
 
-  goto yyerrlab2;
+/*---------------------------------------------------.
+| yyerrorlab -- error raised explicitly by YYERROR.  |
+`---------------------------------------------------*/
+yyerrorlab:
+
+  /* Pacify compilers like GCC when the user code never invokes
+     YYERROR and the label yyerrorlab therefore never appears in user
+     code.  */
+  if (/*CONSTCOND*/ 0)
+     goto yyerrorlab;
+
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYERROR.  */
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+  yystate = *yyssp;
+  goto yyerrlab1;
 
 
-/*---------------------------------------------------------------.
-| yyerrlab2 -- pop states until the error token can be shifted.  |
-`---------------------------------------------------------------*/
-yyerrlab2:
+/*-------------------------------------------------------------.
+| yyerrlab1 -- common code for both syntax error and YYERROR.  |
+`-------------------------------------------------------------*/
+yyerrlab1:
   yyerrstatus = 3;	/* Each real token shifted decrements this.  */
 
   for (;;)
     {
       yyn = yypact[yystate];
-      if (yyn != YYPACT_NINF)
+      if (!yypact_value_is_default (yyn))
 	{
 	  yyn += YYTERROR;
 	  if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
@@ -5409,22 +6536,20 @@
       if (yyssp == yyss)
 	YYABORT;
 
-      YYDSYMPRINTF ("Error: popping", yystos[*yyssp], yyvsp, yylsp);
-      yydestruct (yystos[yystate], yyvsp);
-      yyvsp--;
-      yystate = *--yyssp;
 
+      yydestruct ("Error: popping",
+		  yystos[yystate], yyvsp);
+      YYPOPSTACK (1);
+      yystate = *yyssp;
       YY_STACK_PRINT (yyss, yyssp);
     }
 
-  if (yyn == YYFINAL)
-    YYACCEPT;
-
-  YYDPRINTF ((stderr, "Shifting error token, "));
-
   *++yyvsp = yylval;
 
 
+  /* Shift the error token.  */
+  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
+
   yystate = yyn;
   goto yynewstate;
 
@@ -5443,25 +6568,50 @@
   yyresult = 1;
   goto yyreturn;
 
-#ifndef yyoverflow
-/*----------------------------------------------.
-| yyoverflowlab -- parser overflow comes here.  |
-`----------------------------------------------*/
-yyoverflowlab:
-  yyerror ("parser stack overflow");
+#if !defined(yyoverflow) || YYERROR_VERBOSE
+/*-------------------------------------------------.
+| yyexhaustedlab -- memory exhaustion comes here.  |
+`-------------------------------------------------*/
+yyexhaustedlab:
+  yyerror (YY_("memory exhausted"));
   yyresult = 2;
   /* Fall through.  */
 #endif
 
 yyreturn:
+  if (yychar != YYEMPTY)
+    {
+      /* Make sure we have latest lookahead translation.  See comments at
+         user semantic actions for why this is necessary.  */
+      yytoken = YYTRANSLATE (yychar);
+      yydestruct ("Cleanup: discarding lookahead",
+                  yytoken, &yylval);
+    }
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYABORT or YYACCEPT.  */
+  YYPOPSTACK (yylen);
+  YY_STACK_PRINT (yyss, yyssp);
+  while (yyssp != yyss)
+    {
+      yydestruct ("Cleanup: popping",
+		  yystos[*yyssp], yyvsp);
+      YYPOPSTACK (1);
+    }
 #ifndef yyoverflow
   if (yyss != yyssa)
     YYSTACK_FREE (yyss);
 #endif
-  return yyresult;
+#if YYERROR_VERBOSE
+  if (yymsg != yymsgbuf)
+    YYSTACK_FREE (yymsg);
+#endif
+  /* Make sure YYID is used.  */
+  return YYID (yyresult);
 }
 
 
+
+/* Line 2067 of yacc.c  */
 #line 2564 "c-parse.y"
 
 
@@ -6034,4 +7184,3 @@
 
 #include "gt-c-parse.h"
 
-
--- a/gcc/c-parse.y
+++ b/gcc/c-parse.y
@@ -1661,7 +1661,7 @@
 
 structsp_attr:
 	  struct_head identifier '{'
-		{ $$ = start_struct (RECORD_TYPE, $2);
+		{ $<ttype>$ = start_struct (RECORD_TYPE, $2);
 		  /* Start scope of tag before parsing components.  */
 		}
 	  component_decl_list '}' maybe_attribute
@@ -1671,7 +1671,7 @@
 				      $3, chainon ($1, $5));
 		}
 	| union_head identifier '{'
-		{ $$ = start_struct (UNION_TYPE, $2); }
+		{ $<ttype>$ = start_struct (UNION_TYPE, $2); }
 	  component_decl_list '}' maybe_attribute
 		{ $$ = finish_struct ($<ttype>4, $5, chainon ($1, $7)); }
 	| union_head '{' component_decl_list '}' maybe_attribute
@@ -1679,12 +1679,12 @@
 				      $3, chainon ($1, $5));
 		}
 	| enum_head identifier '{'
-		{ $$ = start_enum ($2); }
+		{ $<ttype>$ = start_enum ($2); }
 	  enumlist maybecomma_warn '}' maybe_attribute
 		{ $$ = finish_enum ($<ttype>4, nreverse ($5),
 				    chainon ($1, $8)); }
 	| enum_head '{'
-		{ $$ = start_enum (NULL_TREE); }
+		{ $<ttype>$ = start_enum (NULL_TREE); }
 	  enumlist maybecomma_warn '}' maybe_attribute
 		{ $$ = finish_enum ($<ttype>3, nreverse ($4),
 				    chainon ($1, $7)); }
--- a/gcc/collect2.c
+++ b/gcc/collect2.c
@@ -74,6 +74,10 @@
 #undef REAL_STRIP_FILE_NAME
 #endif
 
+#ifdef WIN32
+# define USE_POPEN
+#endif
+
 /* If we cannot use a special method, use the ordinary one:
    run nm to find what symbols are present.
    In a cross-compiler, this means you need a cross nm,
@@ -444,7 +448,11 @@
 #endif
 
   signal (signo, SIG_DFL);
+#ifndef WIN32
   kill (getpid (), signo);
+#else
+  exit(3);
+#endif
 }
 
 
@@ -1572,7 +1580,7 @@
   if (redir)
     {
       /* Open response file.  */
-      redir_handle = open (redir, O_WRONLY | O_TRUNC | O_CREAT);
+      redir_handle = open (redir, O_WRONLY | O_TRUNC | O_CREAT, S_IRUSR | S_IWUSR);
 
       /* Duplicate the stdout and stderr file handles
 	 so they can be restored later.  */
@@ -2081,6 +2089,31 @@
   if (nm_file_name == 0)
     fatal ("cannot find `nm'");
 
+#ifdef USE_POPEN
+  p = (char*) xmalloc (strlen (nm_file_name)
+                       + strlen (NM_FLAGS)
+                       + strlen (prog_name)
+                       + 10);
+  strcpy (p, nm_file_name);
+  strcat (p, " ");
+  if (NM_FLAGS[0] != '\0')
+    {
+      strcat (p, NM_FLAGS);
+      strcat (p, " ");
+    }
+  strcat (p, prog_name);
+  inf = popen (p, "r");
+  if (inf == NULL)
+    fatal_perror ("can't popen `%s'", p);
+
+  /* Trace if needed.  */
+  if (vflag)
+    fprintf (stderr, " %s\n", p);
+
+  free (p);
+  fflush (stdout);
+  fflush (stderr);
+#else
   nm_argv[argc++] = nm_file_name;
   if (NM_FLAGS[0] != '\0')
     nm_argv[argc++] = NM_FLAGS;
@@ -2142,6 +2175,7 @@
 
   if (debug)
     fprintf (stderr, "\nnm output with constructors/destructors.\n");
+#endif
 
   /* Read each line of nm output.  */
   while (fgets (buf, sizeof buf, inf) != (char *) 0)
@@ -2215,7 +2249,11 @@
   if (fclose (inf) != 0)
     fatal_perror ("fclose");
 
+#ifdef USE_POPEN
+  pclose (inf);
+#else
   do_wait (nm_file_name);
+#endif
 
   signal (SIGINT,  int_handler);
 #ifdef SIGQUIT
--- a/gcc/combine.c
+++ b/gcc/combine.c
@@ -6553,7 +6553,7 @@
      address, we stay there.  If we have a comparison, set to COMPARE,
      but once inside, go back to our default of SET.  */
 
-  next_code = (code == MEM || code == PLUS || code == MINUS ? MEM
+  next_code = (code == MEM /* SCz: || code == PLUS || code == MINUS */ ? MEM
 	       : ((code == COMPARE || GET_RTX_CLASS (code) == '<')
 		  && XEXP (x, 1) == const0_rtx) ? COMPARE
 	       : in_code == COMPARE ? SET : in_code);
--- a/gcc/config/divmod.c
+++ b/gcc/config/divmod.c
@@ -1,4 +1,21 @@
-long udivmodsi4 ();
+/* cover the root directory case */
+#if !defined(mc68hc11) && !defined(mc68hc12) && !defined(m9s12x)
+#if defined(target11)
+#define mc68hc11
+#endif
+#if defined(target12)
+#define mc68hc12
+#endif
+#if defined(targets12x)
+#define m9s12x
+#define mc68hc12
+#endif
+#endif
+
+#ifndef mc68hc12
+
+extern unsigned long __udivmodsi4 (unsigned long num, unsigned long den,
+                                   unsigned long *mod);
 
 long
 __divsi3 (long a, long b)
@@ -18,7 +35,7 @@
       neg = !neg;
     }
 
-  res = udivmodsi4 (a, b, 0);
+  res = __udivmodsi4 (a, b, 0);
 
   if (neg)
     res = -res;
@@ -41,10 +58,13 @@
   if (b < 0)
     b = -b;
 
-  res = udivmodsi4 (a, b, 1);
+  __udivmodsi4 (a, b, (unsigned long*) &res);
 
   if (neg)
     res = -res;
 
   return res;
 }
+
+
+#endif /* !mc68hc12  */
--- /dev/null
+++ b/gcc/config/larith.asm
@@ -0,0 +1,1348 @@
+/* libgcc routines for M68HC11 & M68HC12.
+   Copyright (C) 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
+
+This file is part of GNU CC.
+
+GNU CC is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+In addition to the permissions in the GNU General Public License, the
+Free Software Foundation gives you unlimited permission to link the
+compiled version of this file with other programs, and to distribute
+those programs without any restriction coming from the use of this
+file.  (The General Public License restrictions do apply in other
+respects; for example, they cover modification of the file, and
+distribution when not linked into another program.)
+
+This file is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+/* As a special exception, if you link this library with other files,
+   some of which are compiled with GCC, to produce an executable,
+   this library does not by itself cause the resulting executable
+   to be covered by the GNU General Public License.
+   This exception does not however invalidate any other reasons why
+   the executable file might be covered by the GNU General Public License.  */
+
+	.file "larith.asm"
+
+#ifdef __HAVE_SHORT_INT__
+	.mode mshort
+#else
+	.mode mlong
+#endif
+
+	.macro declare_near name
+	.globl \name
+	.type  \name,@function
+	.size  \name,.Lend-\name
+\name:
+	.endm
+
+#if defined(__USE_RTC__)
+# define ARG(N) N+1
+
+	.macro ret
+#if defined(mc68hc12)
+	rtc
+#else
+	jmp __return_32
+#endif
+	.endm
+
+	.macro declare name
+	.globl \name
+	.type  \name,@function
+	.size  \name,.Lend-\name
+	.far   \name
+\name:
+	.endm
+
+	.macro farsym name
+	.far NAME
+	.endm
+
+#else
+# define ARG(N) N
+
+	.macro ret
+	rts
+	.endm
+
+	.macro farsym name
+	.endm
+
+	.macro declare name
+	.globl \name
+	.type  \name,@function
+	.size  \name,.Lend-\name
+\name:
+	.endm
+
+#endif
+
+	.sect .text
+
+
+#define REG(NAME)			\
+NAME:	.dc.w	1;			\
+	.type NAME,@object ;		\
+	.size NAME,2
+
+#ifdef L_regs_min
+/* Pseudo hard registers used by gcc.
+   They should be located in page0.  */
+
+	.sect .softregs
+	.globl _.tmp
+	.globl _.z,_.xy
+REG(_.tmp)
+REG(_.z)
+REG(_.xy)
+
+#endif
+
+#ifdef L_regs_frame
+	.sect .softregs
+	.globl _.frame
+REG(_.frame)
+#endif
+
+#ifdef L_regs_d1_2
+	.sect .softregs
+	.globl _.d1,_.d2
+REG(_.d1)
+REG(_.d2)
+#endif
+
+#ifdef L_regs_d3_4
+	.sect .softregs
+	.globl _.d3,_.d4
+REG(_.d3)
+REG(_.d4)
+#endif
+
+#ifdef L_regs_d5_6
+	.sect .softregs
+	.globl _.d5,_.d6
+REG(_.d5)
+REG(_.d6)
+#endif
+
+#ifdef L_regs_d7_8
+	.sect .softregs
+	.globl _.d7,_.d8
+REG(_.d7)
+REG(_.d8)
+#endif
+
+#ifdef L_regs_d9_16
+/* Pseudo hard registers used by gcc.
+   They should be located in page0.  */
+	.sect .softregs
+	.globl _.d9,_.d10,_.d11,_.d12,_.d13,_.d14
+	.globl _.d15,_.d16
+REG(_.d9)
+REG(_.d10)
+REG(_.d11)
+REG(_.d12)
+REG(_.d13)
+REG(_.d14)
+REG(_.d15)
+REG(_.d16)
+
+#endif
+
+#ifdef L_regs_d17_32
+/* Pseudo hard registers used by gcc.
+   They should be located in page0.  */
+	.sect .softregs
+	.globl _.d17,_.d18,_.d19,_.d20,_.d21,_.d22
+	.globl _.d23,_.d24,_.d25,_.d26,_.d27,_.d28
+	.globl _.d29,_.d30,_.d31,_.d32
+REG(_.d17)
+REG(_.d18)
+REG(_.d19)
+REG(_.d20)
+REG(_.d21)
+REG(_.d22)
+REG(_.d23)
+REG(_.d24)
+REG(_.d25)
+REG(_.d26)
+REG(_.d27)
+REG(_.d28)
+REG(_.d29)
+REG(_.d30)
+REG(_.d31)
+REG(_.d32)
+#endif
+
+#ifdef L_premain
+;;
+;; Specific initialization for 68hc11 before the main.
+;; Nothing special for a generic routine; Just enable interrupts.
+;;
+	declare_near	__premain
+	clra
+	tap	; Clear both I and X.
+	rts
+#endif
+
+#ifdef L__exit
+;;
+;; Exit operation.  Just loop forever and wait for interrupts.
+;; (no other place to go)
+;; This operation is split in several pieces collected together by
+;; the linker script.  This allows to support destructors at the
+;; exit stage while not impacting program sizes when there is no
+;; destructors.
+;;
+;; _exit:
+;;    *(.fini0)		/* Beginning of finish code (_exit symbol).  */
+;;    *(.fini1)		/* Place holder for applications.  */
+;;    *(.fini2)		/* C++ destructors.  */
+;;    *(.fini3)		/* Place holder for applications.  */
+;;    *(.fini4)		/* Runtime exit.  */
+;;
+	.sect .fini0,"ax",@progbits
+	.globl _exit
+	.globl exit
+	.weak  exit
+	farsym  exit
+	farsym  _exit
+exit:
+_exit:
+
+	.sect .fini4,"ax",@progbits
+fatal:
+	cli
+	wai
+	bra fatal
+#endif
+
+#ifdef L_abort
+;;
+;; Abort operation.  This is defined for the GCC testsuite.
+;;
+	declare	abort
+
+	ldd	#255		;
+#ifdef mc68hc12
+	trap	#0x30
+#else
+	.byte 0xCD		; Generate an illegal instruction trap
+	.byte 0x03		; The simulator catches this and stops.
+#endif
+	jmp _exit
+#endif
+
+#ifdef L_cleanup
+;;
+;; Cleanup operation used by exit().
+;;
+	declare	_cleanup
+
+	ret
+#endif
+
+;-----------------------------------------
+; required gcclib code
+;-----------------------------------------
+#ifdef L_memcpy
+       declare	memcpy
+       declare	__memcpy
+
+	.weak memcpy
+;;;
+;;; void* memcpy(void*, const void*, size_t)
+;;;
+;;; D    = dst	Pmode
+;;; 2,sp = src	Pmode
+;;; 4,sp = size	HImode (size_t)
+;;;
+#ifdef mc68hc12
+	ldx	ARG(2),sp
+	ldy	ARG(4),sp
+	pshd
+	xgdy
+	lsrd
+	bcc	Start
+	movb	1,x+,1,y+
+Start:
+	beq	Done
+Loop:
+	movw	2,x+,2,y+
+	dbne	d,Loop
+Done:
+	puld
+	ret
+#else
+	xgdy
+	tsx
+	ldd	ARG(4),x
+	ldx	ARG(2),x	; SRC = X, DST = Y
+	cpd	#0
+	beq	End
+	pshy
+	inca			; Correction for the deca below
+L0:
+	psha			; Save high-counter part
+L1:
+	ldaa	0,x		; Copy up to 256 bytes
+	staa	0,y
+	inx
+	iny
+	decb
+	bne	L1
+	pula
+	deca
+	bne	L0
+	puly			; Restore Y to return the DST
+End:
+	xgdy
+	ret
+#endif
+#endif
+
+#ifdef L_memset
+       declare	memset
+       declare	__memset
+;;;
+;;; void* memset(void*, int value, size_t)
+;;;
+#ifndef __HAVE_SHORT_INT__
+;;; D    = dst	Pmode
+;;; 2,sp = src	SImode
+;;; 6,sp = size	HImode (size_t)
+	val  = ARG(5)
+	size = ARG(6)
+#else
+;;; D    = dst	Pmode
+;;; 2,sp = src	SImode
+;;; 6,sp = size	HImode (size_t)
+	val  = ARG(3)
+	size = ARG(4)
+#endif
+#ifdef mc68hc12
+	xgdx
+	ldab	val,sp
+	ldy	size,sp
+	pshx
+	beq	End
+Loop:
+	stab	1,x+
+	dbne	y,Loop
+End:
+	puld
+	ret
+#else
+	xgdx
+	tsy
+	ldab	val,y
+	ldy	size,y		; DST = X, CNT = Y
+	beq	End
+	pshx
+L0:
+	stab	0,x		; Fill up to 256 bytes
+	inx
+	dey
+	bne	L0
+	pulx			; Restore X to return the DST
+End:
+	xgdx
+	ret
+#endif
+#endif
+
+#ifdef L_adddi3
+	declare	___adddi3
+
+	tsx
+	xgdy
+	ldd	ARG(8),x		; Add LSB
+	addd	ARG(16),x
+	std	6,y		; Save (carry preserved)
+
+	ldd	ARG(6),x
+	adcb	ARG(15),x
+	adca	ARG(14),x
+	std	4,y
+
+	ldd	ARG(4),x
+	adcb	ARG(13),x
+	adca	ARG(12),x
+	std	2,y
+
+	ldd	ARG(2),x
+	adcb	ARG(11),x		; Add MSB
+	adca	ARG(10),x
+	std	0,y
+
+	xgdy
+	ret
+#endif
+
+#ifdef L_subdi3
+	declare	___subdi3
+
+	tsx
+	xgdy
+	ldd	ARG(8),x		; Subtract LSB
+	subd	ARG(16),x
+	std	6,y			; Save, borrow preserved
+
+	ldd	ARG(6),x
+	sbcb	ARG(15),x
+	sbca	ARG(14),x
+	std	4,y
+
+	ldd	ARG(4),x
+	sbcb	ARG(13),x
+	sbca	ARG(12),x
+	std	2,y
+
+	ldd	ARG(2),x		; Subtract MSB
+	sbcb	ARG(11),x
+	sbca	ARG(10),x
+	std	0,y
+
+	xgdy			;
+	ret
+#endif
+
+#ifdef L_notdi2
+	declare	___notdi2
+
+	tsy
+	xgdx
+	ldd	ARG(8),y
+	coma
+	comb
+	std	6,x
+
+	ldd	ARG(6),y
+	coma
+	comb
+	std	4,x
+
+	ldd	ARG(4),y
+	coma
+	comb
+	std	2,x
+
+	ldd	ARG(2),y
+	coma
+	comb
+	std	0,x
+	xgdx
+	ret
+#endif
+
+#ifdef L_negsi2
+	declare_near ___negsi2
+
+	comb
+	coma
+	xgdx
+	comb
+	coma
+	inx
+	xgdx
+	bne	done
+	inx
+done:
+	rts
+#endif
+
+#ifdef L_one_cmplsi2
+	declare_near ___one_cmplsi2
+
+	comb
+	coma
+	xgdx
+	comb
+	coma
+	xgdx
+	rts
+#endif
+
+#ifdef L_ashlsi3
+	declare_near ___ashlsi3
+
+	xgdy
+	clra
+	andb	#0x1f
+	xgdy
+	beq	Return
+Loop:
+	lsld
+	xgdx
+	rolb
+	rola
+	xgdx
+	dey
+	bne	Loop
+Return:
+	rts
+#endif
+
+#ifdef L_ashrsi3
+	declare_near ___ashrsi3
+
+	xgdy
+	clra
+	andb	#0x1f
+	xgdy
+	beq	Return
+Loop:
+	xgdx
+	asra
+	rorb
+	xgdx
+	rora
+	rorb
+	dey
+	bne	Loop
+Return:
+	rts
+#endif
+
+#ifdef L_lshrsi3
+	declare_near ___lshrsi3
+
+	xgdy
+	clra
+	andb	#0x1f
+	xgdy
+	beq	Return
+Loop:
+	xgdx
+	lsrd
+	xgdx
+	rora
+	rorb
+	dey
+	bne	Loop
+Return:
+	rts
+#endif
+
+#ifdef L_lshrhi3
+	declare_near ___lshrhi3
+
+	cpx	#16
+	bge	Return_zero
+	cpx	#0
+	beq	Return
+Loop:
+	lsrd
+	dex
+	bne	Loop
+Return:
+	rts
+Return_zero:
+	clra
+	clrb
+	rts
+#endif
+
+#ifdef L_lshlhi3
+	declare_near ___lshlhi3
+
+	cpx	#16
+	bge	Return_zero
+	cpx	#0
+	beq	Return
+Loop:
+	lsld
+	dex
+	bne	Loop
+Return:
+	rts
+Return_zero:
+	clra
+	clrb
+	rts
+#endif
+
+#ifdef L_rotrhi3
+	declare_near ___rotrhi3
+
+___rotrhi3:
+	xgdx
+	clra
+	andb	#0x0f
+	xgdx
+	beq	Return
+Loop:
+	tap
+	rorb
+	rora
+	dex
+	bne	Loop
+Return:
+	rts
+#endif
+
+#ifdef L_rotlhi3
+	declare_near ___rotlhi3
+
+___rotlhi3:
+	xgdx
+	clra
+	andb	#0x0f
+	xgdx
+	beq	Return
+Loop:
+	asrb
+	rolb
+	rola
+	rolb
+	dex
+	bne	Loop
+Return:
+	rts
+#endif
+
+#ifdef L_ashrhi3
+	declare_near ___ashrhi3
+
+	cpx	#16
+	bge	Return_minus_1_or_zero
+	cpx	#0
+	beq	Return
+Loop:
+	asra
+	rorb
+	dex
+	bne	Loop
+Return:
+	rts
+Return_minus_1_or_zero:
+	clrb
+	tsta
+	bpl	Return_zero
+	comb
+Return_zero:
+	tba
+	rts
+#endif
+
+#ifdef L_ashrqi3
+	declare_near ___ashrqi3
+
+	cmpa	#8
+	bge	Return_minus_1_or_zero
+	tsta
+	beq	Return
+Loop:
+	asrb
+	deca
+	bne	Loop
+Return:
+	rts
+Return_minus_1_or_zero:
+	clrb
+	tstb
+	bpl	Return_zero
+	coma
+Return_zero:
+	tab
+	rts
+#endif
+
+#ifdef L_lshlqi3
+	declare_near ___lshlqi3
+
+	cmpa	#8
+	bge	Return_zero
+	tsta
+	beq	Return
+Loop:
+	lslb
+	deca
+	bne	Loop
+Return:
+	rts
+Return_zero:
+	clrb
+	rts
+#endif
+
+#ifdef L_divmodhi4
+#ifndef mc68hc12
+/* 68HC12 signed divisions are generated inline (idivs).  */
+
+	declare_near __divmodhi4
+
+;
+;; D = numerator
+;; X = denominator
+;;
+;; Result:	D = D / X
+;;		X = D % X
+;;
+	tsta
+	bpl	Numerator_pos
+	comb			; D = -D <=> D = (~D) + 1
+	coma
+	xgdx
+	inx
+	tsta
+	bpl	Numerator_neg_denominator_pos
+Numerator_neg_denominator_neg:
+	comb			; X = -X
+	coma
+	addd	#1
+	xgdx
+	idiv
+	coma
+	comb
+	xgdx			; Remainder <= 0 and result >= 0
+	inx
+	rts
+
+Numerator_pos_denominator_pos:
+	xgdx
+	idiv
+	xgdx			; Both values are >= 0
+	rts
+
+Numerator_pos:
+	xgdx
+	tsta
+	bpl	Numerator_pos_denominator_pos
+Numerator_pos_denominator_neg:
+	coma			; X = -X
+	comb
+	xgdx
+	inx
+	idiv
+	xgdx			; Remainder >= 0 but result <= 0
+	coma
+	comb
+	addd	#1
+	rts
+
+Numerator_neg_denominator_pos:
+	xgdx
+	idiv
+	coma			; One value is > 0 and the other < 0
+	comb			; Change the sign of result and remainder
+	xgdx
+	inx
+	coma
+	comb
+	addd	#1
+	rts
+#endif /* !mc68hc12 */
+#endif
+
+#ifdef L_mulqi3
+	declare_near ___mulqi3
+
+;
+; short __mulqi3(signed char a, signed char b);
+;
+;	signed char a	-> register A
+;	signed char b	-> register B
+;
+; returns the signed result of A * B in register D.
+;
+	tsta
+	bmi	A_neg
+	tstb
+	bmi	B_neg
+	mul
+	rts
+B_neg:
+	negb
+	bra	A_or_B_neg
+A_neg:
+	nega
+	tstb
+	bmi	AB_neg
+A_or_B_neg:
+	mul
+	coma
+	comb
+	addd	#1
+	rts
+AB_neg:
+	negb
+	mul
+	rts
+#endif
+
+#ifdef L_mulhi3
+	declare_near ___mulhi3
+
+;
+;
+;  unsigned short ___mulhi3(unsigned short a, unsigned short b)
+;
+;	a = register D
+;	b = register X
+;
+#ifdef mc68hc12
+	pshx			; Preserve X
+	exg	x,y
+	emul
+	exg	x,y
+	pulx
+	rts
+#else
+#ifdef NO_TMP
+	;
+	; 16 bit multiplication without temp memory location.
+	; (smaller but slower)
+	;
+	pshx			; (4)
+	ins			; (3)
+	pshb			; (3)
+	psha			; (3)
+	pshx			; (4)
+	pula			; (4)
+	pulx			; (5)
+	mul			; (10) B.high * A.low
+	xgdx			; (3)
+	mul			; (10) B.low * A.high
+	abx			; (3)
+	pula			; (4)
+	pulb			; (4)
+	mul			; (10) B.low * A.low
+	pshx			; (4)
+	tsx			; (3)
+	adda	1,x		; (4)
+	pulx			; (5)
+	rts			; (5) 20 bytes
+				; ---
+				; 91 cycles
+#else
+	stx	*_.tmp		; (4)
+	pshb			; (3)
+	ldab	*_.tmp+1	; (3)
+	mul			; (10) A.high * B.low
+	ldaa	*_.tmp		; (3)
+	stab	*_.tmp		; (3)
+	pulb			; (4)
+	pshb			; (4)
+	mul			; (10) A.low * B.high
+	addb	*_.tmp		; (4)
+	stab	*_.tmp		; (3)
+	ldaa	*_.tmp+1	; (3)
+	pulb			; (4)
+	mul			; (10) A.low * B.low
+	adda	*_.tmp		; (4)
+	rts			; (5) 24/32 bytes
+				; 77/85 cycles
+#endif
+#endif
+#endif
+
+#ifdef L_mulhi32
+
+;
+;
+;  unsigned long __mulhi32(unsigned short a, unsigned short b)
+;
+;	a = register D
+;	b = value on stack
+;
+;	+---------------+
+;       |  B low	| <- 7,x
+;	+---------------+
+;       |  B high	| <- 6,x
+;	+---------------+
+;       |  PC low	|
+;	+---------------+
+;       |  PC high	|
+;	+---------------+
+;	|  Tmp low	|
+;	+---------------+
+;	|  Tmp high     |
+;	+---------------+
+;	|  A low	|
+;	+---------------+
+;	|  A high	|
+;	+---------------+  <- 0,x
+;
+;
+;      <B-low>    5,x
+;      <B-high>   4,x
+;      <ret>      2,x
+;      <A-low>    1,x
+;      <A-high>   0,x
+;
+	declare_near	__mulhi32
+
+#ifdef mc68hc12
+	ldy	2,sp
+	emul
+	exg	x,y
+	rts
+#else
+	pshx			; Room for temp value
+	pshb
+	psha
+	tsx
+	ldab	6,x
+	mul
+	xgdy			; A.high * B.high
+	ldab	7,x
+	pula
+	mul			; A.high * B.low
+	std	2,x
+	ldaa	1,x
+	ldab	6,x
+	mul			; A.low * B.high
+	addd	2,x
+	stab	2,x
+	tab
+	aby
+	bcc	N
+	ldab	#0xff
+	aby
+	iny
+N:
+	ldab	7,x
+	pula
+	mul			; A.low * B.low
+	adda	2,x
+	pulx			; Drop temp location
+	pshy			; Put high part in X
+	pulx
+	bcc	Ret
+	inx
+Ret:
+	rts
+#endif
+#endif
+
+#ifdef L_mulsi3
+
+;
+;      <B-low>    8,y
+;      <B-high>   6,y
+;      <ret>      4,y
+;	<tmp>	  2,y
+;      <A-low>    0,y
+;
+; D,X   -> A
+; Stack -> B
+;
+; The result is:
+;
+;	(((A.low * B.high) + (A.high * B.low)) << 16) + (A.low * B.low)
+;
+;
+;
+
+	declare	__mulsi3
+
+#ifdef mc68hc12
+
+
+
+	pshd				; Save A.low
+	ldy	ARG(4),sp
+	emul				; A.low * B.high
+	ldy	ARG(6),sp
+	exg	x,d
+	emul				; A.high * B.low
+	leax	d,x
+	ldy	ARG(6),sp
+	puld
+	emul				; A.low * B.low
+	exg	d,y
+	leax	d,x
+	exg	d,y
+	ret
+#else
+B_low	=	ARG(8)
+B_high	=	ARG(6)
+A_low	=	0
+A_high	=	2
+	pshx
+	pshb
+	psha
+	tsy
+;
+; If B.low is 0, optimize into: (A.low * B.high) << 16
+;
+	ldd	B_low,y
+	beq	B_low_zero
+;
+; If A.high is 0, optimize into: (A.low * B.high) << 16 + (A.low * B.low)
+;
+	cpx	#0
+	beq	A_high_zero
+	bsr	___mulhi3		; A.high * B.low
+;
+; If A.low is 0, optimize into: (A.high * B.low) << 16
+;
+	ldx	A_low,y
+	beq	A_low_zero		; X = 0, D = A.high * B.low
+	std	2,y
+;
+; If B.high is 0, we can avoid the (A.low * B.high) << 16 term.
+;
+	ldd	B_high,y
+	beq	B_high_zero
+	bsr	___mulhi3		; A.low * B.high
+	addd	2,y
+	std	2,y
+;
+; Here, we know that A.low and B.low are not 0.
+;
+B_high_zero:
+	ldd	B_low,y			; A.low is on the stack
+	bsr	__mulhi32		; A.low * B.low
+	xgdx
+	tsy				; Y was clobbered, get it back
+	addd	2,y
+A_low_zero:				; See A_low_zero_non_optimized below
+	xgdx
+Return:
+	ins
+	ins
+	ins
+	ins
+	ret
+;
+;
+; A_low_zero_non_optimized:
+;
+; At this step, X = 0 and D = (A.high * B.low)
+; Optimize into: (A.high * B.low) << 16
+;
+;	xgdx
+;	clra			; Since X was 0, clearing D is superfuous.
+;	clrb
+;	bra	Return
+; ----------------
+; B.low == 0, the result is:	(A.low * B.high) << 16
+;
+; At this step:
+;   D = B.low				= 0
+;   X = A.high				?
+;       A.low is at A_low,y		?
+;       B.low is at B_low,y		?
+;
+B_low_zero:
+	ldd	A_low,y
+	beq	Zero1
+	ldx	B_high,y
+	beq	Zero2
+	bsr	___mulhi3
+Zero1:
+	xgdx
+Zero2:
+	clra
+	clrb
+	bra	Return
+; ----------------
+; A.high is 0, optimize into: (A.low * B.high) << 16 + (A.low * B.low)
+;
+; At this step:
+;   D = B.low				!= 0
+;   X = A.high				= 0
+;       A.low is at A_low,y		?
+;       B.low is at B_low,y		?
+;
+A_high_zero:
+	ldd	A_low,y		; A.low
+	beq	Zero1
+	ldx	B_high,y	; B.high
+	beq	A_low_B_low
+	bsr	___mulhi3
+	std	2,y
+	bra	B_high_zero	; Do the (A.low * B.low) and the add.
+
+; ----------------
+; A.high and B.high are 0 optimize into: (A.low * B.low)
+;
+; At this step:
+;   D = B.high				= 0
+;   X = A.low				!= 0
+;       A.low is at A_low,y		!= 0
+;       B.high is at B_high,y		= 0
+;
+A_low_B_low:
+	ldd	B_low,y			; A.low is on the stack
+	bsr	__mulhi32
+	bra	Return
+#endif
+#endif
+
+#ifdef L_map_data
+
+	.sect	.install2,"ax",@progbits
+	.globl	__map_data_section
+	.globl __data_image
+#ifdef mc68hc12
+	.globl __data_section_size
+#endif
+__map_data_section:
+#ifdef mc68hc12
+	ldx	#__data_image
+	ldy	#__data_section_start
+	ldd	#__data_section_size
+	beq	Done
+Loop:
+	movb	1,x+,1,y+
+	dbne	d,Loop
+#else
+	ldx	#__data_image
+	ldy	#__data_section_start
+	bra	Start_map
+Loop:
+	ldaa	0,x
+	staa	0,y
+	inx
+	iny
+Start_map:
+	cpx	#__data_image_end
+	blo	Loop
+#endif
+Done:
+
+#endif
+
+#ifdef L_init_bss
+
+	.sect	.install2,"ax",@progbits
+	.globl	__init_bss_section
+
+__init_bss_section:
+	ldd	#__bss_size
+	beq	Done
+	ldx	#__bss_start
+Loop:
+#ifdef mc68hc12
+	clr	1,x+
+	dbne	d,Loop
+#else
+	clr	0,x
+	inx
+	subd	#1
+	bne	Loop
+#endif
+Done:
+
+#endif
+
+#ifdef L_ctor
+
+; End of constructor table
+	.sect	.install3,"ax",@progbits
+	.globl	__do_global_ctors
+
+__do_global_ctors:
+	; Start from the end - sizeof(void*)
+	ldx	#__CTOR_END__-2
+ctors_loop:
+	cpx	#__CTOR_LIST__
+	blo	ctors_done
+	pshx
+	ldx	0,x
+	jsr	0,x
+	pulx
+	dex
+	dex
+	bra	ctors_loop
+ctors_done:
+
+#endif
+
+#ifdef L_dtor
+
+	.sect	.fini3,"ax",@progbits
+	.globl	__do_global_dtors
+
+;;
+;; This piece of code is inserted in the _exit() code by the linker.
+;;
+__do_global_dtors:
+	pshb	; Save exit code
+	psha
+	ldx	#__DTOR_LIST__
+dtors_loop:
+	cpx	#__DTOR_END__
+	bhs	dtors_done
+	pshx
+	ldx	0,x
+	jsr	0,x
+	pulx
+	inx
+	inx
+	bra	dtors_loop
+dtors_done:
+	pula	; Restore exit code
+	pulb
+
+#endif
+
+#ifdef L_far_tramp
+#ifdef mc68hc12
+	.sect	.tramp,"ax",@progbits
+	.globl	__far_trampoline
+
+;; This is a trampoline used by the linker to invoke a function
+;; using rtc to return and being called with jsr/bsr.
+;; The trampoline generated is:
+;;
+;;	foo_tramp:
+;;		ldy	#foo
+;;		call	__far_trampoline,page(foo)
+;;
+;; The linker transforms:
+;;
+;;		jsr	foo
+;;
+;; into
+;;		jsr	foo_tramp
+;;
+;; The linker generated trampoline and _far_trampoline must be in
+;; non-banked memory.
+;;
+__far_trampoline:
+	movb	0,sp, 2,sp	; Copy page register below the caller's return
+	leas	2,sp		; address.
+	jmp	0,y		; We have a 'call/rtc' stack layout now
+				; and can jump to the far handler
+				; (whose memory bank is mapped due to the
+				; call to the trampoline).
+#endif
+
+#ifdef mc68hc11
+	.sect	.tramp,"ax",@progbits
+	.globl __far_trampoline
+
+;; Trampoline generated by gcc for 68HC11:
+;;
+;;	pshb
+;;	ldab	#%page(func)
+;;	ldy	#%addr(func)
+;;	jmp	__far_trampoline
+;;
+__far_trampoline:
+	psha				; (2) Save function parameter (high)
+	;; <Read current page in A>
+	psha				; (2)
+	;; <Set currenge page from B>
+	pshx				; (4)
+	tsx				; (3)
+	ldab	4,x			; (4) Restore function parameter (low)
+	ldaa	2,x			; (4) Get saved page number
+	staa	4,x			; (4) Save it below return PC
+	pulx				; (5)
+	pula				; (3)
+	pula				; (3) Restore function parameter (high)
+	jmp	0,y			; (4)
+#endif
+#endif
+
+#ifdef L_call_far
+#ifdef mc68hc11
+	.sect	.tramp,"ax",@progbits
+	.globl __call_a16
+	.globl __call_a32
+;;
+;; The call methods are used for 68HC11 to support memory bank switching.
+;; Every far call is redirected to these call methods.  Its purpose is to:
+;;
+;;  1/ Save the current page on the stack (1 byte to follow 68HC12 call frame)
+;;  2/ Install the new page
+;;  3/ Jump to the real function
+;;
+;; The page switching (get/save) is board dependent.  The default provided
+;; here does nothing (just create the appropriate call frame).
+;;
+;; Call sequence (10 bytes, 13 cycles):
+;;
+;;	ldx #page			; (3)
+;;	ldy #func			; (4)
+;;	jsr __call_a16			; (6)
+;;
+;; Call trampoline (11 bytes, 19 cycles):
+;;
+__call_a16:
+	;; xgdx				; (3)
+	;; <Read current page in A>	; (3) ldaa _current_page
+	psha				; (2)
+	;; <Set current page from B>	; (4) staa _current_page
+	;; xgdx				; (3)
+	jmp 0,y				; (4)
+
+;;
+;; Call sequence (10 bytes, 14 cycles):
+;;
+;;	pshb				; (2)
+;;	ldab #page			; (2)
+;;	ldy  #func			; (4)
+;;	jsr __call_a32			; (6)
+;;
+;; Call trampoline (87 bytes, 57 cycles):
+;;
+__call_a32:
+	pshx				; (4)
+	psha				; (2)
+	;; <Read current page in A>	; (3) ldaa _current_page
+	psha				; (2)
+	;; <Set current page from B>	; (4) staa _current_page
+	tsx				; (3)
+	ldab	6,x			; (4) Restore function parameter
+	ldaa	5,x			; (4) Move PC return at good place
+	staa	6,x			; (4)
+	ldaa	4,x			; (4)
+	staa	5,x			; (4)
+	pula				; (3)
+	staa	4,x			; (4)
+	pula				; (3)
+	pulx				; (5)
+	jmp	0,y			; (4)
+#endif
+#endif
+
+#ifdef L_return_far
+#ifdef mc68hc11
+	.sect	.tramp,"ax",@progbits
+       .globl __return_void
+       .globl __return_16
+       .globl __return_32
+
+__return_void:
+	;; pulb
+	;; <Set current page from B> (Board specific)
+	;; rts
+__return_16:
+	;; xgdx
+	;; pulb
+	;; <Set current page from B> (Board specific)
+	;; xgdx
+	;; rts
+__return_32:
+	;; xgdy
+	;; pulb
+	;; <Set current page from B> (Board specific)
+	;; xgdy
+	;; rts
+	ins
+	rts
+#endif
+#endif
+.Lend:
+;-----------------------------------------
+; end required gcclib code
+;-----------------------------------------
--- a/gcc/config/m68hc11/larith.asm
+++ b/gcc/config/m68hc11/larith.asm
@@ -35,6 +35,10 @@
 
 	.file "larith.asm"
 
+#if !defined(mc68hc11) && !defined(mc68hc12) && !defined(m9s12x)
+  #error No target defined for larith.asm
+#endif
+
 #ifdef __HAVE_SHORT_INT__
 	.mode mshort
 #else
@@ -402,18 +406,30 @@
 	std	6,y			; Save, borrow preserved
 
 	ldd	ARG(6),x
+#if defined(m9s12x)
+    sbed    ARG(14),x
+#else
 	sbcb	ARG(15),x
 	sbca	ARG(14),x
+#endif
 	std	4,y
 
 	ldd	ARG(4),x
+#if defined(m9s12x)
+	sbed	ARG(12),x
+#else
 	sbcb	ARG(13),x
 	sbca	ARG(12),x
+#endif
 	std	2,y
 	
 	ldd	ARG(2),x		; Subtract MSB
+#if defined(m9s12x)
+	sbed	ARG(10),x
+#else
 	sbcb	ARG(11),x
 	sbca	ARG(10),x
+#endif
 	std	0,y
 
 	xgdy			;
@@ -469,10 +485,14 @@
 
 	comb
 	coma
+#if defined(m9s12x)
+    comx
+#else
 	xgdx
 	comb
 	coma
 	xgdx
+#endif
 	rts
 #endif
 	
@@ -486,10 +506,14 @@
 	beq	Return
 Loop:
 	lsld
+#if defined(m9s12x)
+    rolx
+#else
 	xgdx
 	rolb
 	rola
 	xgdx
+#endif
 	dey
 	bne	Loop
 Return:
@@ -505,10 +529,14 @@
 	xgdy
 	beq	Return
 Loop:
+#if defined(m9s12x)
+    asrx
+#else
 	xgdx
 	asra
 	rorb
 	xgdx
+#endif
 	rora
 	rorb
 	dey
@@ -526,9 +554,13 @@
 	xgdy
 	beq	Return
 Loop:
+#if defined(m9s12x)
+    lsrx
+#else
 	xgdx
 	lsrd
 	xgdx
+#endif
 	rora
 	rorb
 	dey
@@ -579,10 +611,14 @@
 	declare_near ___rotrhi3
 
 ___rotrhi3:
+#if defined(m9s12x)
+    andx    #0x000f
+#else
 	xgdx
 	clra
 	andb	#0x0f
 	xgdx
+#endif
 	beq	Return
 Loop:
 	tap
@@ -598,10 +634,14 @@
 	declare_near ___rotlhi3
 
 ___rotlhi3:
+#if defined(m9s12x)
+    andx    #0x000f
+#else
 	xgdx
 	clra
 	andb	#0x0f
 	xgdx
+#endif
 	beq	Return
 Loop:
 	asrb
@@ -951,6 +991,9 @@
 	declare	__mulsi3
 
 #ifdef mc68hc12
+
+
+
 	pshd				; Save A.low
 	ldy	ARG(4),sp
 	emul				; A.low * B.high
--- /dev/null
+++ b/gcc/config/m68hc11/ldivmod.asm
@@ -0,0 +1,584 @@
+;;;-----------------------------------------
+
+;;;  Hand coded div and mod functions.
+;;;  AES 2009
+;;;	 for S12X platform
+;;;-----------------------------------------
+
+; Re-coded for m68hc12 as well - James Murray October 2010
+	
+	.file "ldivmod.asm"
+
+#if !defined(mc68hc11) && !defined(mc68hc12) && !defined(m9s12x)
+  #error No target defined for ldivmod.asm
+#endif
+
+#if defined(mc68hc12) || defined(m9s12x)
+
+#ifdef __HAVE_SHORT_INT__
+	.mode mshort
+#else
+	.mode mlong
+#endif
+
+	.macro declare_near name
+	.globl \name
+	.type  \name,@function
+	.size  \name,.Lend-\name
+\name:
+	.endm
+
+#if defined(__USE_RTC__)
+# define ARG(N) N+1
+
+	.macro ret
+#if defined(mc68hc12)
+	rtc
+#else
+	jmp __return_32
+#endif
+	.endm
+
+	.macro declare name
+	.globl \name
+	.type  \name,@function
+	.size  \name,.Lend-\name
+	.far   \name
+\name:
+	.endm
+
+	.macro farsym name
+	.far NAME
+	.endm
+
+#else
+# define ARG(N) N
+
+	.macro ret
+	rts
+	.endm
+
+	.macro farsym name
+	.endm
+
+	.macro declare name
+	.globl \name
+	.type  \name,@function
+	.size  \name,.Lend-\name
+\name:
+	.endm
+
+#endif
+
+	.sect .text
+	
+
+#define REG(NAME)			\
+NAME:	.dc.w	1;			\
+	.type NAME,@object ;		\
+	.size NAME,2
+
+#ifdef L_regs_min
+/* Pseudo hard registers used by gcc.
+   They should be located in page0.  */
+
+	.sect .softregs
+	.globl _.tmp
+
+REG(_.tmp)
+#endif
+
+
+
+/* ok, guessing that we get called with a in D and X and B on stack */
+
+;;; 
+;;; long __divsi3 ( long num, long den )
+;;;
+
+;;; d == num_low
+;;; x == num_high
+
+;;; sp, ARG(4)  == den_high
+;;; sp, ARG(6)  == den_low
+;;; return result in XD
+
+;;; calling here we have also pushed 4 extra bytes on stack
+;;;  and we dont use a frame pointer
+
+
+udivmodsi:
+	pshy				; preserve y
+	pshd				; save numerator in case ediv fails
+	pshx
+#ifndef m9s12x
+	tst 	ARG(10), sp		; does denominator fit in uint16 ?
+	bne 	go_soft_udivmodsi
+	tst 	ARG(11), sp		; does denominator fit in uint16 ?
+	bne 	go_soft_udivmodsi
+#else
+	tstw 	ARG(10), sp		; does denominator fit in uint16 ?
+	bne 	go_soft_udivmodsi
+#endif
+	tfr 	x,y			; load num_high into y
+	ldx	ARG(12), sp		; load denominator into x
+	ediv
+	bvs	go_soft_udivmodsi 	; overflow ??
+
+	;; overwrite denominator on stack with modulus
+	;; this is ok since c copies args onto stack  (???CHECKME)
+
+	std	ARG(12), sp
+#ifndef m9s12x
+	clr 	ARG(10), sp
+	clr 	ARG(11), sp
+#else
+	clrw 	ARG(10), sp
+#endif
+
+	;; return division  results in X:D
+#ifndef m9s12x
+    ldx #0
+#else
+	clrx
+#endif
+	tfr	y,d
+	
+	leas 	4, sp		  	; deallocate stack for numerator save
+	puly				; retrieve y
+	rts
+
+go_soft_udivmodsi:
+#ifndef m9s12x
+    ldy #0
+#else
+	clry
+#endif
+	bra 	soft_udivmodsi
+	
+
+divmodsi:	
+
+	pshy			; preserve y
+	pshd			; save numerator in case edivs fails
+	pshx
+	ldy	ARG(10),sp	; denominator fits in signed int16  ??
+	beq	test_pos
+#ifndef m9s12x
+    xgdy
+    coma
+    comb
+    xgdy
+#else
+	comy
+#endif
+	beq	test_neg
+	bra	soft_divmodsi
+test_pos:	
+	ldy	ARG(12),sp
+	bpl	hard_divmodsi 	
+	bra	soft_divmodsi
+
+test_neg:
+	ldy	ARG(12),sp
+	bpl	soft_divmodsi
+	
+hard_divmodsi:
+	
+	exg 	x,y
+	edivs			; attempt a divide by hardware
+	bvs  	soft_divmodsi     	; an overflow happened ... do soft divide
+
+#ifndef m9s12x
+	clr 	ARG(10),sp
+	clr 	ARG(11),sp
+#else
+	clrw 	ARG(10),sp
+#endif
+	std	ARG(12), sp
+	bpl	skip_hdsx_mod   ; sign extend modulus
+	movw	#0xFFFF, ARG(10), sp 	
+skip_hdsx_mod:	
+
+
+	;; returned division  results in X:D
+#ifndef m9s12x
+    ldx #0
+    xgdy
+    tsta
+    xgdy
+#else
+	clrx
+	tsty
+#endif
+	bpl	skip_hdsx_div   ; sign extend result
+	ldx    #0xFFFF
+	
+skip_hdsx_div:	
+	tfr	y,d	
+	leas    4,sp		; deallocate stack
+	puly			; retrieve y
+	rts
+
+soft_divmodsi:
+	;; numerator in sp and sp+1 ; den in ARG(10) and ARG(12)
+#ifndef m9s12x
+    ldy #0
+#else
+	clry	              ; use y to evaluate sign of result
+#endif
+	tst	0, sp       ; was tstw
+	bpl	sd_skip_neg_num
+
+#ifndef m9s12x
+    xgdy
+    orab    #3
+    xgdy
+    com     3, sp
+    com     2, sp
+    com     1, sp
+    com     0, sp
+	inc	    3, sp
+	bne	sd_skip_neg_num
+	inc	    2, sp
+	bne	sd_skip_neg_num
+	inc	    1, sp
+	bne	sd_skip_neg_num
+	inc 	0, sp
+#else
+	ory    #3
+	comw	2, sp
+	comw  	0, sp
+	incw	2, sp
+	bne	sd_skip_neg_num
+	incw	0, sp
+#endif
+	
+sd_skip_neg_num:
+
+	tst 	ARG(10), sp
+	bpl	sd_skip_neg_den ; was tstw
+
+#ifndef m9s12x
+    xgdy
+    eorb    #1
+    xgdy
+	com 	ARG(13), sp
+	com 	ARG(12), sp
+	com 	ARG(11), sp
+	com 	ARG(10), sp
+	inc	    ARG(13), sp
+	bne	sd_skip_neg_den
+	inc	    ARG(12), sp
+	bne	sd_skip_neg_den
+	inc	    ARG(11), sp
+	bne	sd_skip_neg_den
+	inc	    ARG(10), sp
+#else
+	eory	#1
+	comw 	ARG(12), sp
+	comw 	ARG(10),  sp
+	incw	ARG(12), sp
+	bne	sd_skip_neg_den
+	incw	ARG(10),  sp
+#endif	
+
+sd_skip_neg_den:
+soft_udivmodsi:	    		; if called from udivmodsi
+				; make sure y=0  
+	leas -8,sp		; allocate for 'bit' and 'res' 
+	
+	;; stack should look like this on entry if  ARG(N)=N:
+
+	;; 
+	;; 
+	;; 
+	;; denominator (SI)                             ---  sp+18
+	;; 
+	;; return address for calling function  (HI)   sp+16
+	;; 
+	;; return address for frontend  function (HI) sp+14
+	;;
+	;; preserve y	   ----  sp+12
+	;; 
+	;; 
+	;; 
+	;; numerator (SI)  ----  sp+8
+	;;
+	;;
+	;;
+	;; bit (SI)        ----  sp+4
+	;;
+	;; 
+	;; 
+	;; res (SI)        ----  sp
+	
+#ifndef m9s12x
+	clr 	0, sp		; res = 0
+	clr	    1, sp
+	clr	    2, sp
+	clr	    3, sp
+	tst	ARG(18),sp
+	bne     checked_den
+	tst	ARG(19),sp
+	bne     checked_den
+	tst	ARG(20),sp
+	bne     checked_den
+	tst	ARG(21),sp
+	beq	while_end
+#else
+	clrw 	0, sp		; res = 0
+	clrw	2, sp
+	tstw	ARG(18),sp
+	bne     checked_den
+	tstw	ARG(20),sp
+	beq	while_end
+#endif
+	
+checked_den:	
+
+	movw	#1, 6, sp
+#ifndef m9s12x
+	clr	    4,sp            ; bit = 1
+	clr	    5,sp            ; bit = 1
+#else
+	clrw	4,sp            ; bit = 1
+#endif
+
+while_den:			; while ((den < num) && !(den.bit31))
+	tst 	ARG(18), sp ; was tstw
+	bmi 	while_bit
+	ldd	10,sp
+	ldx	8,sp
+
+	subd 	ARG(20), sp
+#ifndef m9s12x
+    xgdx
+    sbcb    ARG(19), sp
+    sbca    ARG(18), sp
+    xgdx
+#else
+	sbex	ARG(18), sp
+#endif
+	bcs	while_bit
+
+#ifndef m9s12x
+	asl	    ARG(21), sp     ;  den <<= 1
+	rol	    ARG(20), sp
+	rol	    ARG(19), sp
+	rol	    ARG(18), sp
+
+	asl	    7,sp		; bit <<= 1
+	rol	    6,sp			
+	rol	    5,sp			
+	rol	    4,sp			
+#else
+	aslw	ARG(20), sp     ;  den <<= 1
+	rolw	ARG(18), sp
+
+	aslw	6,sp		; bit <<= 1
+	rolw	4,sp			
+#endif
+
+	bra	while_den
+
+
+while_bit:			; while  (bit!=0)
+#ifndef m9s12x
+	tst	    4, sp
+	bne	while_bit_ok
+	tst	    5, sp
+	bne	while_bit_ok
+	tst	    6, sp
+	bne	while_bit_ok
+	tst	    7,sp
+	beq	while_end
+#else
+	tstw	4, sp
+	bne	while_bit_ok
+	tstw	6,sp
+	beq	while_end
+#endif
+
+while_bit_ok:
+	
+	ldd 	10, sp		; if (num >= den) 
+	ldx	8, sp
+	subd	ARG(20),sp
+#ifndef m9s12x
+    xgdx
+    sbcb    ARG(19),sp
+    sbca    ARG(18),sp
+    xgdx
+#else
+	sbex	ARG(18),sp
+#endif
+	bcs	skip_restore   	; here was bmi
+
+	std	10,sp		; num-=den
+	stx	8,sp
+
+#ifndef m9s12x
+	ldd	    0,sp		; res|= bit
+	oraa	4,sp
+	orab	5,sp
+	std	    0,sp
+	ldd	    2,sp
+	oraa	6,sp
+	orab	7,sp
+	std	    2,sp
+#else
+	ldx	    0,sp		; res|= bit
+	orx	    4,sp
+	stx	    0,sp
+	ldx	    2,sp
+	orx	    6,sp
+	stx	    2,sp
+#endif
+
+skip_restore:
+	
+#ifndef m9s12x
+	lsr	    4,sp 		; bit >>=1
+	ror	    5,sp		
+	ror	    6,sp		
+	ror	    7,sp		
+	
+	lsr 	ARG(18),sp		; den >>=1
+	ror 	ARG(19),sp
+	ror 	ARG(20),sp
+	ror 	ARG(21),sp
+#else
+	lsrw	4,sp 		; bit >>=1
+	rorw	6,sp		
+	
+	lsrw	ARG(18),sp		; den >>=1
+	rorw	ARG(20),sp
+#endif
+	
+	bra while_bit
+	
+while_end:
+	;; numerator contains mod
+	;; overwrite denominator with it on stack for return
+//	movw	8,sp,ARG(18), sp 
+//	movw	10,sp, ARG(20), sp
+	leax	ARG(18), sp
+	movw	8,sp, 0,x
+	movw	10,sp, 2,x
+	
+	ldx	0,sp
+	ldd 	2,sp
+
+	leas	12,sp 		; deallocate locals
+#ifndef m9s12x
+    xgdy			; do we need to negate result ?
+    tsta
+    bne no_end
+	tstb
+    bne no_end
+    xgdy
+	bra	end_division
+no_end:
+    xgdy
+#else
+	tsty			; do we need to negate result ?
+	beq	end_division
+#endif
+					
+	;; 	if y&1 then negate result
+	;; 	if y&2 then negate modulus
+
+	pshy
+#ifndef m9s12x
+    xgdy
+    andb    #1
+    xgdy
+#else
+	andy	#1
+#endif
+	puly
+	beq	skip_end_res_neg
+	
+	coma
+	comb
+#ifndef m9s12x
+    xgdx
+    coma
+    comb
+    xgdx
+#else
+	comx
+#endif
+	incb
+	bne	end_division
+	inca	
+	bne	end_division
+	inx	
+
+skip_end_res_neg:
+#ifndef m9s12x
+    xgdy
+    andb    #2
+    xgdy
+#else
+	andy	#2
+#endif
+	beq	end_division
+
+#ifndef m9s12x
+	com 	ARG(6), sp
+	com 	ARG(7), sp
+	com 	ARG(8), sp
+	com 	ARG(9), sp
+	inc	    ARG(9), sp
+	bne	end_division
+	inc	    ARG(8), sp
+	bne	end_division
+	inc	    ARG(7), sp
+	bne	end_division
+	inc	    ARG(6),  sp
+#else
+	comw 	ARG(6), sp
+	comw 	ARG(8), sp
+	incw	ARG(8), sp
+	bne	end_division
+	incw	ARG(6),  sp
+#endif
+	
+end_division:
+	puly
+	rts
+
+
+	
+;;;  si3 frontends for divmodsi3
+	
+	declare __divsi3
+	bsr	divmodsi
+	ret
+	
+	declare __modsi3
+
+	bsr 	divmodsi
+	ldx	ARG(2), sp	; stack has two less on it now
+	ldd	ARG(4), sp	
+	ret
+
+	declare __umodsi3
+	bsr 	udivmodsi
+	ldx	ARG(2), sp
+	ldd	ARG(4), sp	
+	ret
+	
+	
+	declare __udivsi3
+	bsr 	udivmodsi
+	ret
+	
+#endif
+
+.Lend:
+;-----------------------------------------
+; end required gcclib code
+;-----------------------------------------
--- /dev/null
+++ b/gcc/config/m68hc11/ldivmod.asm-s12x_only
@@ -0,0 +1,380 @@
+;;;-----------------------------------------
+
+;;;  Hand coded div and mod functions.
+;;;  AES 2009
+ 	
+;;;-----------------------------------------
+
+
+
+	
+	.file "ldivmod.asm"
+
+#ifdef __HAVE_SHORT_INT__
+	.mode mshort
+#else
+	.mode mlong
+#endif
+
+	.macro declare_near name
+	.globl \name
+	.type  \name,@function
+	.size  \name,.Lend-\name
+\name:
+	.endm
+
+#if defined(__USE_RTC__)
+# define ARG(N) N+1
+
+	.macro ret
+#if defined(mc68hc12)
+	rtc
+#else
+	jmp __return_32
+#endif
+	.endm
+
+	.macro declare name
+	.globl \name
+	.type  \name,@function
+	.size  \name,.Lend-\name
+	.far   \name
+\name:
+	.endm
+
+	.macro farsym name
+	.far NAME
+	.endm
+
+#else
+# define ARG(N) N
+
+	.macro ret
+	rts
+	.endm
+
+	.macro farsym name
+	.endm
+
+	.macro declare name
+	.globl \name
+	.type  \name,@function
+	.size  \name,.Lend-\name
+\name:
+	.endm
+
+#endif
+
+	.sect .text
+	
+
+#define REG(NAME)			\
+NAME:	.dc.w	1;			\
+	.type NAME,@object ;		\
+	.size NAME,2
+
+#ifdef L_regs_min
+/* Pseudo hard registers used by gcc.
+   They should be located in page0.  */
+
+	.sect .softregs
+	.globl _.tmp
+
+REG(_.tmp)
+#endif
+
+
+
+/* ok, guessing that we get called with a in D and X and B on stack */
+
+;;; 
+;;; long __divsi3 ( long num, long den )
+;;;
+
+;;; d == num_low
+;;; x == num_high
+
+;;; sp, ARG(4)  == den_high
+;;; sp, ARG(6)  == den_low
+;;; return result in XD
+
+;;; calling here we have also pushed 4 extra bytes on stack
+;;;  and we dont use a frame pointer
+
+
+udivmodsi:
+	pshy				; preserve y
+	pshd				; save numerator in case ediv fails
+	pshx
+	tstw 	ARG(10), sp		; does denominator fit in uint16 ?
+	bne 	go_soft_udivmodsi
+	tfr 	x,y			; load num_high into y
+	ldx	ARG(12), sp		; load denominator into x
+	ediv
+	bvs	go_soft_udivmodsi 	; overflow ??
+
+	;; overwrite denominator on stack with modulus
+	;; this is ok since c copies args onto stack  (???CHECKME)
+
+	std	ARG(12), sp
+	clrw 	ARG(10), sp
+
+	;; return division  results in X:D
+	clrx
+	tfr	y,d
+	
+	leas 	4, sp		  	; deallocate stack for numerator save
+	puly				; retrieve y
+	rts
+
+go_soft_udivmodsi:	
+	clry
+	bra 	soft_udivmodsi
+	
+
+divmodsi:	
+
+	pshy			; preserve y
+	pshd			; save numerator in case edivs fails
+	pshx
+	ldy	ARG(10),sp	; denominator fits in signed int16  ??
+	beq	test_pos
+	comy
+	beq	test_neg
+	bra	soft_divmodsi
+test_pos:	
+	ldy	ARG(12),sp
+	bpl	hard_divmodsi 	
+	bra	soft_divmodsi
+
+test_neg:
+	ldy	ARG(12),sp
+	bpl	soft_divmodsi
+	
+hard_divmodsi:
+	
+	exg 	x,y
+	edivs			; attempt a divide by hardware
+	bvs  	soft_divmodsi     	; an overflow happened ... do soft divide
+
+	clrw 	ARG(10),sp
+	std	ARG(12), sp
+	bpl	skip_hdsx_mod   ; sign extend modulus
+	movw	#0xFFFF, ARG(10), sp 	
+skip_hdsx_mod:	
+
+
+	;; returned division  results in X:D
+	clrx
+	tsty
+	bpl	skip_hdsx_div   ; sign extend result
+	ldx    #0xFFFF
+	
+skip_hdsx_div:	
+	tfr	y,d	
+	leas    4,sp		; deallocate stack
+	puly			; retrieve y
+	rts
+
+soft_divmodsi:
+	;; numerator in sp and sp+1 ; den in ARG(10) and ARG(12)
+	clry	              ; use y to evaluate sign of result
+	tstw	0, sp
+	bpl	sd_skip_neg_num
+
+	ory    #3
+	comw	2, sp
+	comw  	0, sp
+	incw	2, sp
+	bne	sd_skip_neg_num
+	incw	0, sp
+
+	
+sd_skip_neg_num:
+
+	tstw 	ARG(10), sp
+	bpl	sd_skip_neg_den
+
+	eory	#1
+	comw 	ARG(12), sp
+	comw 	ARG(10),  sp
+	incw	ARG(12), sp
+	bne	sd_skip_neg_den
+	incw	ARG(10),  sp
+	
+
+sd_skip_neg_den:
+soft_udivmodsi:	    		; if called from udivmodsi
+				; make sure y=0  
+	leas -8,sp		; allocate for 'bit' and 'res' 
+	
+	;; stack should look like this on entry if  ARG(N)=N:
+
+	;; 
+	;; 
+	;; 
+	;; denominator (SI)                             ---  sp+18
+	;; 
+	;; return address for calling function  (HI)   sp+16
+	;; 
+	;; return address for frontend  function (HI) sp+14
+	;;
+	;; preserve y	   ----  sp+12
+	;; 
+	;; 
+	;; 
+	;; numerator (SI)  ----  sp+8
+	;;
+	;;
+	;;
+	;; bit (SI)        ----  sp+4
+	;;
+	;; 
+	;; 
+	;; res (SI)        ----  sp
+	
+	clrw 	0, sp		; res = 0
+	clrw	2, sp
+
+	tstw	ARG(18),sp
+	bne     checked_den
+	tstw	ARG(20),sp
+	beq	while_end 	
+	
+checked_den:	
+
+	movw	#1, 6, sp
+	clrw	4,sp            ; bit = 1
+
+while_den:			; while ((den < num) && !(den.bit31))
+	tstw	ARG(18), sp
+	bmi 	while_bit
+	ldd	10,sp
+	ldx	8,sp
+
+	subd 	ARG(20), sp
+	sbex	ARG(18), sp
+	bcs	while_bit
+
+	aslw	ARG(20), sp     ;  den <<= 1
+	rolw	ARG(18), sp
+
+	aslw	6,sp		; bit <<= 1
+	rolw	4,sp			
+
+	bra	while_den
+
+
+while_bit:			; while  (bit!=0)
+	tstw	4, sp
+	bne	while_bit_ok
+	tstw	6,sp
+	beq	while_end
+
+while_bit_ok:
+	
+	ldd 	10, sp		; if (num >= den) 
+	ldx	8, sp
+	subd	ARG(20),sp
+	sbex	ARG(18),sp
+	bcs	skip_restore   	; here was bmi
+
+	std	10,sp		; num-=den
+	stx	8,sp
+
+	ldx	0,sp		; res|= bit
+	orx	4,sp
+	stx	0,sp
+	ldx	2,sp
+	orx	6,sp
+	stx	2,sp
+
+skip_restore:
+	
+	lsrw	4,sp 		; bit >>=1
+	rorw	6,sp		
+	
+	lsrw	ARG(18),sp		; den >>=1
+	rorw	ARG(20),sp
+	
+	bra while_bit
+	
+while_end:
+	;; numerator contains mod
+	;; overwrite denominator with it on stack for return
+//	movw	8,sp,ARG(18), sp 
+//	movw	10,sp, ARG(20), sp
+	leax	ARG(18), sp
+	movw	8,sp, 0,x
+	movw	10,sp, 2,x
+	
+	ldx	0,sp
+	ldd 	2,sp
+
+	leas	12,sp 		; deallocate locals
+	tsty			; do we need to negate result ?
+	beq	end_division    
+					
+	;; 	if y&1 then negate result
+	;; 	if y&2 then negate modulus
+
+	pshy
+	andy	#1
+	puly
+	beq	skip_end_res_neg
+	
+	coma
+	comb
+	comx
+	incb
+	bne	end_division
+	inca	
+	bne	end_division
+	incx	
+
+skip_end_res_neg:
+	andy	#2
+	beq	end_division
+
+	comw 	ARG(6), sp
+	comw 	ARG(8),  sp
+	incw	ARG(8), sp
+	bne	end_division
+	incw	ARG(6),  sp
+
+	
+end_division:
+	puly
+	rts
+
+
+	
+;;;  si3 frontends for divmodsi3
+	
+	declare __divsi3
+	bsr	divmodsi
+	ret
+	
+	declare __modsi3
+
+	bsr 	divmodsi
+	ldx	ARG(2), sp	; stack has two less on it now
+	ldd	ARG(4), sp	
+	ret
+
+	declare __umodsi3
+	bsr 	udivmodsi
+	ldx	ARG(2), sp
+	ldd	ARG(4), sp	
+	ret
+	
+	
+	declare __udivsi3
+	bsr 	udivmodsi
+	ret
+	
+
+.Lend:
+;-----------------------------------------
+; end required gcclib code
+;-----------------------------------------
--- a/gcc/config/m68hc11/m68hc11-crt0.S
+++ b/gcc/config/m68hc11/m68hc11-crt0.S
@@ -79,7 +79,7 @@
 ;; 
 ;;	int __premain(void);
 ;; 
-	jsr	__premain
+	bsr	__premain
 	
 ;;
 ;; 
--- a/gcc/config/m68hc11/m68hc11-protos.h
+++ b/gcc/config/m68hc11/m68hc11-protos.h
@@ -1,5 +1,6 @@
 /* Prototypes for exported functions defined in m68hc11.c
-   Copyright (C) 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
+   Copyright (C) 1999, 2000, 2001, 2002, 2003,
+   2005, 2006 Free Software Foundation, Inc.
    Contributed by Stephane Carrez (stcarrez@nerim.fr)
 
 This file is part of GNU CC.
@@ -24,7 +25,7 @@
 extern int m68hc11_optimization_options PARAMS((int,int));
 extern void m68hc11_conditional_register_usage PARAMS((void));
 extern int hard_regno_mode_ok PARAMS((int, enum machine_mode));
-extern int m68hc11_hard_regno_rename_ok PARAMS((int, int));
+extern int m68hc11_hard_regno_rename_ok PARAMS((int, int, int));
 
 extern int m68hc11_total_frame_size PARAMS((void));
 extern int m68hc11_initial_frame_pointer_offset PARAMS((void));
@@ -105,6 +106,7 @@
 extern int reg_or_indexed_operand PARAMS((rtx,enum machine_mode));
 extern int tst_operand PARAMS((rtx,enum machine_mode));
 extern int cmp_operand PARAMS((rtx,enum machine_mode));
+extern int nonimmediate_noinc_operand PARAMS((rtx,enum machine_mode));
 extern int memory_indexed_operand PARAMS((rtx, enum machine_mode));
 
 extern void m68hc11_split_logical PARAMS((enum machine_mode, int, rtx*));
@@ -147,6 +149,7 @@
 
 extern int m68hc11_is_far_symbol PARAMS((rtx));
 extern int m68hc11_is_trap_symbol PARAMS((rtx));
+extern int m68hc11_page0_symbol_p (rtx x);
 
 #endif /* TREE_CODE */
 
--- a/gcc/config/m68hc11/m68hc11.c
+++ b/gcc/config/m68hc11/m68hc11.c
@@ -1,21 +1,22 @@
 /* Subroutines for code generation on Motorola 68HC11 and 68HC12.
-   Copyright (C) 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
+   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+   Free Software Foundation, Inc.
    Contributed by Stephane Carrez (stcarrez@nerim.fr)
 
-This file is part of GNU CC.
+This file is part of GCC.
 
-GNU CC is free software; you can redistribute it and/or modify
+GCC is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation; either version 2, or (at your option)
 any later version.
 
-GNU CC is distributed in the hope that it will be useful,
+GCC is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
-along with GNU CC; see the file COPYING.  If not, write to
+along with GCC; see the file COPYING.  If not, write to
 the Free Software Foundation, 59 Temple Place - Suite 330,
 Boston, MA 02111-1307, USA.
 
@@ -70,6 +71,7 @@
 static int m68hc11_make_autoinc_notes PARAMS ((rtx*, void*));
 static int m68hc11_auto_inc_p PARAMS ((rtx));
 static tree m68hc11_handle_fntype_attribute PARAMS ((tree *, tree, tree, int, bool *));
+static tree m68hc11_handle_page0_attribute PARAMS ((tree *, tree, tree, int, bool *));
 const struct attribute_spec m68hc11_attribute_table[];
 
 void create_regs_rtx PARAMS ((void));
@@ -79,6 +81,7 @@
 static void m68hc11_asm_out_constructor PARAMS ((rtx, int));
 static void m68hc11_asm_out_destructor PARAMS ((rtx, int));
 static void m68hc11_encode_section_info PARAMS((tree, int));
+static const char *m68hc11_strip_name_encoding (const char* str);
 
 /* Must be set to 1 to produce debug messages.  */
 int debug_m6811 = 0;
@@ -129,6 +132,16 @@
    This is 1 for 68HC11 and 0 for 68HC12.  */
 int m68hc11_sp_correction;
 
+#define ADDR_STRICT       0x01  /* Accept only registers in class A_REGS  */
+#define ADDR_INCDEC       0x02  /* Post/Pre inc/dec */
+#define ADDR_INDEXED      0x04  /* D-reg index */
+#define ADDR_OFFSET       0x08
+#define ADDR_INDIRECT     0x10  /* Accept (mem (mem ...)) for [n,X] */
+#define ADDR_CONST        0x20  /* Accept const and symbol_ref  */
+
+int m68hc11_addr_mode;
+int m68hc11_mov_addr_mode;
+
 /* Comparison operands saved by the "tstxx" and "cmpxx" expand patterns.  */
 rtx m68hc11_compare_op0;
 rtx m68hc11_compare_op1;
@@ -227,6 +240,9 @@
 #undef TARGET_ENCODE_SECTION_INFO
 #define TARGET_ENCODE_SECTION_INFO  m68hc11_encode_section_info
 
+#undef TARGET_STRIP_NAME_ENCODING
+#define TARGET_STRIP_NAME_ENCODING m68hc11_strip_name_encoding
+
 struct gcc_target targetm = TARGET_INITIALIZER;
 
 int
@@ -264,6 +280,8 @@
       m68hc11_reg_valid_for_base[HARD_Z_REGNUM] = 1;
       m68hc11_sp_correction = 1;
       m68hc11_tmp_regs_class = D_REGS;
+      m68hc11_addr_mode = ADDR_OFFSET;
+      m68hc11_mov_addr_mode = 0;
       if (m68hc11_soft_reg_count == 0 && !TARGET_M6812)
 	m68hc11_soft_reg_count = "4";
     }
@@ -283,6 +301,10 @@
       m68hc11_reg_valid_for_index[HARD_D_REGNUM] = 1;
       m68hc11_sp_correction = 0;
       m68hc11_tmp_regs_class = TMP_REGS;
+      m68hc11_addr_mode = ADDR_INDIRECT | ADDR_OFFSET | ADDR_CONST
+        | (TARGET_AUTO_INC_DEC ? ADDR_INCDEC : 0);
+      m68hc11_mov_addr_mode = ADDR_OFFSET | ADDR_CONST
+        | (TARGET_AUTO_INC_DEC ? ADDR_INCDEC : 0);
       target_flags &= ~MASK_M6811;
       target_flags |= MASK_NO_DIRECT_MODE;
       if (m68hc11_soft_reg_count == 0)
@@ -316,7 +338,7 @@
   /* For 68HC12, the Z register emulation is not necessary when the
      frame pointer is not used.  The frame pointer is eliminated and
      replaced by the stack register (which is a BASE_REG_CLASS).  */
-  if (TARGET_M6812 && flag_omit_frame_pointer && optimize)
+  if (TARGET_M6812 && flag_omit_frame_pointer && optimize && 0)
     {
       fixed_regs[HARD_Z_REGNUM] = 1;
     }
@@ -385,8 +407,9 @@
 }
 
 int
-m68hc11_hard_regno_rename_ok (reg1, reg2)
+m68hc11_hard_regno_rename_ok (reg1, reg2, mode)
      int reg1, reg2;
+     int mode;
 {
   /* Don't accept renaming to Z register.  We will replace it to
      X,Y or D during machine reorg pass.  */
@@ -398,6 +421,11 @@
       && (D_REGNO_P (reg1) || X_REGNO_P (reg1)))
     return 0;
 
+  /* Don't rename D as if it holds a 8-bit value, the code will be
+     bigger.  */
+  if (mode == QImode && D_REGNO_P (reg1))
+    return 0;
+
   return 1;
 }
 
@@ -522,21 +550,25 @@
    For 68hc11:  n,r    with n in [0..255] and r in A_REGS class
    For 68hc12:  n,r    no constraint on the constant, r in A_REGS class.  */
 static int
-register_indirect_p (operand, mode, strict)
-     rtx operand;
-     enum machine_mode mode;
-     int strict;
+register_indirect_p (rtx operand, enum machine_mode mode, int addr_mode)
 {
   rtx base, offset;
 
   switch (GET_CODE (operand))
     {
+    case MEM:
+      if ((addr_mode & ADDR_INDIRECT) && GET_MODE_SIZE (mode) <= 2)
+        return register_indirect_p (XEXP (operand, 0), mode,
+                                    addr_mode & (ADDR_STRICT | ADDR_OFFSET));
+      return 0;
+
     case POST_INC:
     case PRE_INC:
     case POST_DEC:
     case PRE_DEC:
-      if (TARGET_M6812 && TARGET_AUTO_INC_DEC)
-	return register_indirect_p (XEXP (operand, 0), mode, strict);
+      if (addr_mode & ADDR_INCDEC)
+	return register_indirect_p (XEXP (operand, 0), mode,
+                                    addr_mode & ADDR_STRICT);
       return 0;
 
     case PLUS:
@@ -548,36 +580,57 @@
       if (GET_CODE (offset) == MEM)
 	return 0;
 
+      /* Indexed addressing mode with 2 registers.  */
+      if (GET_CODE (base) == REG && GET_CODE (offset) == REG)
+        {
+          if (!(addr_mode & ADDR_INDEXED))
+            return 0;
+
+          addr_mode &= ADDR_STRICT;
+          if (REGNO_OK_FOR_BASE_P2 (REGNO (base), addr_mode)
+              && REGNO_OK_FOR_INDEX_P2 (REGNO (offset), addr_mode))
+            return 1;
+
+          if (REGNO_OK_FOR_BASE_P2 (REGNO (offset), addr_mode)
+              && REGNO_OK_FOR_INDEX_P2 (REGNO (base), addr_mode))
+            return 1;
+
+          return 0;
+        }
+
+      if (!(addr_mode & ADDR_OFFSET))
+        return 0;
+
       if (GET_CODE (base) == REG)
 	{
-	  if (!VALID_CONSTANT_OFFSET_P (offset, mode))
+          if (!VALID_CONSTANT_OFFSET_P (offset, mode))
 	    return 0;
 
-	  if (strict == 0)
+	  if (!(addr_mode & ADDR_STRICT))
 	    return 1;
 
-	  return REGNO_OK_FOR_BASE_P2 (REGNO (base), strict);
+	  return REGNO_OK_FOR_BASE_P2 (REGNO (base), 1);
 	}
+
       if (GET_CODE (offset) == REG)
 	{
 	  if (!VALID_CONSTANT_OFFSET_P (base, mode))
 	    return 0;
 
-	  if (strict == 0)
+	  if (!(addr_mode & ADDR_STRICT))
 	    return 1;
 
-	  return REGNO_OK_FOR_BASE_P2 (REGNO (offset), strict);
+	  return REGNO_OK_FOR_BASE_P2 (REGNO (offset), 1);
 	}
       return 0;
 
     case REG:
-      return REGNO_OK_FOR_BASE_P2 (REGNO (operand), strict);
+      return REGNO_OK_FOR_BASE_P2 (REGNO (operand), addr_mode & ADDR_STRICT);
 
     case CONST_INT:
-      if (TARGET_M6811)
-        return 0;
-
-      return VALID_CONSTANT_OFFSET_P (operand, mode);
+      if (addr_mode & ADDR_CONST)
+        return VALID_CONSTANT_OFFSET_P (operand, mode);
+      return 0;
 
     default:
       return 0;
@@ -592,6 +645,7 @@
      enum machine_mode mode;
 {
   rtx base, offset;
+  int addr_mode;
 
   if (GET_CODE (operand) == REG && reload_in_progress
       && REGNO (operand) >= FIRST_PSEUDO_REGISTER
@@ -611,7 +665,8 @@
   if (PUSH_POP_ADDRESS_P (operand))
     return 1;
 
-  if (!register_indirect_p (operand, mode, reload_completed))
+  addr_mode = m68hc11_mov_addr_mode | (reload_completed ? ADDR_STRICT : 0);
+  if (!register_indirect_p (operand, mode, addr_mode))
     return 0;
 
   if (TARGET_M6812 && GET_CODE (operand) == PLUS
@@ -654,12 +709,21 @@
      rtx operand;
      enum machine_mode mode;
 {
+  int addr_mode;
+
+  if (GET_CODE (operand) == REG && reload_in_progress
+      && REGNO (operand) >= FIRST_PSEUDO_REGISTER
+      && reg_equiv_memory_loc[REGNO (operand)])
+    {
+      operand = reg_equiv_memory_loc[REGNO (operand)];
+      operand = eliminate_regs (operand, 0, NULL_RTX);
+    }
   if (GET_CODE (operand) != MEM)
     return 0;
 
   operand = XEXP (operand, 0);
-  return register_indirect_p (operand, mode,
-                              (reload_completed | reload_in_progress));
+  addr_mode = m68hc11_addr_mode | (reload_completed ? ADDR_STRICT : 0);
+  return register_indirect_p (operand, mode, addr_mode);
 }
 
 static int
@@ -668,6 +732,8 @@
      enum machine_mode mode;
      int strict;
 {
+  int addr_mode;
+
   if (CONSTANT_ADDRESS_P (operand) && TARGET_M6812)
     {
       /* Reject the global variables if they are too wide.  This forces
@@ -677,7 +743,8 @@
 
       return 1;
     }
-  if (register_indirect_p (operand, mode, strict))
+  addr_mode = m68hc11_addr_mode | (strict ? ADDR_STRICT : 0);
+  if (register_indirect_p (operand, mode, addr_mode))
     {
       return 1;
     }
@@ -930,6 +997,27 @@
   return general_operand (operand, mode);
 }
 
+/* Predicate for nonimmediate operands but which rejects the
+   auto-increment/decrement modes.  We must use this predicate
+   for operand 0 (and sometimes operand 1) when an insn can have
+   an operand that would create a RELOAD_OTHER in which a reload
+   part (RELOAD_FOR_OUTPUT_ADDRESS) could be created.  When this
+   happens, the RELOAD_FOR_OUTPUT_ADDRESS is emitted after the RELOAD_OTHER
+   and this will not be valid.  */
+int
+nonimmediate_noinc_operand (operand, mode)
+     rtx operand;
+     enum machine_mode mode;
+{
+  if (GET_CODE (operand) == MEM)
+    {
+      rtx addr = XEXP (operand, 0);
+      if (m68hc11_auto_inc_p (addr))
+	return 0;
+    }
+  return nonimmediate_operand (operand, mode);
+}
+
 int
 non_push_operand (operand, mode)
      rtx operand;
@@ -944,6 +1032,43 @@
 }
 
 int
+splitable_operand (operand, mode)
+     rtx operand;
+     enum machine_mode mode;
+{
+  if (general_operand (operand, mode) == 0)
+    return 0;
+
+  if (push_operand (operand, mode) == 1)
+    return 0;
+
+  /* Reject a (MEM (MEM X)) because the patterns that use non_push_operand
+     need to split such addresses to access the low and high part but it
+     is not possible to express a valid address for the low part.  */
+  if (mode != QImode && GET_CODE (operand) == MEM
+      && GET_CODE (XEXP (operand, 0)) == MEM)
+    return 0;
+  return 1;
+}
+
+int
+push_or_splitable_operand (operand, mode)
+     rtx operand;
+     enum machine_mode mode;
+{
+  if (general_operand (operand, mode) == 0)
+    return 0;
+
+  /* Reject a (MEM (MEM X)) because the patterns that use non_push_operand
+     need to split such addresses to access the low and high part but it
+     is not possible to express a valid address for the low part.  */
+  if (mode != QImode && GET_CODE (operand) == MEM
+      && GET_CODE (XEXP (operand, 0)) == MEM)
+    return 0;
+  return 1;
+}
+
+int
 reg_or_some_mem_operand (operand, mode)
      rtx operand;
      enum machine_mode mode;
@@ -951,6 +1076,7 @@
   if (GET_CODE (operand) == MEM)
     {
       rtx op = XEXP (operand, 0);
+      int addr_mode;
 
       if (symbolic_memory_operand (op, mode))
 	return 1;
@@ -958,10 +1084,20 @@
       if (IS_STACK_PUSH (operand))
 	return 1;
 
-      if (m68hc11_register_indirect_p (operand, mode))
-	return 1;
+      if (GET_CODE (operand) == REG && reload_in_progress
+          && REGNO (operand) >= FIRST_PSEUDO_REGISTER
+          && reg_equiv_memory_loc[REGNO (operand)])
+         {
+            operand = reg_equiv_memory_loc[REGNO (operand)];
+            operand = eliminate_regs (operand, 0, NULL_RTX);
+         }
+      if (GET_CODE (operand) != MEM)
+         return 0;
 
-      return 0;
+      operand = XEXP (operand, 0);
+      addr_mode = m68hc11_addr_mode | (reload_completed ? ADDR_STRICT : 0);
+      addr_mode &= ~ADDR_INDIRECT;
+      return register_indirect_p (operand, mode, addr_mode);
     }
 
   return register_operand (operand, mode);
@@ -987,18 +1123,23 @@
      rtx operand;
      enum machine_mode mode;
 {
-  if (GET_CODE (operand) == MEM)
+  if (GET_CODE (operand) == MEM && GET_MODE (operand) == mode)
     {
       rtx op = XEXP (operand, 0);
+      int addr_mode;
+
+      if (m68hc11_page0_symbol_p (op))
+        return 1;
 
       if (symbolic_memory_operand (op, mode))
-	return 0;
+	return TARGET_M6812;
 
       if (reload_in_progress)
         return 1;
 
       operand = XEXP (operand, 0);
-      return register_indirect_p (operand, mode, reload_completed);
+      addr_mode = m68hc11_addr_mode | (reload_completed ? ADDR_STRICT : 0);
+      return register_indirect_p (operand, mode, addr_mode);
     }
   return 0;
 }
@@ -1234,6 +1375,31 @@
 
 /* Declaration of types.  */
 
+/* Handle an "tiny_data" attribute; arguments as in
+   struct attribute_spec.handler.  */
+static tree
+m68hc11_handle_page0_attribute (node, name, args, flags, no_add_attrs)
+     tree *node;
+     tree name;
+     tree args ATTRIBUTE_UNUSED;
+     int flags ATTRIBUTE_UNUSED;
+     bool *no_add_attrs;
+{
+  tree decl = *node;
+
+  if (TREE_STATIC (decl) || DECL_EXTERNAL (decl))
+    {
+      DECL_SECTION_NAME (decl) = build_string (6, ".page0");
+    }
+  else
+    {
+      warning ("`%s' attribute ignored", IDENTIFIER_POINTER (name));
+      *no_add_attrs = true;
+    }
+
+  return NULL_TREE;
+}
+
 const struct attribute_spec m68hc11_attribute_table[] =
 {
   /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */
@@ -1241,6 +1407,7 @@
   { "trap",      0, 0, false, true,  true,  m68hc11_handle_fntype_attribute },
   { "far",       0, 0, false, true,  true,  m68hc11_handle_fntype_attribute },
   { "near",      0, 0, false, true,  true,  m68hc11_handle_fntype_attribute },
+  { "page0",     0, 0, false, false, false, m68hc11_handle_page0_attribute },
   { NULL,        0, 0, false, false, false, NULL }
 };
 
@@ -1271,6 +1438,52 @@
 
   return NULL_TREE;
 }
+/* Undo the effects of the above.  */
+
+static const char *
+m68hc11_strip_name_encoding (str)
+     const char *str;
+{
+  return str + (*str == '*' || *str == '@' || *str == '&');
+}
+
+static void
+m68hc11_encode_label (tree decl)
+{
+  const char *str = XSTR (XEXP (DECL_RTL (decl), 0), 0);
+  int len = strlen (str);
+  char *newstr = alloca (len + 2);
+
+  newstr[0] = '@';
+  strcpy (&newstr[1], str);
+
+  XSTR (XEXP (DECL_RTL (decl), 0), 0) = ggc_alloc_string (newstr, len + 1);
+}
+
+/* Return 1 if this is a symbol in page0  */
+int
+m68hc11_page0_symbol_p (rtx x)
+{
+  switch (GET_CODE (x))
+    {
+    case SYMBOL_REF:
+      return XSTR (x, 0) != 0 && XSTR (x, 0)[0] == '@';
+
+    case CONST:
+      return m68hc11_page0_symbol_p (XEXP (x, 0));
+
+    case PLUS:
+      if (!m68hc11_page0_symbol_p (XEXP (x, 0)))
+        return 0;
+
+      return GET_CODE (XEXP (x, 1)) == CONST_INT
+        && INTVAL (XEXP (x, 1)) < 256
+        && INTVAL (XEXP (x, 1)) >= 0;
+
+    default:
+      return 0;
+    }
+}
 
 /* We want to recognize trap handlers so that we handle calls to traps
    in a special manner (by issuing the trap).  This information is stored
@@ -1286,6 +1499,13 @@
   int is_far = 0;
   rtx rtl;
   
+  if (TREE_CODE (decl) == VAR_DECL)
+    {
+      if (lookup_attribute ("page0", DECL_ATTRIBUTES (decl)) != 0)
+        m68hc11_encode_label (decl);
+      return;
+    }
+
   if (TREE_CODE (decl) != FUNCTION_DECL)
     return;
 
@@ -1372,15 +1592,19 @@
   /* For a trap handler, we must take into account the registers which
      are pushed on the stack during the trap (except the PC).  */
   func_attr = TYPE_ATTRIBUTES (TREE_TYPE (current_function_decl));
+  current_function_interrupt = lookup_attribute ("interrupt",
+						 func_attr) != NULL_TREE;
+  trap_handler = lookup_attribute ("trap", func_attr) != NULL_TREE;
 
   if (lookup_attribute ("far", func_attr) != 0)
     current_function_far = 1;
   else if (lookup_attribute ("near", func_attr) != 0)
     current_function_far = 0;
   else
-    current_function_far = TARGET_LONG_CALLS != 0;
+    current_function_far = (TARGET_LONG_CALLS != 0
+                            && !current_function_interrupt
+                            && !trap_handler);
 
-  trap_handler = lookup_attribute ("trap", func_attr) != NULL_TREE;
   if (trap_handler && from == ARG_POINTER_REGNUM)
     size = 7;
 
@@ -1679,7 +1903,9 @@
   else if (lookup_attribute ("near", func_attr) != NULL_TREE)
     current_function_far = 0;
   else
-    current_function_far = TARGET_LONG_CALLS != 0;
+    current_function_far = (TARGET_LONG_CALLS != 0
+                            && !current_function_interrupt
+                            && !current_function_trap);
 
   /* Get the scratch register to build the frame and push registers.
      If the first argument is a 32-bit quantity, the D+X registers
@@ -2014,6 +2240,14 @@
 	{
 	  return gen_int_mode (val >> 16, HImode);
 	}
+      else if (mode == SImode)
+       {
+#if HOST_BITS_PER_WIDE_INT > 32
+         return gen_int_mode (val >> 32, SImode);
+#else
+         return (val >= 0) ? const0_rtx : constm1_rtx;
+#endif
+       }
     }
   if (mode == QImode && D_REG_P (x))
     return gen_rtx (REG, mode, HARD_A_REGNUM);
@@ -2307,7 +2541,21 @@
 	    abort ();
 	  break;
 
+        case MEM:
+          if (TARGET_M6812)
+            {
+              fprintf (file, "[");
+              print_operand_address (file, XEXP (base, 0));
+              fprintf (file, "]");
+            }
+          else
+            abort ();
+          break;
+
 	default:
+          if (m68hc11_page0_symbol_p (base))
+            fprintf (file, "*");
+
 	  output_address (base);
 	  break;
 	}
@@ -2349,7 +2597,7 @@
 }
 
 /* Returns true if the operand 'op' must be printed with parenthesis
-   arround it.  This must be done only if there is a symbol whose name
+   around it.  This must be done only if there is a symbol whose name
    is a processor register.  */
 static int
 must_parenthesize (op)
@@ -2903,15 +3151,7 @@
   high_to = m68hc11_gen_highpart (mode, to);
 
   low_from = m68hc11_gen_lowpart (mode, from);
-  if (mode == SImode && GET_CODE (from) == CONST_INT)
-    {
-      if (INTVAL (from) >= 0)
-	high_from = const0_rtx;
-      else
-	high_from = constm1_rtx;
-    }
-  else
-    high_from = m68hc11_gen_highpart (mode, from);
+  high_from = m68hc11_gen_highpart (mode, from);
 
   if (offset)
     {
@@ -3104,26 +3344,8 @@
   low[2] = m68hc11_gen_lowpart (mode, operands[2]);
 
   high[0] = m68hc11_gen_highpart (mode, operands[0]);
-
-  if (mode == SImode && GET_CODE (operands[1]) == CONST_INT)
-    {
-      if (INTVAL (operands[1]) >= 0)
-	high[1] = const0_rtx;
-      else
-	high[1] = constm1_rtx;
-    }
-  else
-    high[1] = m68hc11_gen_highpart (mode, operands[1]);
-
-  if (mode == SImode && GET_CODE (operands[2]) == CONST_INT)
-    {
-      if (INTVAL (operands[2]) >= 0)
-	high[2] = const0_rtx;
-      else
-	high[2] = constm1_rtx;
-    }
-  else
-    high[2] = m68hc11_gen_highpart (mode, operands[2]);
+  high[1] = m68hc11_gen_highpart (mode, operands[1]);
+  high[2] = m68hc11_gen_highpart (mode, operands[2]);
 
   low[3] = operands[3];
   high[3] = operands[3];
@@ -3236,10 +3458,13 @@
 
   if (TARGET_M6812)
     {
-      if (IS_STACK_PUSH (operands[0]) && H_REG_P (operands[1]))
+      rtx from = operands[1];
+      rtx to = operands[0];
+
+      if (IS_STACK_PUSH (to) && H_REG_P (from))
 	{
           cc_status = cc_prev_status;
-	  switch (REGNO (operands[1]))
+	  switch (REGNO (from))
 	    {
 	    case HARD_X_REGNUM:
 	    case HARD_Y_REGNUM:
@@ -3247,17 +3472,17 @@
 	      output_asm_insn ("psh%1", operands);
 	      break;
             case HARD_SP_REGNUM:
-              output_asm_insn ("sts\t-2,sp", operands);
+              output_asm_insn ("sts\t2,-sp", operands);
               break;
 	    default:
 	      abort ();
 	    }
 	  return;
 	}
-      if (IS_STACK_POP (operands[1]) && H_REG_P (operands[0]))
+      if (IS_STACK_POP (from) && H_REG_P (to))
 	{
           cc_status = cc_prev_status;
-	  switch (REGNO (operands[0]))
+	  switch (REGNO (to))
 	    {
 	    case HARD_X_REGNUM:
 	    case HARD_Y_REGNUM:
@@ -3278,17 +3503,6 @@
 	{
 	  if (SP_REG_P (operands[0]))
 	    output_asm_insn ("lds\t%1", operands);
-	  else if (0 /* REG_WAS_0 note is boggus;  don't rely on it.  */
-                   && !D_REG_P (operands[0])
-                   && GET_CODE (operands[1]) == CONST_INT
-                   && (INTVAL (operands[1]) == 1 || INTVAL (operands[1]) == -1)
-                   && find_reg_note (insn, REG_WAS_0, 0))
-            {
-              if (INTVAL (operands[1]) == 1)
-                output_asm_insn ("in%0", operands);
-              else
-                output_asm_insn ("de%0", operands);
-            }
 	  else
 	    output_asm_insn ("ld%0\t%1", operands);
 	}
@@ -3299,11 +3513,59 @@
 	  else
 	    output_asm_insn ("st%1\t%0", operands);
 	}
+
+      /* The 68hc12 does not support (MEM:HI (MEM:HI)) with the movw
+         instruction.  We have to use a scratch register as temporary location.
+         Trying to use a specific pattern or constrain failed.  */
+      else if (GET_CODE (to) == MEM && GET_CODE (XEXP (to, 0)) == MEM)
+        {
+          rtx ops[4];
+
+          ops[0] = to;
+          ops[2] = from;
+          ops[3] = 0;
+          if (dead_register_here (insn, d_reg))
+            ops[1] = d_reg;
+          else if (dead_register_here (insn, ix_reg))
+            ops[1] = ix_reg;
+          else if (dead_register_here (insn, iy_reg))
+            ops[1] = iy_reg;
+          else
+            {
+              ops[1] = d_reg;
+              ops[3] = d_reg;
+              output_asm_insn ("psh%3", ops);
+            }
+
+          ops[0] = to;
+          ops[2] = from;
+          output_asm_insn ("ld%1\t%2", ops);
+          output_asm_insn ("st%1\t%0", ops);
+          if (ops[3])
+            output_asm_insn ("pul%3", ops);
+        }
+
+      /* Use movw for non-null constants or when we are clearing
+         a volatile memory reference.  However, this is possible
+         only if the memory reference has a small offset or is an
+         absolute address.  */
+      else if (GET_CODE (from) == CONST_INT
+               && INTVAL (from) == 0
+               && (MEM_VOLATILE_P (to) == 0
+                   || m68hc11_small_indexed_indirect_p (to, HImode) == 0))
+        {
+          if (TARGET_M68S12X)
+          {
+            output_asm_insn ("clrw\t%0", operands);
+          }
+          else
+          {
+          output_asm_insn ("clr\t%h0", operands);
+          output_asm_insn ("clr\t%b0", operands);
+          }
+        }
       else
 	{
-	  rtx from = operands[1];
-	  rtx to = operands[0];
-
 	  if ((m68hc11_register_indirect_p (from, GET_MODE (from))
 	       && !m68hc11_small_indexed_indirect_p (from, GET_MODE (from)))
 	      || (m68hc11_register_indirect_p (to, GET_MODE (to))
@@ -3320,6 +3582,7 @@
 		  ops[0] = to;
 		  ops[1] = operands[2];
 		  m68hc11_gen_movhi (insn, ops);
+                  return;
 		}
 	      else
 		{
@@ -3327,19 +3590,11 @@
                   fatal_insn ("move insn not handled", insn);
 		}
 	    }
-	  else
-	    {
-	      if (GET_CODE (from) == CONST_INT && INTVAL (from) == 0)
-		{
-		  output_asm_insn ("clr\t%h0", operands);
-		  output_asm_insn ("clr\t%b0", operands);
-		}
-	      else
-		{
-                  m68hc11_notice_keep_cc (operands[0]);
-		  output_asm_insn ("movw\t%1,%0", operands);
-		}
-	    }
+          else
+            {
+              m68hc11_notice_keep_cc (operands[0]);
+              output_asm_insn ("movw\t%1,%0", operands);
+            }
 	}
       return;
     }
@@ -3472,16 +3727,6 @@
 	      cc_status = cc_prev_status;
 	      output_asm_insn ("tsx", operands);
 	    }
-	  else if (0 /* REG_WAS_0 note is boggus;  don't rely on it.  */
-                   && GET_CODE (operands[1]) == CONST_INT
-                   && (INTVAL (operands[1]) == 1 || INTVAL (operands[1]) == -1)
-                   && find_reg_note (insn, REG_WAS_0, 0))
-            {
-              if (INTVAL (operands[1]) == 1)
-                output_asm_insn ("in%0", operands);
-              else
-                output_asm_insn ("de%0", operands);
-            }
 	  else
 	    {
 	      output_asm_insn ("ldx\t%1", operands);
@@ -3530,16 +3775,6 @@
 	      cc_status = cc_prev_status;
 	      output_asm_insn ("tsy", operands);
 	    }
-	  else if (0 /* REG_WAS_0 note is boggus;  don't rely on it.  */
-                   && GET_CODE (operands[1]) == CONST_INT
-                   && (INTVAL (operands[1]) == 1 || INTVAL (operands[1]) == -1)
-                   && find_reg_note (insn, REG_WAS_0, 0))
-            {
-              if (INTVAL (operands[1]) == 1)
-                output_asm_insn ("in%0", operands);
-              else
-                output_asm_insn ("de%0", operands);
-            }
           else
 	    {
 	      output_asm_insn ("ldy\t%1", operands);
@@ -3689,8 +3924,10 @@
 	}
       else if (H_REG_P (operands[0]))
 	{
-	  if (Q_REG_P (operands[0]))
-	    output_asm_insn ("lda%0\t%b1", operands);
+          if (IS_STACK_POP (operands[1]))
+            output_asm_insn ("pul%b0", operands);
+	  else if (Q_REG_P (operands[0]))
+            output_asm_insn ("lda%0\t%b1", operands);
 	  else if (D_REG_P (operands[0]))
 	    output_asm_insn ("ldab\t%b1", operands);
 	  else
@@ -3780,16 +4017,6 @@
 		  output_asm_insn ("ldab\t%T0", operands);
 		}
 	    }
-	  else if (0 /* REG_WAS_0 note is boggus;  don't rely on it.  */
-                   && GET_CODE (operands[1]) == CONST_INT
-                   && (INTVAL (operands[1]) == 1 || INTVAL (operands[1]) == -1)
-                   && find_reg_note (insn, REG_WAS_0, 0))
-            {
-              if (INTVAL (operands[1]) == 1)
-                output_asm_insn ("inc%b0", operands);
-              else
-                output_asm_insn ("dec%b0", operands);
-            }          
 	  else if (!DB_REG_P (operands[1]) && !D_REG_P (operands[1])
 		   && !DA_REG_P (operands[1]))
 	    {
@@ -3935,11 +4162,34 @@
 	  break;
 
 	case HARD_X_REGNUM:
-	  output_asm_insn ("xgdx\n\tstab\t%b0\n\txgdx", operands);
-	  break;
-
-	case HARD_Y_REGNUM:
-	  output_asm_insn ("xgdy\n\tstab\t%b0\n\txgdy", operands);
+        case HARD_Y_REGNUM:
+	  if (!reg_mentioned_p (operands[1], operands[0]))
+	    {
+              output_asm_insn ("xgd%1\n\tstab\t%b0\n\txgd%1", operands);
+            }
+          else if (TARGET_M6811)
+            {
+              int dead = dead_register_here (insn, d_reg);
+	      output_asm_insn ("st%1\t%t1", operands);
+              if (!dead)
+                output_asm_insn ("psha", operands);
+	      output_asm_insn ("ldaa\t%T1", operands);
+	      output_asm_insn ("staa\t%0", operands);
+              if (!dead)
+                output_asm_insn ("pula", operands);
+	      CC_STATUS_INIT;
+            }
+          else
+            {
+              int dead = dead_register_here (insn, d_reg);
+              if (!dead)
+                output_asm_insn ("psha", operands);
+	      output_asm_insn ("tfr\t%1,a", operands);
+	      output_asm_insn ("staa\t%0", operands);
+              if (!dead)
+                output_asm_insn ("pulb", operands);
+	      CC_STATUS_INIT;
+            }
 	  break;
 
 	default:
@@ -4136,6 +4386,12 @@
       && cc_status.value2
       && reg_overlap_mentioned_p (cc_status.value1, cc_status.value2))
     cc_status.value2 = 0;
+
+  else if (cc_status.value1 && side_effects_p (cc_status.value1))
+    cc_status.value1 = 0;
+
+  else if (cc_status.value2 && side_effects_p (cc_status.value2))
+    cc_status.value2 = 0;
 }
 
 /* The current instruction does not affect the flags but changes
@@ -4306,8 +4562,10 @@
 	{
 	  if ((GET_CODE (src) == REG && REGNO (src) == HARD_Z_REGNUM)
 	      || (GET_CODE (src) == COMPARE &&
-		  (rtx_equal_p (XEXP (src, 0), z_reg)
-		   || rtx_equal_p (XEXP (src, 1), z_reg))))
+		  ((rtx_equal_p (XEXP (src, 0), z_reg)
+                    && H_REG_P (XEXP (src, 1)))
+		   || (rtx_equal_p (XEXP (src, 1), z_reg)
+                       && H_REG_P (XEXP (src, 0))))))
 	    {
 	      if (insn == info->first)
 		{
@@ -4905,7 +5163,7 @@
 /* The insn uses the Z register.  Find a replacement register for it
    (either X or Y) and replace it in the insn and the next ones until
    the flow changes or the replacement register is used.  Instructions
-   are emited before and after the Z-block to preserve the value of
+   are emitted before and after the Z-block to preserve the value of
    Z and of the replacement register.  */
 
 static void
@@ -5067,9 +5325,11 @@
       if (info.save_before_last)
 	save_pos_insn = PREV_INSN (save_pos_insn);
 
-      emit_insn_before (gen_movhi (gen_rtx (REG, HImode, SOFT_Z_REGNUM),
-				   gen_rtx (REG, HImode, info.regno)),
-			save_pos_insn);
+      /* Use emit_insn_after () to ensure the new insn is part of
+         the good basic block.  */
+      emit_insn_after (gen_movhi (gen_rtx (REG, HImode, SOFT_Z_REGNUM),
+                                  gen_rtx (REG, HImode, info.regno)),
+                       PREV_INSN (save_pos_insn));
     }
 
   if (info.must_push_reg && info.last)
@@ -5108,8 +5368,8 @@
       else
 	dst = gen_rtx (REG, HImode, SOFT_SAVED_XY_REGNUM);
 
-      emit_insn_before (gen_movhi (gen_rtx (REG, HImode, info.regno),
-				   dst), insn);
+      emit_insn_after (gen_movhi (gen_rtx (REG, HImode, info.regno),
+                                  dst), PREV_INSN (insn));
     }
 
 }
@@ -5176,6 +5436,13 @@
 }
 
 
+/* Machine-dependent reorg pass.
+   Specific optimizations are defined here:
+    - this pass changes the Z register into either X or Y
+      (it preserves X/Y previous values in a memory slot in page0).
+
+   When this pass is finished, the global variable
+   'z_replacement_completed' is set to 2.  */
 void
 m68hc11_reorg (first)
      rtx first;
@@ -5204,7 +5471,7 @@
   z_replacement_completed = 1;
   m68hc11_reassign_regs (first);
 
-  /* After some splitting, there are some oportunities for CSE pass.
+  /* After some splitting, there are some opportunities for CSE pass.
      This happens quite often when 32-bit or above patterns are split.  */
   if (optimize > 0 && split_done)
     {
@@ -5355,7 +5622,7 @@
       break;
 
     case SYMBOL_REF:
-      cost = 8;
+      cost = m68hc11_page0_symbol_p (addr) ? 0 : 8;
       break;
 
     case LABEL_REF:
@@ -5388,7 +5655,7 @@
 	    break;
 
 	  case SYMBOL_REF:
-	    cost = 8;
+	    cost = m68hc11_page0_symbol_p (addr) ? 0 : 8;
 	    break;
 
 	  case CONST:
--- a/gcc/config/m68hc11/m68hc11.h
+++ b/gcc/config/m68hc11/m68hc11.h
@@ -1,22 +1,23 @@
 /* Definitions of target machine for GNU compiler.
    Motorola 68HC11 and 68HC12.
-   Copyright (C) 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
+   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004,
+   2005, 2006 Free Software Foundation, Inc.
    Contributed by Stephane Carrez (stcarrez@nerim.fr)
 
-This file is part of GNU CC.
+This file is part of GCC.
 
-GNU CC is free software; you can redistribute it and/or modify
+GCC is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation; either version 2, or (at your option)
 any later version.
 
-GNU CC is distributed in the hope that it will be useful,
+GCC is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
-along with GNU CC; see the file COPYING.  If not, write to
+along with GCC; see the file COPYING.  If not, write to
 the Free Software Foundation, 59 Temple Place - Suite 330,
 Boston, MA 02111-1307, USA.
 
@@ -41,24 +42,28 @@
 
 #undef ENDFILE_SPEC
 
-/* Compile and assemble for a 68hc11 unless there is a -m68hc12 option.  */
+/* Default to compile and assemble for a 68hc11 */
+/* convert parameter style from 'cc1' to 'as' */
 #ifndef ASM_SPEC
 #define ASM_SPEC                                                \
 "%{m68hc12:-m68hc12}"                                           \
 "%{m68hcs12:-m68hcs12}"                                         \
-"%{!m68hc12:%{!m68hcs12:-m68hc11}} "                            \
+"%{m9s12x:-mm9s12x}"                                             \
+"%{!m68hc12:%{!m68hcs12:%{!m9s12x:-m68hc11}}} "                 \
 "%{mshort:-mshort}%{!mshort:-mlong} "                           \
 "%{fshort-double:-mshort-double}%{!fshort-double:-mlong-double}"
 #endif
 
 /* We need to tell the linker the target elf format.  Just pass an
-   emulation option.  This can be overriden by -Wl option of gcc.  */
+   emulation option.  This can be overridden by -Wl option of gcc.  */
 #ifndef LINK_SPEC
 #define LINK_SPEC                                               \
 "%{m68hc12:-m m68hc12elf}"                                      \
 "%{m68hcs12:-m m68hc12elf}"                                     \
-"%{!m68hc12:%{!m68hcs12:-m m68hc11elf}} "                       \
-"%{!mnorelax:%{!m68hc12:%{!m68hcs12:-relax}}}"
+"%{m9s12x:-m m9s12x}"                                           \
+"%{!m68hc12:%{!m68hcs12:%{!m9s12x:-m m68hc11elf}}} "            \
+"%{!mnorelax:%{!m68hc12:%{!m68hcs12:%{!m9s12x:-relax}}}}"
+
 #endif
 
 #ifndef LIB_SPEC
@@ -75,7 +80,8 @@
  %{!mshort:-D__INT__=32}\
  %{m68hc12:-Dmc6812 -DMC6812 -Dmc68hc12}\
  %{m68hcs12:-Dmc6812 -DMC6812 -Dmc68hcs12}\
- %{!m68hc12:%{!m68hcs12:-Dmc6811 -DMC6811 -Dmc68hc11}}\
+ %{m9s12x:-Dmc6812 -DMC6812 -Dmc68hc12 -Dmc68hcs12 -Dm9s12x -m9s12x}\
+ %{!m68hc12:%{!m68hcs12:%{!m9s12x:-Dmc6811 -DMC6811 -Dmc68hc11}}}\
  %{fshort-double:-D__HAVE_SHORT_DOUBLE__}\
  %{mlong-calls:-D__USE_RTC__}"
 #endif
@@ -84,7 +90,9 @@
 #define STARTFILE_SPEC "crt1%O%s"
 
 /* Names to predefine in the preprocessor for this target machine.  */
-#define CPP_PREDEFINES		"-Dmc68hc1x"
+#ifndef CPP_PREDEFINES
+#define CPP_PREDEFINES		"-Dmc68hc1x -Dtarget11"
+#endif
 
 /* As an embedded target, we have no libc.  */
 #define inhibit_libc
@@ -125,20 +133,22 @@
  * with -mauto-incdec.
  */
 
-#define MASK_SHORT              0002	/* Compile with 16-bit `int' */
-#define MASK_AUTO_INC_DEC       0004
-#define MASK_M6811              0010
-#define MASK_M6812              0020
-#define MASK_M68S12             0040
-#define MASK_NO_DIRECT_MODE     0100
-#define MASK_MIN_MAX            0200
-#define MASK_LONG_CALLS         0400
+#define MASK_SHORT              0x0002	/* Compile with 16-bit `int' */
+#define MASK_AUTO_INC_DEC       0x0004    /* FIXME - tidy M68XX flags order */
+#define MASK_M6811              0x0010
+#define MASK_M6812              0x0020
+#define MASK_M68S12             0x0040
+#define MASK_NO_DIRECT_MODE     0x0100
+#define MASK_MIN_MAX            0x0200
+#define MASK_LONG_CALLS         0x0400
+#define MASK_M68S12X            0x0800
 
 #define TARGET_OP_TIME		(optimize && optimize_size == 0)
 #define TARGET_SHORT            (target_flags & MASK_SHORT)
 #define TARGET_M6811            (target_flags & MASK_M6811)
 #define TARGET_M6812            (target_flags & MASK_M6812)
 #define TARGET_M68S12           (target_flags & MASK_M68S12)
+#define TARGET_M68S12X          (!(target_flags & MASK_M6811) && (target_flags & MASK_M68S12X))
 #define TARGET_AUTO_INC_DEC     (target_flags & MASK_AUTO_INC_DEC)
 #define TARGET_MIN_MAX          (target_flags & MASK_MIN_MAX)
 #define TARGET_NO_DIRECT_MODE   (target_flags & MASK_NO_DIRECT_MODE)
@@ -161,6 +171,7 @@
 #  define MULTILIB_DEFAULTS { "m68hc12" }
 # endif
 #endif
+/* 9s12x in own .h */
 
 /* Macro to define tables used to set the flags. This is a list in braces of
    pairs in braces, each pair being { "NAME", VALUE } where VALUE is the bits
@@ -200,6 +211,10 @@
     N_("Compile for a 68HC12")},				\
   { "68S12",  MASK_M6812 | MASK_M68S12,				\
     N_("Compile for a 68HCS12")},				\
+  { "9s12x",  MASK_M6812 | MASK_M68S12 | MASK_M68S12X,		\
+    N_("Compile for CPU12X")},				\
+  { "m9s12x",  MASK_M6812 | MASK_M68S12 | MASK_M68S12X,		\
+    N_("Compile for CPU12X")},				\
   { "", TARGET_DEFAULT, 0 }}
 
 /* This macro is similar to `TARGET_SWITCHES' but defines names of
@@ -232,7 +247,7 @@
 #endif
 
 /* Print subsidiary information on the compiler version in use.  */
-#define TARGET_VERSION	fprintf (stderr, " (MC68HC11/MC68HC12/MC68HCS12)")
+#define TARGET_VERSION	fprintf (stderr, " (MC68HC11/MC68HC12/MC68HCS12/M9S12X)")
 
 /* Sometimes certain combinations of command options do not make
    sense on a particular target machine.  You can define a macro
@@ -277,6 +292,10 @@
 /* Define this if most significant word of a multiword number is numbered.  */
 #define WORDS_BIG_ENDIAN 	1
 
+/* Use a MAX_BITS_PER_WORD equivalent to SImode so that
+   several SI patterns can be used (mostly shift & add).  */
+/* #define MAX_BITS_PER_WORD       32  */
+
 /* Width of a word, in units (bytes).  */
 #define UNITS_PER_WORD		2
 
@@ -804,8 +823,8 @@
 /* A C expression that is nonzero if hard register number REGNO2 can be
    considered for use as a rename register for REGNO1 */
 
-#define HARD_REGNO_RENAME_OK(REGNO1,REGNO2) \
-  m68hc11_hard_regno_rename_ok ((REGNO1), (REGNO2))
+#define HARD_REGNO_RENAME_OK(REGNO1,REGNO2,MODE)            \
+  m68hc11_hard_regno_rename_ok ((REGNO1), (REGNO2), (MODE))
 
 /* A C expression whose value is nonzero if pseudos that have been
    assigned to registers of class CLASS would likely be spilled
@@ -874,7 +893,9 @@
 		 && VALUE == CONST0_RTX (GET_MODE (VALUE))) : 0) 
 
 /* 'U' represents certain kind of memory indexed operand for 68HC12.
-   and any memory operand for 68HC11.  */
+   and any memory operand for 68HC11.
+   'R' represents indexed addressing mode or access to page0 for 68HC11.
+   For 68HC12, it represents any memory operand.  */
 #define EXTRA_CONSTRAINT(OP, C)                         \
 ((C) == 'U' ? m68hc11_small_indexed_indirect_p (OP, GET_MODE (OP)) \
  : (C) == 'Q' ? m68hc11_symbolic_p (OP, GET_MODE (OP)) \
@@ -963,7 +984,7 @@
    followed by "to".  Eliminations of the same "from" register are listed
    in order of preference.
 
-   We have two registers that are eliminated on the 6811. The psuedo arg
+   We have two registers that are eliminated on the 6811. The pseudo arg
    pointer and pseudo frame pointer registers can always be eliminated;
    they are replaced with either the stack or the real frame pointer.  */
 
@@ -1215,7 +1236,7 @@
 
 
 /* Internal macro, return 1 if REGNO is a valid base register.  */
-#define REG_VALID_P(REGNO) (1)	/* ? */
+#define REG_VALID_P(REGNO) ((REGNO) >= 0)
 
 extern unsigned char m68hc11_reg_valid_for_base[FIRST_PSEUDO_REGISTER];
 #define REG_VALID_FOR_BASE_P(REGNO) \
@@ -1489,7 +1510,7 @@
    macro is used in only one place: `find_reloads_address' in reload.c.
 
    For M68HC11, we handle large displacements of a base register
-   by splitting the addend accors an addhi3 insn.
+   by splitting the addend across an addhi3 insn.
 
    For M68HC12, the 64K offset range is available.
    */
@@ -1690,7 +1711,7 @@
 
 /* Assembler Commands for Exception Regions.  */
 
-/* Default values provided by GCC should be ok. Assumming that DWARF-2
+/* Default values provided by GCC should be ok. Assuming that DWARF-2
    frame unwind info is ok for this platform.  */
 
 #undef PREFERRED_DEBUGGING_TYPE
@@ -1719,6 +1740,12 @@
 #define IMMEDIATE_PREFIX "#"
 #define GLOBAL_ASM_OP   "\t.globl\t"
 
+/* This is how to output a reference to a user-level label named NAME.
+   `assemble_name' uses this.  */
+#undef  ASM_OUTPUT_LABELREF
+#define ASM_OUTPUT_LABELREF(FILE, NAME) \
+  asm_fprintf (FILE, "%U%s", (*targetm.strip_name_encoding) (NAME))
+
 
 /* Miscellaneous Parameters.  */
 
@@ -1737,8 +1764,10 @@
 {"m68hc11_shift_operator",   {ASHIFT, ASHIFTRT, LSHIFTRT, ROTATE, ROTATERT}},\
 {"m68hc11_eq_compare_operator", {EQ, NE}},                              \
 {"non_push_operand",         {SUBREG, REG, MEM}},			\
+{"splitable_operand",        {SUBREG, REG, MEM}},			\
 {"reg_or_some_mem_operand",  {SUBREG, REG, MEM}},			\
 {"tst_operand",              {SUBREG, REG, MEM}},			\
+{"nonimmediate_noinc_operand", {SUBREG, REG, MEM}},			\
 {"cmp_operand",              {SUBREG, REG, MEM, SYMBOL_REF, LABEL_REF,	\
 			     CONST_INT, CONST_DOUBLE}},
 
--- a/gcc/config/m68hc11/m68hc11.md
+++ b/gcc/config/m68hc11/m68hc11.md
@@ -1,21 +1,22 @@
 ;;- Machine description file for Motorola 68HC11 and 68HC12.
-;;- Copyright (C) 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
+;;- Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005
+;;- Free Software Foundation, Inc.
 ;;- Contributed by Stephane Carrez (stcarrez@nerim.fr)
 
-;; This file is part of GNU CC.
+;; This file is part of GCC.
 
-;; GNU CC is free software; you can redistribute it and/or modify
+;; GCC is free software; you can redistribute it and/or modify
 ;; it under the terms of the GNU General Public License as published by
 ;; the Free Software Foundation; either version 2, or (at your option)
 ;; any later version.
 
-;; GNU CC is distributed in the hope that it will be useful,
+;; GCC is distributed in the hope that it will be useful,
 ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
 ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ;; GNU General Public License for more details.
 
 ;; You should have received a copy of the GNU General Public License
-;; along with GNU CC; see the file COPYING.  If not, write to
+;; along with GCC; see the file COPYING.  If not, write to
 ;; the Free Software Foundation, 59 Temple Place - Suite 330,
 ;; Boston, MA 02111-1307, USA.
 
@@ -50,11 +51,11 @@
 ;; v    register 'd' for 68hc11,	16-bit
 ;;      NO_REG for 68hc12
 ;;      (used for scratch register)
-;; w    register 'sp'			16-bit 
+;; w    register 'sp'			16-bit
 ;; x    register 'x'			16-bit
 ;; y    register 'y'			16-bit
 ;; z    register 'z'			16-bit  (fake r for 68HC11 and 68HC12)
-;; D    register 'd+x'			32-bit 
+;; D    register 'd+x'			32-bit
 ;;
 ;; Group of registers:
 ;; q    register 'a' or 'b' or 'd'	 8-bit
@@ -93,7 +94,7 @@
 ;; Operands modifiers:
 ;;
 ;;     %b	Get the low part of the operand (to obtain a QImode)
-;;		This modified must always be used for QImode operations
+;;		This modifier must always be used for QImode operations
 ;;		because a correction must be applied when the operand
 ;;		is a soft register (ex: *ZD1). Otherwise, we generate
 ;;		*ZD1 and this is the high part of the register. For other
@@ -102,7 +103,7 @@
 ;;     %h	Get the high part of the operand (to obtain a QImode)
 ;;     %t	Represents the temporary/scratch register *_.tmp
 ;;		The scratch register is used in some cases when GCC puts
-;;		some values in bad registers. 
+;;		some values in bad registers.
 ;;
 ;; 32/64-bit Patterns:
 ;;     The 68HC11 does not support 32/64-bit operations.  Most of the
@@ -143,7 +144,9 @@
    (A_REGNUM        5)		; A (high part of D)
    (B_REGNUM        6)		; B (low part of D)
    (CC_REGNUM       7)		; Condition code register
-   (SOFT_Z_REGNUM  11)          ; Z soft register
+   (SOFT_TMP_REGNUM 10)         ; TMP soft register
+   (SOFT_Z_REGNUM   11)         ; Z soft register
+   (SOFT_XY_REGNUM  12)         ; XY soft register
 ])
 
 ;;--------------------------------------------------------------------
@@ -192,6 +195,20 @@
      return \"cp%0\\t#0\";
 }")
 
+(define_insn "tsthi_1_s12x"
+  [(set (cc0)
+	(match_operand:HI 0 "tst_operand" "dx,*y"))]
+  "TARGET_M68S12X"
+  "*
+{
+   if (D_REG_P (operands[0]) && !TARGET_M6812)
+     return \"std\\t%t0\";
+   else if (X_REG_P (operands[0]) || Y_REG_P (operands[0]))
+     return \"tst%0\";
+   else
+     return \"cp%0\\t#0\";
+}")
+
 (define_expand "tstqi"
   [(set (cc0)
 	(match_operand:QI 0 "tst_operand" ""))]
@@ -237,7 +254,7 @@
 }")
 
 ;;
-;; tstqi_z_used, cmpqi_z_used and cmphi_z_used are patterns generated 
+;; tstqi_z_used, cmpqi_z_used and cmphi_z_used are patterns generated
 ;; during the Z register replacement.  They are used when an operand
 ;; uses the Z register as an index register (ie, (MEM:QI (REG:HI Z))).
 ;; In that case, we have to preserve the values of the replacement
@@ -247,19 +264,13 @@
 ;; avoid problems with the flow+cse register pass which are made
 ;; after Z register replacement.
 ;;
-(define_insn "tstqi_z_used"
+(define_insn_and_split "tstqi_z_used"
   [(set (cc0)
 	(match_operand:QI 0 "tst_operand" "m"))
    (use (match_operand:HI 1 "hard_reg_operand" "dxy"))
-   (use (reg:HI 11))]
-  ""
-  "#")
-
-(define_split /* "tstqi_z_used" */
-  [(set (cc0)
-	(match_operand:QI 0 "tst_operand" ""))
-   (use (match_operand:HI 1 "hard_reg_operand" ""))
    (use (reg:HI SOFT_Z_REGNUM))]
+  ""
+  "#"
   "z_replacement_completed == 2"
   [(set (mem:HI (pre_dec:HI (reg:HI SP_REGNUM))) (match_dup 1))
    (set (match_dup 1) (match_dup 2))
@@ -300,12 +311,24 @@
   [(set (cc0)
 	(compare (match_operand:HI 0 "hard_reg_operand" "")
 		 (match_operand:HI 1 "hard_reg_operand" "")))]
-  "reload_completed"
+  "TARGET_M6811
+   && reload_completed && !(Z_REG_P (operands[0]) || Z_REG_P (operands[1]))"
   [(set (match_dup 2) (match_dup 1))
    (set (cc0)
         (compare (match_dup 0) (match_dup 2)))]
   "operands[2] = gen_rtx (REG, HImode, SOFT_TMP_REGNUM);")
 
+(define_split
+  [(set (cc0)
+	(compare (match_operand:HI 0 "hard_reg_operand" "")
+		 (match_operand:HI 1 "hard_reg_operand" "")))]
+  "0 && TARGET_M6812
+   && reload_completed && !(Z_REG_P (operands[0]) || Z_REG_P (operands[1]))"
+  [(set (mem:HI (pre_dec:HI (reg:HI SP_REGNUM))) (match_dup 1))
+   (set (cc0)
+        (compare (match_dup 0) (mem:HI (post_inc:HI (reg:HI SP_REGNUM)))))]
+  "")
+
 (define_expand "cmphi"
   [(set (cc0)
 	(compare (match_operand:HI 0 "tst_operand" "")
@@ -323,9 +346,9 @@
 
 (define_insn "cmphi_1_hc12"
   [(set (cc0)
-	(compare (match_operand:HI 0 "tst_operand" 
+	(compare (match_operand:HI 0 "tst_operand"
 				"d,?xy,xyd,?xy,d,m,!u,dxy,dxy")
-		 (match_operand:HI 1 "cmp_operand"
+		 (match_operand:HI 1 "general_operand"
 				"i,i,!u,m,m,dxy,dxy,?*d*A,!*w")))]
   "TARGET_M6812"
   "*
@@ -335,18 +358,20 @@
       cc_status.flags |= CC_REVERSED;
       return \"cp%1\\t%0\";
     }
+  else if (SP_REG_P (operands[1]))
+    return \"sts\\t2,-sp\n\\tcp%0\\t2,sp+\";
   else if (H_REG_P (operands[1]))
-    return \"#\";
+    return \"psh%1\n\\tcp%0\\t2,sp+\";
   else
     return \"cp%0\\t%1\";
 }")
 
 (define_insn "cmphi_1_hc11"
   [(set (cc0)
-	(compare (match_operand:HI 0 "tst_operand" 
-				"dx,y,xyd,?xy,d,m,!u,dxy,dxy")
+	(compare (match_operand:HI 0 "tst_operand"
+				"dx,y,xyd,?xy,d,m,m,dxy,dxy,?u*z,dxy,*z")
 		 (match_operand:HI 1 "cmp_operand"
-				"i,i,!u,m,m,dxy,dxy,?*d*A,!*w")))]
+				"i,i,!u,m,m,?xy,d,?*d*A,?u,dxy,!*w,i")))]
   "TARGET_M6811"
   "*
 {
@@ -361,21 +386,14 @@
     return \"cp%0\\t%1\";
 }")
 
-(define_insn "cmphi_z_used"
+(define_insn_and_split "cmphi_z_used"
   [(set (cc0)
 	(compare (match_operand:HI 0 "tst_operand" "dxy,m")
-		 (match_operand:HI 1 "cmp_operand" "m,dxy")))
+		 (match_operand:HI 1 "cmp_operand" "mi,dxy")))
    (use (match_operand:HI 2 "hard_reg_operand" "dxy,dxy"))
    (use (reg:HI SOFT_Z_REGNUM))]
   ""
-  "#")
-  
-(define_split /* "cmphi_z_used" */
-  [(set (cc0)
-	(compare (match_operand:HI 0 "tst_operand" "")
-		 (match_operand:HI 1 "cmp_operand" "")))
-   (use (match_operand:HI 2 "hard_reg_operand" ""))
-   (use (reg:HI SOFT_Z_REGNUM))]
+  "#"
   "z_replacement_completed == 2"
   [(set (mem:HI (pre_dec:HI (reg:HI SP_REGNUM))) (match_dup 2))
    (set (match_dup 2) (match_dup 3))
@@ -452,21 +470,14 @@
    operands[3] = gen_rtx (REG, HImode, SOFT_TMP_REGNUM);
    operands[4] = gen_rtx (REG, QImode, SOFT_TMP_REGNUM);")
 
-(define_insn "bitcmpqi_z_used"
+(define_insn_and_split "bitcmpqi_z_used"
   [(set (cc0)
 	(and:QI (match_operand:QI 0 "tst_operand" "d,m")
 		(match_operand:QI 1 "cmp_operand" "m,d")))
    (use (match_operand:HI 2 "hard_reg_operand" "xy,xy"))
    (use (reg:HI SOFT_Z_REGNUM))]
   ""
-  "#")
-  
-(define_split /* "bitcmpqi_z_used" */
-  [(set (cc0)
-	(and:QI (match_operand:QI 0 "tst_operand" "")
-		(match_operand:QI 1 "cmp_operand" "")))
-   (use (match_operand:HI 2 "hard_reg_operand" ""))
-   (use (reg:HI SOFT_Z_REGNUM))]
+  "#"
   "z_replacement_completed == 2"
   [(set (mem:HI (pre_dec:HI (reg:HI SP_REGNUM))) (match_dup 2))
    (set (match_dup 2) (match_dup 3))
@@ -542,21 +553,14 @@
    return \"cmpb\\t%b0\";
 }")
 
-(define_insn "cmpqi_z_used"
+(define_insn_and_split "cmpqi_z_used"
   [(set (cc0)
 	(compare (match_operand:QI 0 "tst_operand" "dxy,m")
 		 (match_operand:QI 1 "cmp_operand" "m,dxy")))
    (use (match_operand:HI 2 "hard_reg_operand" "dxy,dxy"))
    (use (reg:HI SOFT_Z_REGNUM))]
   ""
-  "#")
-  
-(define_split /* cmpqi_z_used */
-  [(set (cc0)
-	(compare (match_operand:QI 0 "tst_operand" "")
-		 (match_operand:QI 1 "cmp_operand" "")))
-   (use (match_operand:HI 2 "hard_reg_operand" ""))
-   (use (reg:HI SOFT_Z_REGNUM))]
+  "#"
   "z_replacement_completed == 2"
   [(set (mem:HI (pre_dec:HI (reg:HI SP_REGNUM))) (match_dup 2))
    (set (match_dup 2) (match_dup 3))
@@ -573,41 +577,29 @@
 ;; (strict_low_part ...) information.  This is correct for our machine
 ;; description but not for GCC optimization passes.
 ;;
-(define_insn "movstrictsi"
+(define_insn_and_split "movstrictsi"
   [(set (strict_low_part (match_operand:SI 0 "non_push_operand" "+um,D,D"))
 	(match_operand:SI 1 "general_operand" "D,Dim,uD"))]
   ""
-  "#")
-
-(define_split
-  [(set (strict_low_part (match_operand:SI 0 "non_push_operand" ""))
-	(match_operand:SI 1 "general_operand" ""))]
+  "#"
   "z_replacement_completed == 2"
   [(set (match_dup 0) (match_dup 1))]
   "")
 
-(define_insn "movstricthi"
+(define_insn_and_split "movstricthi"
   [(set (strict_low_part (match_operand:HI 0 "non_push_operand" "+um,dA,dA"))
 	(match_operand:HI 1 "general_operand" "dA,dAim,u"))]
   ""
-  "#")
-
-(define_split
-  [(set (strict_low_part (match_operand:HI 0 "non_push_operand" ""))
-	(match_operand:HI 1 "general_operand" ""))]
+  "#"
   "z_replacement_completed == 2"
   [(set (match_dup 0) (match_dup 1))]
   "")
 
-(define_insn "movstrictqi"
+(define_insn_and_split "movstrictqi"
   [(set (strict_low_part (match_operand:QI 0 "non_push_operand" "+mu,!dA"))
 	(match_operand:QI 1 "general_operand" "d,imudA"))]
   ""
-  "#")
-
-(define_split
-  [(set (strict_low_part (match_operand:QI 0 "non_push_operand" ""))
-	(match_operand:QI 1 "general_operand" ""))]
+  "#"
   "z_replacement_completed == 2"
   [(set (match_dup 0) (match_dup 1))]
   "")
@@ -617,9 +609,9 @@
 ;; The movdi and movdf patterns are identical except for the mode.
 ;; They are also very similar to those for movsi and movsf.
 ;;
-;; For 68HC11, we need a scratch register (either D, X, Y) 
+;; For 68HC11, we need a scratch register (either D, X, Y)
 ;; because there is no memory->memory moves.  It must be defined with
-;; earlyclobber (&) so that it does not appear in the source or destination 
+;; earlyclobber (&) so that it does not appear in the source or destination
 ;; address.  Providing patterns for movdi/movdf allows GCC to generate
 ;; better code.  [Until now, the scratch register is limited to D because
 ;; otherwise we can run out of registers in the A_REGS class for reload].
@@ -651,17 +643,26 @@
     }
 ")
 
-(define_insn "movdi_internal"
-  [(set (match_operand:DI 0 "nonimmediate_operand" "=ou,U,!u,U,m,m,!u")
+;; Separate push from normal moves to avoid reloading problems
+;; The 'clr' is not able to push on 68HC11 so we really need a scratch.
+;; We can also accept more scratch registers.
+(define_insn_and_split "*pushdi_internal"
+  [(set (match_operand:DI 0 "push_operand" "=<,<,<,<")
+	(match_operand:DI 1 "general_operand" "i,U,m,!u"))
+   (clobber (match_scratch:HI 2 "=&dA,&d,&d,&dA"))]
+  ""
+  "#"
+  "reload_completed"
+  [(const_int 0)]
+  "m68hc11_split_move (operands[0], operands[1], operands[2]);
+   DONE;")
+
+(define_insn_and_split "movdi_internal"
+  [(set (match_operand:DI 0 "non_push_operand" "=m!u,U,!u,U,m,m,!u")
 	(match_operand:DI 1 "general_operand" "K,iU,iU,!u,mi,!u,!mu"))
    (clobber (match_scratch:HI 2 "=X,&d,&d,&d,&d,&d,&d"))]
   ""
-  "#")
-
-(define_split
-  [(set (match_operand:DI 0 "nonimmediate_operand" "")
-	(match_operand:DI 1 "general_operand" ""))
-   (clobber (match_scratch:HI 2 ""))]
+  "#"
   "reload_completed"
   [(const_int 0)]
   "m68hc11_split_move (operands[0], operands[1], operands[2]);
@@ -687,17 +688,24 @@
     }
 ")
 
-(define_insn "movdf_internal"
-  [(set (match_operand:DF 0 "nonimmediate_operand" "=ou,U,!u,U,m,m,!u")
+;; See pushdi_internal
+(define_insn_and_split "*pushdf_internal"
+  [(set (match_operand:DF 0 "push_operand" "=<,<,<,<")
+	(match_operand:DF 1 "general_operand" "i,U,m,!u"))
+   (clobber (match_scratch:HI 2 "=&dA,&d,&d,&dA"))]
+  ""
+  "#"
+  "reload_completed"
+  [(const_int 0)]
+  "m68hc11_split_move (operands[0], operands[1], operands[2]);
+   DONE;")
+
+(define_insn_and_split "movdf_internal"
+  [(set (match_operand:DF 0 "non_push_operand" "=mu,U,!u,U,m,m,!u")
 	(match_operand:DF 1 "general_operand" "G,iU,iU,!u,mi,!u,!mu"))
    (clobber (match_scratch:HI 2 "=X,&d,&d,&d,&d,&d,&d"))]
   ""
-  "#")
-
-(define_split
-  [(set (match_operand:DF 0 "nonimmediate_operand" "")
-	(match_operand:DF 1 "general_operand" ""))
-   (clobber (match_scratch:HI 2 ""))]
+  "#"
   "reload_completed"
   [(const_int 0)]
   "m68hc11_split_move (operands[0], operands[1], operands[2]);
@@ -732,17 +740,23 @@
     }
 ")
 
-(define_insn "movsi_internal"
-  [(set (match_operand:SI 0 "nonimmediate_operand" "=ou,mu,?D,m,?D,?u,?u,!u,D")
-	(match_operand:SI 1 "general_operand"      "K,imu,im,?D,!u,?D,mi,!u,!D"))
-   (clobber (match_scratch:HI 2                    "=X,&d,X,X,X,X,&d,&d,X"))]
+(define_insn_and_split "*pushsi_internal"
+  [(set (match_operand:SI 0 "push_operand" "=<,<,<,<,<")
+	(match_operand:SI 1 "general_operand" "!D,i,U,m,!u"))
+   (clobber (match_scratch:HI 2 "=X,&dA,&d,&d,&dA"))]
   ""
-  "#")
+  "#"
+  "reload_completed"
+  [(const_int 0)]
+  "m68hc11_split_move (operands[0], operands[1], operands[2]);
+   DONE;")
 
-(define_split
-  [(set (match_operand:SI 0 "nonimmediate_operand" "")
-	(match_operand:SI 1 "general_operand" ""))
-   (clobber (match_scratch:HI 2 ""))]
+(define_insn_and_split "movsi_internal"
+  [(set (match_operand:SI 0 "nonimmediate_operand" "=mu,mu,?D,m,?D,?u,?u,!u,D")
+	(match_operand:SI 1 "general_operand" "K,imu,im,?D,!u,?D,mi,!u,!D"))
+   (clobber (match_scratch:HI 2               "=X,&d,X,X,X,X,&d,&d,X"))]
+  ""
+  "#"
   "reload_completed"
   [(const_int 0)]
   "m68hc11_split_move (operands[0], operands[1], operands[2]);
@@ -768,17 +782,23 @@
     }
 ")
 
-(define_insn "movsf_internal"
-  [(set (match_operand:SF 0 "nonimmediate_operand" "=o!u,m,D,m,D,!u,!u,!u,D")
+(define_insn_and_split "*pushsf_internal"
+  [(set (match_operand:SF 0 "push_operand" "=<,<,<,<,<")
+	(match_operand:SF 1 "general_operand" "!D,i,U,m,!u"))
+   (clobber (match_scratch:HI 2 "=X,&dA,&d,&d,&dA"))]
+  ""
+  "#"
+  "reload_completed"
+  [(const_int 0)]
+  "m68hc11_split_move (operands[0], operands[1], operands[2]);
+   DONE;")
+
+(define_insn_and_split "movsf_internal"
+  [(set (match_operand:SF 0 "nonimmediate_operand" "=m!u,m,D,m,D,!u,!u,!u,D")
 	(match_operand:SF 1 "general_operand" "G,im,im,D,!u,D,mi,!u,!D"))
    (clobber (match_scratch:HI 2 "=X,&d,X,X,X,X,&d,&d,X"))]
   ""
-  "#")
-
-(define_split
-  [(set (match_operand:SF 0 "nonimmediate_operand" "")
-	(match_operand:SF 1 "general_operand" ""))
-   (clobber (match_scratch:HI 2 ""))]
+  "#"
   "reload_completed"
   [(const_int 0)]
   "m68hc11_split_move (operands[0], operands[1], operands[2]);
@@ -790,6 +810,17 @@
 ;; We don't need a scratch register.
 ;;--------------------------------------------------------------------
 
+(define_insn "movhi_const0_s12x"
+  [(set (match_operand:HI 0 "nonimmediate_operand" "=d,x,y,A,um")
+	(const_int 0))]
+  "TARGET_M68S12X"
+  "@
+   clra\\n\\tclrb
+   clrx
+   clry
+   ld%0\\t#0
+   clrw\\t%0")
+
 (define_insn "*movhi2_push"
   [(set (match_operand:HI 0 "push_operand" "=<,<,<")
 	(match_operand:HI 1 "general_operand" "xy,?d,!z"))]
@@ -849,6 +880,18 @@
           DONE;
         }
     }
+
+  /* The doloop optimization can emit a move with a constant > 32767.
+     This will fail later on because the move instruction is not recognized
+     eg: (set (reg:HI 53) (const_int 0x8000))
+     because for some reason gcc expects the constant to be sign extended
+     ie, it only recognize: (set (reg:HI 53) (const_int 0xffff8000))
+     Do the sign extension here.  */
+  if (GET_CODE (operands[1]) == CONST_INT
+      && INTVAL (operands[1]) > 0x7fffL && INTVAL (operands[1]) <= 0x0ffffL)
+    {
+      operands[1] = GEN_INT ((INTVAL (operands[1])) | (-1L << 16));
+    }
   if (TARGET_M6811 && (reload_in_progress | reload_completed) == 0)
     {
       if (GET_CODE (operands[0]) == MEM &&
@@ -878,18 +921,9 @@
     }
 }")
 
-(define_insn "movhi_const0"
-  [(set (match_operand:HI 0 "non_push_operand" "=d,A,um")
-	(const_int 0))]
-  ""
-  "@
-   clra\\n\\tclrb
-   ld%0\\t#0
-   clr\\t%b0\\n\\tclr\\t%h0")
-
 (define_insn "*movhi_68hc12"
-  [(set (match_operand:HI 0 "nonimmediate_operand" "=U,dAw,U,U,m,!u")
-	(match_operand:HI 1 "general_operand" "U,rim,dAwi,!u,dAw,riU"))]
+  [(set (match_operand:HI 0 "nonimmediate_operand" "=U,dAw,dAw,m,U,U,m,!u")
+	(match_operand:HI 1 "general_operand" "U,dAwim,!u,K,dAwi,!u,dAw,riU"))]
   "TARGET_M6812"
   "*
 {
@@ -897,6 +931,15 @@
   return \"\";
 }")
 
+(define_insn "movhi_const0"
+  [(set (match_operand:HI 0 "nonimmediate_operand" "=d,A,um")
+	(const_int 0))]
+  "TARGET_M6811"
+  "@
+   clra\\n\\tclrb
+   ld%0\\t#0
+   clr\\t%b0\\n\\tclr\\t%h0")
+
 (define_insn "*movhi_m68hc11"
   [(set (match_operand:HI 0 "nonimmediate_operand" "=dAw,!u,m,m,dAw,!*u")
 	(match_operand:HI 1 "general_operand" "dAwim,dAw,dA,?Aw,!*u,dAw"))]
@@ -936,9 +979,9 @@
 (define_split
   [(set (match_operand:QI 0 "hard_addr_reg_operand" "")
         (match_operand:QI 1 "general_operand" ""))]
-  "z_replacement_completed == 2 && GET_MODE (operands[0]) == QImode
+  "z_replacement_completed == 2
    && !reg_mentioned_p (operands[0], operands[1])
-   && !D_REG_P (operands[1])"
+   && !(D_REG_P (operands[1]) || Q_REG_P (operands[1]))"
   [(parallel [(set (reg:HI D_REGNUM) (match_dup 2))
               (set (match_dup 2) (reg:HI D_REGNUM))])
    (set (reg:QI D_REGNUM) (match_dup 1))
@@ -952,9 +995,9 @@
 (define_split
   [(set (match_operand:QI 0 "nonimmediate_operand" "")
         (match_operand:QI 1 "hard_addr_reg_operand" ""))]
-  "z_replacement_completed == 2 && GET_MODE (operands[1]) == QImode
+  "z_replacement_completed == 2
    && !reg_mentioned_p (operands[1], operands[0])
-   && !D_REG_P (operands[0])"
+   && !(D_REG_P (operands[0]) || Q_REG_P (operands[0]))"
   [(parallel [(set (reg:HI D_REGNUM) (match_dup 2))
               (set (match_dup 2) (reg:HI D_REGNUM))])
    (set (match_dup 0) (reg:QI D_REGNUM))
@@ -1019,9 +1062,9 @@
 }")
 
 (define_insn "*movqi_68hc12"
-  [(set (match_operand:QI 0 "nonimmediate_operand" 
+  [(set (match_operand:QI 0 "nonimmediate_operand"
 				"=U,d*AU*q,d*A*qU,d*A*q,m,?*u,m")
-	(match_operand:QI 1 "general_operand" 
+	(match_operand:QI 1 "general_operand"
 				"U,*ri*q,U,m,d*q,*ri*qU,!*A"))]
   "TARGET_M6812"
   "*
@@ -1067,7 +1110,7 @@
   [(set (match_operand:SF 0 "nonimmediate_operand" "")
 	(unsigned_float:SF (match_operand:SI 1 "general_operand" "")))]
   ""
-  "m68hc11_emit_libcall (\"__floatunsisf\", UNSIGNED_FLOAT, 
+  "m68hc11_emit_libcall (\"__floatunsisf\", UNSIGNED_FLOAT,
 			 SFmode, SImode, 2, operands);
    DONE;")
 
@@ -1075,7 +1118,7 @@
   [(set (match_operand:DF 0 "nonimmediate_operand" "")
 	(unsigned_float:DF (match_operand:SI 1 "general_operand" "")))]
   ""
-  "m68hc11_emit_libcall (\"__floatunsidf\", UNSIGNED_FLOAT, 
+  "m68hc11_emit_libcall (\"__floatunsidf\", UNSIGNED_FLOAT,
 			 DFmode, SImode, 2, operands);
    DONE;")
 
@@ -1091,7 +1134,7 @@
 ;;
 (define_insn "zero_extendqidi2"
   [(set (match_operand:DI 0 "nonimmediate_operand" "=m,!u,m,!u")
-	(zero_extend:DI 
+	(zero_extend:DI
 	   (match_operand:QI 1 "nonimmediate_operand" "m,dmu,*B,*B")))
    (clobber (match_scratch:HI 2 "=&d,&dB,&d,&dB"))]
   ""
@@ -1148,7 +1191,7 @@
        emit_insn (gen_addhi3 (gen_rtx (REG, HImode, HARD_SP_REGNUM),
 			      gen_rtx (REG, HImode, HARD_SP_REGNUM),
 			      const1_rtx));
-     }      
+     }
    emit_move_insn (push, operands[2]);
    emit_move_insn (push, operands[2]);
    emit_move_insn (push, operands[2]);
@@ -1188,7 +1231,7 @@
 
 (define_insn "zero_extendhidi2"
   [(set (match_operand:DI 0 "non_push_operand" "=m,m,m,m,!u,!u")
-	(zero_extend:DI 
+	(zero_extend:DI
 	    (match_operand:HI 1 "nonimmediate_operand" "m,d,A,!u,dmA,!u")))
    (clobber (match_scratch:HI 2 "=&d,&B,&d,&dB,&dB,&dB"))]
   ""
@@ -1196,7 +1239,7 @@
 
 (define_split
   [(set (match_operand:DI 0 "non_push_operand" "")
-	(zero_extend:DI 
+	(zero_extend:DI
 	    (match_operand:HI 1 "nonimmediate_operand" "")))
    (clobber (match_scratch:HI 2 ""))]
   "z_replacement_completed == 2"
@@ -1227,15 +1270,15 @@
 
 (define_insn "zero_extendsidi2"
   [(set (match_operand:DI 0 "nonimmediate_operand" "=m,m,!u,!u")
-	(zero_extend:DI 
+	(zero_extend:DI
 	    (match_operand:SI 1 "nonimmediate_operand" "m,Du,m,Du")))
    (clobber (match_scratch:HI 2 "=d,d,d,d"))]
   ""
   "#")
 
-(define_split 
+(define_split
   [(set (match_operand:DI 0 "nonimmediate_operand" "")
-	(zero_extend:DI 
+	(zero_extend:DI
 	    (match_operand:SI 1 "nonimmediate_operand" "")))
    (clobber (match_scratch:HI 2 ""))]
   "z_replacement_completed == 2"
@@ -1261,7 +1304,7 @@
 ;;
 (define_insn "zero_extendhisi2"
   [(set (match_operand:SI 0 "non_push_operand" "=D,m,u,m,m,!u,!u")
-        (zero_extend:SI 
+        (zero_extend:SI
 	    (match_operand:HI 1 "nonimmediate_operand" "dAmu,dA,dA,m,!u,m,!u")))
    (clobber (match_scratch:HI 2 "=X,X,X,&d,&dB,&dB,&dB"))]
   ""
@@ -1269,7 +1312,7 @@
 
 (define_split
   [(set (match_operand:SI 0 "non_push_operand" "")
-	(zero_extend:SI 
+	(zero_extend:SI
 	    (match_operand:HI 1 "nonimmediate_operand" "")))
    (clobber (match_scratch:HI 2 ""))]
   "reload_completed"
@@ -1290,12 +1333,12 @@
 
 (define_insn "zero_extendqisi2"
   [(set (match_operand:SI 0 "non_push_operand" "=D,D,m,m,u")
-      (zero_extend:SI 
+      (zero_extend:SI
 	  (match_operand:QI 1 "nonimmediate_operand" "dmu,xy,d,xy,dxy")))]
   ""
   "#")
 
-(define_split 
+(define_split
   [(set (match_operand:SI 0 "non_push_operand" "")
 	(zero_extend:SI (match_operand:QI 1 "nonimmediate_operand" "")))]
   "reload_completed && !X_REG_P (operands[0])"
@@ -1305,7 +1348,7 @@
    operands[2] = m68hc11_gen_lowpart (HImode, operands[0]);
    operands[3] = m68hc11_gen_highpart (HImode, operands[0]);")
 
-(define_split 
+(define_split
   [(set (match_operand:SI 0 "hard_reg_operand" "")
 	(zero_extend:SI (match_operand:QI 1 "nonimmediate_operand" "")))]
   "z_replacement_completed == 2 && X_REG_P (operands[0])"
@@ -1350,7 +1393,7 @@
 
 (define_insn "zero_extendqihi2"
   [(set (match_operand:HI 0 "non_push_operand" "=dm,d,*A,!*u,d,m,!*u")
-	(zero_extend:HI 
+	(zero_extend:HI
 	    (match_operand:QI 1 "nonimmediate_operand" "d,*A,d*Am,d,!um,*A,*A")))]
   ""
  "*
@@ -1553,7 +1596,7 @@
       output_asm_insn (\"bpl\\t%l0\", ops);
       output_asm_insn (\"deca\", operands);
 
-      ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\", 
+      ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\",
 				 CODE_LABEL_NUMBER (ops[0]));
     }
    else
@@ -1664,8 +1707,8 @@
 ;;- Min and Max instructions (68HC12).
 ;;--------------------------------------------------------------------
 (define_insn "uminqi3"
-  [(set (match_operand:QI 0 "nonimmediate_operand" "=d,m")
-	(umin:QI (match_operand:QI 1 "nonimmediate_operand" "%0,0")
+  [(set (match_operand:QI 0 "nonimmediate_noinc_operand" "=d,m")
+	(umin:QI (match_operand:QI 1 "nonimmediate_noinc_operand" "%0,0")
 		 (match_operand:QI 2 "general_operand" "m,d")))]
   "TARGET_M6812 && TARGET_MIN_MAX"
   "*
@@ -1686,8 +1729,8 @@
 }")
 
 (define_insn "umaxqi3"
-  [(set (match_operand:QI 0 "nonimmediate_operand" "=d,m")
-	(umax:QI (match_operand:QI 1 "nonimmediate_operand" "%0,0")
+  [(set (match_operand:QI 0 "nonimmediate_noinc_operand" "=d,m")
+	(umax:QI (match_operand:QI 1 "nonimmediate_noinc_operand" "%0,0")
 		 (match_operand:QI 2 "general_operand" "m,d")))]
   "TARGET_M6812 && TARGET_MIN_MAX"
   "*
@@ -1708,8 +1751,8 @@
 }")
 
 (define_insn "uminhi3"
-  [(set (match_operand:HI 0 "nonimmediate_operand" "=d,m")
-	(umin:HI (match_operand:HI 1 "nonimmediate_operand" "%0,0")
+  [(set (match_operand:HI 0 "nonimmediate_noinc_operand" "=d,m")
+	(umin:HI (match_operand:HI 1 "nonimmediate_noinc_operand" "%0,0")
 		 (match_operand:HI 2 "general_operand" "m,d")))]
   "TARGET_M6812 && TARGET_MIN_MAX"
   "*
@@ -1727,8 +1770,8 @@
 }")
 
 (define_insn "umaxhi3"
-  [(set (match_operand:HI 0 "nonimmediate_operand" "=d,m")
-	(umax:HI (match_operand:HI 1 "nonimmediate_operand" "%0,0")
+  [(set (match_operand:HI 0 "nonimmediate_noinc_operand" "=d,m")
+	(umax:HI (match_operand:HI 1 "nonimmediate_noinc_operand" "%0,0")
 		 (match_operand:HI 2 "general_operand" "m,d")))]
   "TARGET_M6812 && TARGET_MIN_MAX"
   "*
@@ -1772,7 +1815,7 @@
 
 (define_insn "*addsi3_zero_extendhi"
   [(set (match_operand:SI 0 "register_operand" "=D,D,D,D")
-	(plus:SI (zero_extend:SI 
+	(plus:SI (zero_extend:SI
 		 (match_operand:HI 1 "general_operand" "dxi,!u,mdxi,!u"))
 		 (match_operand:SI 2 "general_operand" "mi,mi,D?u,!Du")))
    (clobber (match_scratch:HI 3 "=X,X,X,X"))]
@@ -1812,26 +1855,26 @@
 
   CC_STATUS_INIT;
   ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\", CODE_LABEL_NUMBER (ops[2]));
-  return \"\";  
+  return \"\";
 }")
 
 
 (define_split /* "*addsi3_zero_extendqi" */
   [(set (match_operand:SI 0 "register_operand" "")
-	(plus:SI (zero_extend:SI 
+	(plus:SI (zero_extend:SI
 		   (match_operand:QI 1 "general_operand" ""))
 		 (match_operand:SI 2 "memory_operand" "")))
    (clobber (match_scratch:HI 3 "=X,X"))]
   "reload_completed"
   [(set (reg:HI D_REGNUM) (zero_extend:HI (match_dup 1)))
-   (parallel [(set (match_dup 0) 
+   (parallel [(set (match_dup 0)
 		   (plus:SI (zero_extend:SI (reg:HI D_REGNUM)) (match_dup 2)))
 	      (clobber (match_dup 3))])]
   "")
 
 (define_insn "*addsi3_zero_extendqi"
   [(set (match_operand:SI 0 "register_operand" "=D,D")
-	(plus:SI (zero_extend:SI 
+	(plus:SI (zero_extend:SI
 		   (match_operand:QI 1 "general_operand" "dAmi,!dAmiu"))
 		 (match_operand:SI 2 "general_operand" "miD,!muiD")))
    (clobber (match_scratch:HI 3 "=X,X"))]
@@ -1897,7 +1940,7 @@
 				 CODE_LABEL_NUMBER (ops[3]));
     }
   CC_STATUS_INIT;
-  return \"\";  
+  return \"\";
 }")
 
 (define_insn "*addsi3"
@@ -1913,6 +1956,7 @@
   const char* inc_insn;
   const char* incb_mem;
   const char* inch_mem;
+  const char* incw_mem;
   HOST_WIDE_INT val;
 
   if (which_alternative > 2)
@@ -1925,11 +1969,19 @@
     {
       if (!H_REG_P (operands[0]))
 	{
+        if ((val == 0x1000) && TARGET_M68S12X)
+          {
+	  ops[0] = m68hc11_gen_highpart (HImode, operands[0]);
+	  output_asm_insn (\"incw\\t%0\", ops);
+          }
+        else
+          {
 	  ops[0] = m68hc11_gen_highpart (HImode, operands[0]);
 	  ops[1] = m68hc11_gen_highpart (HImode, operands[2]);
 	  output_asm_insn (\"ldd\\t%0\", ops);
 	  output_asm_insn (\"addd\\t%1\", ops);
 	  output_asm_insn (\"std\\t%0\", ops);
+          }
 	  return \"\";
 	}
       else if (val == 1)
@@ -1943,7 +1995,36 @@
     }
   if ((val & 0xffff0000L) != 0 && (val & 0xffff0000L) != 0xffff0000L)
     {
+      if (!H_REG_P (operands[0]) && TARGET_M68S12X)
+	    {
+  	      output_asm_insn (\";val high byte non-zero\", ops);
+	      ops[0] = m68hc11_gen_lowpart (HImode, operands[0]);
+	      ops[1] = m68hc11_gen_lowpart (HImode, operands[2]);
+	      output_asm_insn (\"ldd\\t%0\", ops);
+	      output_asm_insn (\"addd\\t%1\", ops);
+	      output_asm_insn (\"std\\t%0\", ops);
+	      ops[0] = m68hc11_gen_highpart (HImode, operands[0]);
+	      ops[1] = m68hc11_gen_highpart (HImode, operands[2]);
+	      output_asm_insn (\"ldx\\t%0\", ops);
+	      output_asm_insn (\"adex\\t%1\", ops);
+	CC_STATUS_INIT; /* not sure if this is correct, but want to declare CC is not as expected after ADEX */
+	      output_asm_insn (\"stx\\t%0\", ops);
+	      return \"\";
+        }
+      else if (D_REG_P (operands[0]) && TARGET_M68S12X)
+        {
+  	      output_asm_insn (\";val high byte non-zero and D reg\", ops);
+	      ops[0] = m68hc11_gen_lowpart (HImode, operands[2]);
+	      ops[1] = m68hc11_gen_highpart (HImode, operands[2]);
+	      output_asm_insn (\"addd\\t%0\", ops);
+	      output_asm_insn (\"adex\\t%1\", ops);
+	CC_STATUS_INIT; /* not sure if this is correct, but want to declare CC is not as expected after ADEX */
+	      return \"\";
+        }
+      else
+        {
       return \"#\";
+        }
     }
 
   if (val >= 0)
@@ -1953,6 +2034,7 @@
       inc_insn = \"inx\\t\";
       incb_mem  = \"inc\\t%b1\";
       inch_mem  = \"inc\\t%h1\";
+      incw_mem  = \"incw\\t%1\";
     }
   else
     {
@@ -1961,8 +2043,9 @@
       inc_insn = \"dex\";
       incb_mem  = \"dec\\t%b1\";
       inch_mem  = \"dec\\t%h1\";
+      incw_mem  = \"decw\\t%1\";
     }
-      
+
   ops[2] = gen_label_rtx ();
   if (!H_REG_P (operands[0]))
     {
@@ -1985,16 +2068,30 @@
       ops[1] = ops[0];
       if (INTVAL (operands[2]) < 0)
 	{
+        if (TARGET_M68S12X)
+          {
+	  output_asm_insn (\"decw\\t%1\", ops);
+          }
+        else
+          {
 	  output_asm_insn (\"ldd\\t%1\", ops);
 	  output_asm_insn (\"addd\\t#-1\", ops);
 	  output_asm_insn (\"std\\t%1\", ops);
+          }
 	}
       else
 	{
+        if (TARGET_M68S12X)
+          {
+          output_asm_insn (incw_mem, ops);
+          }
+        else
+	  {
           output_asm_insn (incb_mem, ops);
           output_asm_insn (\"bne\\t%l2\", ops);
           output_asm_insn (inch_mem, ops);
-	}
+	  }
+        }
     }
   ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\", CODE_LABEL_NUMBER (ops[2]));
 
@@ -2002,6 +2099,11 @@
   return \"\";
 }")
 
+;;
+;;  split to handle 32-add when low-byte is zero
+;;
+;;
+
 (define_split
   [(set (match_operand:SI 0 "register_operand" "")
 	(plus:SI (match_operand:SI 1 "register_operand" "")
@@ -2024,13 +2126,40 @@
      }
    ")
 
+;;
+;;  split 32-bit D/X pair add into a HI add in D and an HI adc in X
+;;  S12X only
+;;
+;; DISABLED - generates bad code
+
+(define_split
+  [(set (match_operand:SI 0 "register_operand" "")
+	(plus:SI (match_operand:SI 1 "register_operand" "")
+		 (match_operand:SI 2 "general_operand" "")))
+   (clobber (match_scratch:HI 3 "=X"))]
+  "TARGET_M68S12X && reload_completed && z_replacement_completed == 2 && 0
+    && (GET_CODE (operands[2]) != CONST_INT ||
+        (!(INTVAL (operands[2]) >= -65536 && INTVAL (operands[2]) <= 65535)))"
+  [(set (reg:HI D_REGNUM) (plus:HI (reg:HI D_REGNUM) (match_dup 3)))
+   (set (reg:HI X_REGNUM) (plus:HI (plus:HI (reg:HI CC_REGNUM) (reg:HI X_REGNUM) )(match_dup 4)))]
+
+  "operands[3] = m68hc11_gen_lowpart (HImode, operands[2]);
+   operands[4] = m68hc11_gen_highpart (HImode, operands[2]);")
+
+
+
+;;
+;;  split 32-bit D/X pair add into a HI add in D , xg and a QI adc in A and B then another xg
+;;
+;;
+
 (define_split
   [(set (match_operand:SI 0 "register_operand" "")
 	(plus:SI (match_operand:SI 1 "register_operand" "")
 		 (match_operand:SI 2 "general_operand" "")))
    (clobber (match_scratch:HI 3 "=X"))]
   "reload_completed && z_replacement_completed == 2
-   && (GET_CODE (operands[2]) != CONST_INT || 
+   && (GET_CODE (operands[2]) != CONST_INT ||
         (!(INTVAL (operands[2]) >= -65536 && INTVAL (operands[2]) <= 65535)))"
   [(set (reg:HI D_REGNUM) (plus:HI (reg:HI D_REGNUM) (match_dup 3)))
    (parallel [(set (reg:HI D_REGNUM) (reg:HI X_REGNUM))
@@ -2051,7 +2180,7 @@
 (define_insn "*addsi_carry"
   [(set (match_operand:HI 0 "register_operand" "=x")
            (plus:HI (plus:HI (match_operand:HI 1 "register_operand" "0")
-		             (const_int 0)) 
+		             (const_int 0))
 		    (reg:HI CC_REGNUM)))]
   ""
   "*
@@ -2089,17 +2218,21 @@
     }
 }")
 
-(define_insn "*addhi3_68hc12"
-  [(set (match_operand:HI 0 "register_operand" "=xyd,d,xy*z*w,xy*z*w,xy*z")
-        (plus:HI (match_operand:HI 1 "register_operand" "%0,0,0,xy*zw,0")
-                 (match_operand:HI 2 "general_operand" "i,m*A*wu,id,id,!mu*A")))]
-  "TARGET_M6812"
+; This currently generates addx #aaaa when leax aaaa,x is smaller and faster
+; DISABLED
+(define_insn "*addhi3_68hcs12x"
+  [(set (match_operand:HI 0 "register_operand" "=xy,d,d,xy*A*w,xy*A*w,xy*A")
+        (plus:HI (match_operand:HI 1 "register_operand" "%0,0,0,0,xy*Aw,0")
+                 (match_operand:HI 2 "general_operand" "Lim!*u,i,m*A*wu,id,id,!mu*A")))]
+  "TARGET_M6812 && TARGET_M68S12X && 0"
   "*
 {
   int val;
   const char* insn_code;
+  /*  printf (\"alternative %d, %d, %d\\n\", which_alternative, REGNO(operands[0]), REGNO(operands[2])) ;
+      fflush(stdout) ; */
 
-  if (which_alternative >= 4)
+  if (which_alternative >= 5)
     {
       if (A_REG_P (operands[2]))
         {
@@ -2108,9 +2241,12 @@
 	  output_asm_insn (\"lea%0 d,%0\", operands);
 	  return \"xgd%2\";
 	}
+/*       printf (\"bombing out\\n\") ;  */
       return \"#\";
+
     }
 
+
   if (D_REG_P (operands[0]))
     {
       if (X_REG_P (operands[2]))
@@ -2135,6 +2271,16 @@
       return \"addd\\t%2\";
     }
 
+  if ((X_REG_P(operands[0]) || Y_REG_P(operands[0]) ) &&
+      (which_alternative!=4)){
+     if( !D_REG_P(operands[2]) &&
+     	  !X_REG_P(operands[2]) &&
+	 !Y_REG_P(operands[2])) {
+/* 	     printf (\"add %d %d %d %d \\n\", which_alternative, REGNO(operands[0]),REGNO(operands[1]),REGNO(operands[2]) ); */
+	     return \"add%0\\t%2\";
+     }
+  }
+
   if (GET_CODE (operands[2]) == CONST_INT)
     val = INTVAL (operands[2]);
   else
@@ -2174,7 +2320,7 @@
      is updated. For SP increment, flags are not changed.  */
   if (SP_REG_P (operands[0]))
     {
-      cc_status = cc_prev_status; 
+      cc_status = cc_prev_status;
       if (INTVAL (operands[2]) < 0)
 	{
 	  while (val > 2)
@@ -2184,7 +2330,7 @@
 	    }
 	  if (val == 0)
 	    return \"\";
-	}     
+	}
     }
   else
     {
@@ -2199,64 +2345,174 @@
   return \"\";
 }")
 
-;;
-;; Specific pattern to add to the stack pointer.
-;; We also take care of the clobbering of the IY register.
-;;
-(define_insn "addhi_sp"
-  [(set (match_operand:HI 0 "stack_register_operand" "=w,w,w,w")
-	  (plus:HI (match_operand:HI 1 "stack_register_operand" "%0,0,0,0")
-		   (match_operand:HI 2 "general_operand" "P,im,u,im")))
-   (clobber (match_scratch:HI 3 "=X,&y,&y,!&x"))]
-  "!TARGET_M6812"
+(define_insn "*addhi3_68hc12"
+  [(set (match_operand:HI 0 "register_operand" "=d*A,d,xy*A*w,xy*A*w,xy*A")
+        (plus:HI (match_operand:HI 1 "register_operand" "%0,0,0,xy*Aw,0")
+                 (match_operand:HI 2 "general_operand" "i,m*A*wu,id,id,!mu*A")))]
+  "TARGET_M6812"
   "*
 {
-  HOST_WIDE_INT val;
+  int val;
+  const char* insn_code;
 
-  if (optimize && Y_REG_P (operands[3])
-      && dead_register_here (insn, gen_rtx (REG, HImode, HARD_X_REGNUM)))
-    operands[3] = gen_rtx (REG, HImode, HARD_X_REGNUM);
+  if (which_alternative >= 4)
+    {
+      if (A_REG_P (operands[2]))
+        {
+	  CC_STATUS_INIT;
+	  output_asm_insn (\"xgd%2\", operands);
+	  output_asm_insn (\"lea%0 d,%0\", operands);
+	  return \"xgd%2\";
+	}
+      return \"#\";
+    }
 
-  if (GET_CODE (operands[2]) == CONST_INT
-      && (val = INTVAL (operands[2])) != 0
-      && (CONST_OK_FOR_LETTER_P (val, 'P')
-	  || (val > 0 && val <= 8)))
+  if (D_REG_P (operands[0]))
     {
-      while (val > 1 || val < -1)
+      if (X_REG_P (operands[2]))
 	{
-	  if (val > 0)
-	    {
-	      if (!H_REG_P (operands[3]))
-		break;
-
-	      output_asm_insn (\"pul%3\", operands);
-	      val -= 2;
-	    }
-	  else
-	    {
-	      output_asm_insn (\"pshx\", operands);
-	      val += 2;
-	    }
+	  m68hc11_notice_keep_cc (operands[0]);
+	  output_asm_insn (\"xgdx\", operands);
+	  output_asm_insn (\"leax\\td,%2\", operands);
+	  return \"xgdx\";
 	}
-      while (val != 0)
+      else if (Y_REG_P (operands[2]))
 	{
-	  if (val > 0)
-	    {
-	      output_asm_insn (\"ins\", operands);
-	      val--;
-	    }
-	  else
-	    {
-	      output_asm_insn (\"des\", operands);
-	      val++;
-	    }
+	  m68hc11_notice_keep_cc (operands[0]);
+	  output_asm_insn (\"xgdy\", operands);
+	  output_asm_insn (\"leay\\td,%2\", operands);
+	  return \"xgdy\";
 	}
-      cc_status = cc_prev_status;
-      return \"\";
-    }
-
-  /* Need to transfer to SP to X/Y and then to D register.
-     Register X/Y is lost, this is specified by the (clobber) statement.  */
+      else if (SP_REG_P (operands[2]))
+	{
+	  output_asm_insn (\"sts\\t%t0\", operands);
+	  return \"addd\\t%t0\";
+	}
+      return \"addd\\t%2\";
+    }
+
+  if (GET_CODE (operands[2]) == CONST_INT)
+    val = INTVAL (operands[2]);
+  else
+    val = 1000;
+
+  if ((val != -1 && val != 1) || !rtx_equal_p (operands[0], operands[1]))
+    {
+      m68hc11_notice_keep_cc (operands[0]);
+      switch (REGNO (operands[0]))
+	{
+	case HARD_X_REGNUM:
+	  return \"leax\\t%i2,%1\";
+
+	case HARD_Y_REGNUM:
+	  return \"leay\\t%i2,%1\";
+
+	case HARD_SP_REGNUM:
+	  return \"leas\\t%i2,%1\";
+
+	default:
+	  fatal_insn (\"Invalid operands in the instruction\", insn);
+	}
+    }
+  if (val > 0)
+    {
+      insn_code = X_REG_P (operands[0]) ? \"inx\"
+		: Y_REG_P (operands[0]) ? \"iny\" : \"ins\";
+    }
+  else
+    {
+      val  = -val;
+      insn_code = X_REG_P (operands[0]) ? \"dex\"
+		: Y_REG_P (operands[0]) ? \"dey\" : \"des\";
+    }
+
+  /* For X and Y increment, the flags are not complete. Only the Z flag
+     is updated. For SP increment, flags are not changed.  */
+  if (SP_REG_P (operands[0]))
+    {
+      cc_status = cc_prev_status;
+      if (INTVAL (operands[2]) < 0)
+	{
+	  while (val > 2)
+	    {
+	      output_asm_insn (\"pshx\", operands);
+	      val -= 2;
+	    }
+	  if (val == 0)
+	    return \"\";
+	}
+    }
+  else
+    {
+      CC_STATUS_INIT;
+    }
+
+  while (val)
+    {
+      output_asm_insn (insn_code, operands);
+      val--;
+    }
+  return \"\";
+}")
+
+;;
+;; Specific pattern to add to the stack pointer.
+;; We also take care of the clobbering of the IY register.
+;;
+(define_insn "addhi_sp"
+  [(set (match_operand:HI 0 "stack_register_operand" "=w,w,w,w")
+	  (plus:HI (match_operand:HI 1 "stack_register_operand" "%0,0,0,0")
+		   (match_operand:HI 2 "general_operand" "P,im,u,im")))
+   (clobber (match_scratch:HI 3 "=X,&y,&y,!&x"))]
+  "!TARGET_M6812"
+  "*
+{
+  HOST_WIDE_INT val;
+
+  if (optimize && Y_REG_P (operands[3])
+      && dead_register_here (insn, gen_rtx (REG, HImode, HARD_X_REGNUM)))
+    operands[3] = gen_rtx (REG, HImode, HARD_X_REGNUM);
+
+  if (GET_CODE (operands[2]) == CONST_INT
+      && (val = INTVAL (operands[2])) != 0
+      && (CONST_OK_FOR_LETTER_P (val, 'P')
+	  || (val > 0 && val <= 8)))
+    {
+      while (val > 1 || val < -1)
+	{
+	  if (val > 0)
+	    {
+	      if (!H_REG_P (operands[3]))
+		break;
+
+	      output_asm_insn (\"pul%3\", operands);
+	      val -= 2;
+	    }
+	  else
+	    {
+	      output_asm_insn (\"pshx\", operands);
+	      val += 2;
+	    }
+	}
+      while (val != 0)
+	{
+	  if (val > 0)
+	    {
+	      output_asm_insn (\"ins\", operands);
+	      val--;
+	    }
+	  else
+	    {
+	      output_asm_insn (\"des\", operands);
+	      val++;
+	    }
+	}
+      cc_status = cc_prev_status;
+      return \"\";
+    }
+
+  /* Need to transfer to SP to X/Y and then to D register.
+     Register X/Y is lost, this is specified by the (clobber) statement.  */
   output_asm_insn (\"ts%3\", operands);
   if (GET_CODE (operands[2]) == CONST_INT
       && ((val = INTVAL (operands[2])) >= 0 && val < 0x100)
@@ -2268,9 +2524,18 @@
     }
   else
     {
-      output_asm_insn (\"xgd%3\", operands);
-      output_asm_insn (\"addd\\t%2\", operands);
-      output_asm_insn (\"xgd%3\", operands);
+      if (TARGET_M68S12X)
+        {
+          output_asm_insn (\";without xgd\", operands);
+          output_asm_insn (\"add%3\\t%2\", operands);
+        }
+      else
+        {
+          output_asm_insn (\";with xgd\", operands);
+        output_asm_insn (\"xgd%3\", operands);
+        output_asm_insn (\"addd\\t%2\", operands);
+        output_asm_insn (\"xgd%3\", operands);
+      }
     }
 
    /* The status flags correspond to the addd.  xgdy and tys do not
@@ -2279,9 +2544,9 @@
 }")
 
 (define_insn "*addhi3"
-  [(set (match_operand:HI 0 "hard_reg_operand" "=A,dA,d,!A,d*A,!d*A")
-	(plus:HI (match_operand:HI 1 "general_operand" "%0,0,0,0,0,0")
-		 (match_operand:HI 2 "general_operand" "N,I,i,I,mi*A*d,!u*d*w")))]
+  [(set (match_operand:HI 0 "hard_reg_operand" "=A,dA,d,!A,d*A,d,!d*A")
+	(plus:HI (match_operand:HI 1 "general_operand" "%0,0,0,0,0,0,0")
+		 (match_operand:HI 2 "general_operand" "N,I,i,I,mi*A*d,*u,!u*d*w")))]
   "TARGET_M6811"
   "*
 {
@@ -2339,7 +2604,7 @@
      is updated.  For SP increment, flags are not changed.  */
   if (SP_REG_P (operands[0]))
     {
-      cc_status = cc_prev_status; 
+      cc_status = cc_prev_status;
       if (INTVAL (operands[2]) < 0)
 	{
 	  while (val >= 2)
@@ -2372,9 +2637,9 @@
 
 (define_insn "*addhi3_zext"
   [(set (match_operand:HI 0 "hard_reg_operand" "=A,d")
-	(plus:HI (zero_extend:HI 
+	(plus:HI (zero_extend:HI
 		     (match_operand:QI 1 "nonimmediate_operand" "d,um*A"))
-		 (match_operand:HI 2 "hard_reg_operand" "0,0")))]
+		 (match_operand:HI 2 "general_operand" "0,0")))]
   ""
   "*
 {
@@ -2383,7 +2648,7 @@
     return \"ab%0\";
   else if (A_REG_P (operands[1]))
     return \"st%1\\t%t0\\n\\taddb\\t%T0\\n\\tadca\\t#0\";
-  else 
+  else
     return \"addb\\t%b1\\n\\tadca\\t#0\";
 }")
 
@@ -2401,8 +2666,8 @@
   "")
 
 (define_insn "addqi3"
-  [(set (match_operand:QI 0 "nonimmediate_operand" "=!d*rm,dq,!*A")
-        (plus:QI (match_operand:QI 1 "nonimmediate_operand" "%0,0,0")
+  [(set (match_operand:QI 0 "nonimmediate_noinc_operand" "=!d*rm,dq,!*A")
+        (plus:QI (match_operand:QI 1 "nonimmediate_noinc_operand" "%0,0,0")
                  (match_operand:QI 2 "general_operand" "N,ium*A*d,ium*A*d")))]
   ""
   "*
@@ -2464,13 +2729,26 @@
 ;;
 ;; add with carry is used for 32-bit add.
 ;;
+(define_insn "*adcBx"
+  [(set (match_operand:HI 0 "register_operand" "=dxy")
+        (plus:HI (plus:HI (reg:HI CC_REGNUM)
+                           (match_operand:HI 1 "register_operand" "%0"))
+                  (match_operand:HI 2 "general_operand" "ium")))]
+  "TARGET_M68S12X && 0"
+  "*
+{
+  output_asm_insn (\"ade%0\\t%2\", operands);
+  CC_STATUS_INIT; /* Z bit doesn't behave as gcc expects - this doesn't help */
+  return \"\";
+}")
+
 (define_insn "*adcq"
   [(set (match_operand:QI 0 "register_operand" "=q")
         (plus:QI (plus:QI (reg:QI CC_REGNUM)
                           (match_operand:QI 1 "register_operand" "%0"))
                  (match_operand:QI 2 "general_operand" "ium")))]
   ""
-  "adc%0\\t%b2")
+  ";adcqi\\nadc%0\\t%b2")
 
 ;;--------------------------------------------------------------------
 ;;- Subtract instructions.
@@ -2489,7 +2767,7 @@
 ;; Subtract with a constant are handled by addsi3.
 ;;
 ;;
-;; - 32-bit Add.
+;; - 32-bit Subtract.
 ;;
 (define_expand "subsi3"
   [(parallel [(set (match_operand:SI 0 "register_operand" "")
@@ -2499,6 +2777,37 @@
   ""
   "")
 
+; this is register = value - soft_register ; works at times, but then causes ICE with addsi3 ?? DISABLED
+(define_insn "*subsi3_soft"
+  [(set (match_operand:SI 0 "register_operand" "=D")
+	(minus:SI (match_operand:SI 1 "general_operand" "")
+		  (match_operand:SI 2 "register_operand" "u")))
+   (clobber (match_scratch:HI 3 "=X"))]
+  "0"
+  "*
+{
+    rtx ops[4];
+    ops[0] = m68hc11_gen_lowpart (HImode, operands[1]);
+    ops[1] = m68hc11_gen_highpart (HImode, operands[1]);
+    ops[2] = m68hc11_gen_lowpart (HImode, operands[2]);
+    ops[3] = m68hc11_gen_highpart (HImode, operands[2]);
+  output_asm_insn (\"ldd\\t%0\", ops);
+  output_asm_insn (\"ldx\\t%1\", ops);
+  output_asm_insn (\"subd\\t%2\", ops);
+    if (TARGET_M68S12X)
+      {
+        output_asm_insn (\"sbex\\t%3\", ops);
+      }
+    else
+      {
+        output_asm_insn (\"xgdx\", ops);
+        output_asm_insn (\"sbcb\\t%b3\", ops);
+        output_asm_insn (\"sbca\\t%h3\", ops);
+        output_asm_insn (\"xgdx\", ops);
+      }
+  return \"\";
+}")
+
 (define_insn "*subsi3"
   [(set (match_operand:SI 0 "register_operand" "=D,D,D,D,!u")
 	(minus:SI (match_operand:SI 1 "general_operand" "0,oi,0,!u,0")
@@ -2535,7 +2844,7 @@
       else
         operands[2] = gen_rtx (REG, HImode, SOFT_TMP_REGNUM);
     }
-  ops[0] = gen_label_rtx (); 
+  ops[0] = gen_label_rtx ();
   output_asm_insn (\"subd\\t%2\", operands);
   output_asm_insn (\"bcc\\t%l0\", ops);
   output_asm_insn (\"dex\", ops);
@@ -2561,7 +2870,7 @@
       m68hc11_gen_movhi (insn, ops);
       operands[2] = gen_rtx (REG, QImode, SOFT_TMP_REGNUM);
     }
-  ops[0] = gen_label_rtx (); 
+  ops[0] = gen_label_rtx ();
   output_asm_insn (\"subb\\t%b2\", operands);
   output_asm_insn (\"sbca\\t#0\", operands);
   output_asm_insn (\"bcc\\t%l0\", ops);
@@ -2571,10 +2880,30 @@
   return \"\";
 }")
 
+;; split for S12X architecture, just like 32-bit add split above.
+;;
+;;
+;; DISABLED
+
+(define_split
+   [(set (match_operand:SI 0 "register_operand" "")
+ 	(minus:SI (match_operand:SI 1 "register_operand" "")
+ 		 (match_operand:SI 2 "general_operand" "")))
+    (clobber (match_scratch:HI 3 "=X"))]
+  "TARGET_M68S12X && reload_completed && z_replacement_completed == 2 && 0
+    && (GET_CODE (operands[2]) != CONST_INT ||
+        (!(INTVAL (operands[2]) >= -65536 && INTVAL (operands[2]) <= 65535)))"
+  [(set (reg:HI D_REGNUM) (minus:HI (reg:HI D_REGNUM) (match_dup 3)))
+   (set (reg:HI X_REGNUM) (minus:HI (minus:HI (reg:HI CC_REGNUM) (reg:HI X_REGNUM) )(match_dup 4)))]
+
+  "operands[3] = m68hc11_gen_lowpart (HImode, operands[2]);
+   operands[4] = m68hc11_gen_highpart (HImode, operands[2]);")
+
 ;;
 ;; reg:HI 1 -> d	reg:QI 6 -> B
 ;; reg:QI 7 -> ccr      reg:QI 5 -> A
 ;;
+; this is register = register - value
 (define_split /* "*subsi3" */
   [(set (match_operand:SI 0 "register_operand" "")
 	(minus:SI (match_operand:SI 1 "register_operand" "")
@@ -2594,6 +2923,7 @@
    operands[5] = m68hc11_gen_highpart (QImode, operands[4]);
    operands[4] = m68hc11_gen_lowpart (QImode, operands[4]);")
 
+; this is register = value - hard_register
 (define_split /* "*subsi3" */
   [(set (match_operand:SI 0 "register_operand" "")
 	(minus:SI (match_operand:SI 1 "general_operand" "")
@@ -2680,9 +3010,16 @@
       if (save_x)
 	output_asm_insn (\"xgdx\", operands);
       output_asm_insn (\"tsx\", operands);
+      if (TARGET_M68S12X)
+        {
+          output_asm_insn (\"subx\\t%2\", operands);
+        }
+      else
+        {
       output_asm_insn (\"xgdx\", operands);
       output_asm_insn (\"subd\\t%2\", operands);
       output_asm_insn (\"xgdx\", operands);
+        }
 
       /* The status flags correspond to the addd. xgdx/y and tx/ys do not
          modify the flags.  */
@@ -2696,21 +3033,26 @@
   /* Need to transfer to SP to X,Y and then to D register.
      Register X,Y is lost, this is specified by the (clobber) statement.  */
   output_asm_insn (\"ts%3\", operands);
+      if (TARGET_M68S12X)
+        {
+          output_asm_insn (\"sub%3\\t%2\", operands);
+        }
+      else
+        {
   output_asm_insn (\"xgd%3\", operands);
   output_asm_insn (\"subd\\t%2\", operands);
   output_asm_insn (\"xgd%3\", operands);
-
+        }
    /* The status flags correspond to the addd. xgdx/y and tx/ys do not
       modify the flags.  */
   return \"t%3s\";
 }")
 
-
-(define_insn "*subhi3"
-  [(set (match_operand:HI 0 "register_operand" "=d,*A,d*A")
-	(minus:HI (match_operand:HI 1 "register_operand" "0,0,0")
-		  (match_operand:HI 2 "general_operand" "im*A*d,im*d*A,!u")))]
-  ""
+(define_insn "*subhi3_orig"
+  [(set (match_operand:HI 0 "register_operand" "=d,*A,d,*A")
+	(minus:HI (match_operand:HI 1 "general_operand" "0,0,0,0")
+		  (match_operand:HI 2 "general_operand" "im*A*d,im*d*A,u,!u")))]
+  "!TARGET_M68S12X"
   "*
 {
   /* Adding to an address register or with another/same register
@@ -2721,9 +3063,32 @@
   return \"subd\\t%2\";
 }")
 
+(define_insn "*subhi3_x"
+; commented definition causes show-stoppingly bad bug of wrong sign
+;  [(set (match_operand:HI 0 "register_operand" "=xy,  ?d, ?d,!*xy")
+;	(minus:HI (match_operand:HI 1 "general_operand" "%0,0,0,0")
+;		  (match_operand:HI 2 "general_operand" "mi, mi,!u*A,!umi")))]
+  [(set (match_operand:HI 0 "register_operand" "=dxy,*A,d,*A")
+	(minus:HI (match_operand:HI 1 "general_operand" "0,0,0,0")
+		  (match_operand:HI 2 "general_operand" "im*A*d,im*d*A,u,!u")))]
+  "TARGET_M68S12X"
+  "*
+{
+  /* Adding to an address register or with another/same register
+     is not possible.  This must be replaced.  */
+  if (A_REG_P (operands[0]) || H_REG_P (operands[2]))
+     	  return \"#\";
+
+  CC_STATUS_INIT;
+  if (X_REG_P(operands[0]) || Y_REG_P(operands[0]))
+	return \"sub%0\\t%2\";
+  else
+	return \"subd\\t%2\";
+}")
+
 (define_insn "*subhi3_zext"
   [(set (match_operand:HI 0 "hard_reg_operand" "=d,d")
-	(minus:HI (match_operand:HI 1 "hard_reg_operand" "0,0")
+	(minus:HI (match_operand:HI 1 "general_operand" "0,0")
            (zero_extend:HI (match_operand:QI 2 "general_operand" "mi*A,!u"))))]
   ""
   "*
@@ -2743,7 +3108,7 @@
 
 (define_insn "subqi3"
   [(set (match_operand:QI 0 "hard_reg_operand" "=dq,!*x*y")
-        (minus:QI (match_operand:QI 1 "hard_reg_operand" "0,0")
+        (minus:QI (match_operand:QI 1 "general_operand" "0,0")
                   (match_operand:QI 2 "general_operand" "uim*A*d,uim*A*d")))]
   ""
   "*
@@ -2759,6 +3124,16 @@
 ;;
 ;; subtract with carry is used for 32-bit subtract.
 ;;
+
+(define_insn "*sbeBx"
+  [(set (match_operand:HI 0 "register_operand" "=dxy")
+        (minus:HI (minus:HI (reg:HI CC_REGNUM)
+                          (match_operand:HI 1 "register_operand" "%0"))
+                 (match_operand:HI 2 "general_operand" "ium")))]
+  "TARGET_M68S12X"
+  "sbe%0\\t%2")
+
+
 (define_insn "*subcq"
   [(set (match_operand:QI 0 "register_operand" "=q")
         (minus:QI (minus:QI (reg:QI CC_REGNUM)
@@ -2837,6 +3212,32 @@
   return \"emul\\n\\texg\\tx,y\";
 }")
 
+(define_insn "umulhisi3_hc11"
+  [(set (match_operand:SI 0 "register_operand" "=D,D")
+        (mult:SI (zero_extend:SI
+		     (match_operand:HI 1 "register_operand" "%d,Amu"))
+		 (zero_extend:SI
+	             (match_operand:HI 2 "register_operand" "Amu,d"))))
+   (clobber (match_scratch:HI 3 "=y,y"))]
+  "TARGET_M6811"
+  "*
+{
+  CC_STATUS_INIT;
+  if (!H_REG_P (operands[1]))
+    output_asm_insn (\"ldx\\t%1\", operands);
+  if (!H_REG_P (operands[2]))
+    output_asm_insn (\"ldx\\t%2\", operands);
+
+  if (Y_REG_P (operands[1]) || Y_REG_P (operands[2]))
+    output_asm_insn (\"pshy\", operands);
+  else if (X_REG_P (operands[1]) || X_REG_P (operands[2])
+           || !H_REG_P (operands[1]) || !H_REG_P (operands[2]))
+    output_asm_insn (\"pshx\", operands);
+
+  output_asm_insn (\"bsr\\t__mulhi32\", operands);
+  return \"ins\\n\\tins\";
+}")
+
 (define_insn "mulhisi3"
   [(set (match_operand:SI 0 "register_operand" "=D,D")
         (mult:SI (sign_extend:SI
@@ -2896,8 +3297,8 @@
 
 (define_insn "mulqi3"
   [(set (match_operand:QI 0 "register_operand" "=d,*x,*y")
-        (mult:QI (match_operand:QI 1 "nonimmediate_operand" "%dum,0,0")
-		 (match_operand:QI 2 "general_operand" "dium,*xium,*yium")))]
+        (mult:QI (match_operand:QI 1 "general_operand" "%di*um,0,0")
+		 (match_operand:QI 2 "general_operand" "di*um,*xium,*yium")))]
   ""
   "*
 {
@@ -2952,11 +3353,11 @@
   ")
 
 (define_insn "mulqihi3"
-  [(set (match_operand:HI 0 "register_operand" "=d,d")
+  [(set (match_operand:HI 0 "register_operand" "=d,d,d")
         (mult:HI (sign_extend:HI
-			(match_operand:QI 1 "register_operand" "%0,0"))
+			(match_operand:QI 1 "register_operand" "%0,0,0"))
 		 (sign_extend:HI
-                        (match_operand:QI 2 "nonimmediate_operand" "dm,*A"))))]
+                        (match_operand:QI 2 "general_operand" "mi*u,*A,0"))))]
   ""
   "*
 {
@@ -2997,7 +3398,7 @@
   ""
   "*
 {
-  if (!X_REG_P (operands[2])) 
+  if (!X_REG_P (operands[2]))
     {
       if (Y_REG_P (operands[2]))
 	{
@@ -3012,7 +3413,7 @@
   if (TARGET_M6812)
     {
       /* Flags are ok after that.  */
-      return \"idivs\\n\\txgdx\";      
+      return \"idivs\\n\\txgdx\";
     }
   else
     {
@@ -3030,7 +3431,7 @@
   ""
   "*
 {
-  if (!X_REG_P (operands[2])) 
+  if (!X_REG_P (operands[2]))
     {
       if (Y_REG_P (operands[2]))
 	{
@@ -3054,21 +3455,29 @@
 ;;- and instructions.
 ;;--------------------------------------------------------------------
 
-(define_insn "anddi3"
+(define_insn_and_split "anddi3"
   [(set (match_operand:DI 0 "reg_or_some_mem_operand" "=m,u")
 	(and:DI (match_operand:DI 1 "reg_or_some_mem_operand" "%imu,imu")
 		(match_operand:DI 2 "general_operand" "imu,imu")))
    (clobber (match_scratch:HI 3 "=d,d"))]
   ""
-  "#")
+  "#"
+  "reload_completed"
+  [(const_int 0)]
+  "m68hc11_split_logical (SImode, AND, operands);
+   DONE;")
 
-(define_insn "andsi3"
+(define_insn_and_split "andsi3"
   [(set (match_operand:SI 0 "register_operand" "=D,!u")
 	(and:SI (match_operand:SI 1 "register_operand" "%0,0")
 		(match_operand:SI 2 "general_operand" "Dimu,imu")))
    (clobber (match_scratch:HI 3 "=X,d"))]
   ""
-  "#")
+  "#"
+  "reload_completed"
+  [(const_int 0)]
+  "m68hc11_split_logical (HImode, AND, operands);
+   DONE;")
 
 (define_expand "andhi3"
   [(set (match_operand:HI 0 "register_operand" "")
@@ -3078,10 +3487,10 @@
   "")
 
 (define_insn "*andhi3_mem"
-  [(set (match_operand:HI 0 "memory_operand" "=Q,R")
+  [(set (match_operand:HI 0 "memory_operand" "=R,Q")
 	(and:HI (match_dup 0)
 	        (match_operand:HI 1 "immediate_operand" "i,i")))
-   (clobber (match_scratch:HI 2 "=xy,X"))]
+   (clobber (match_scratch:HI 2 "=X,xy"))]
   "TARGET_RELAX && !TARGET_M6812"
   "*
 {
@@ -3101,7 +3510,7 @@
   /* When destination is a global variable, generate a .relax instruction
      and load the address in the clobber register.  That load can be
      eliminated by the linker if the address is in page0.  */
-  if (which_alternative == 0)
+  if (which_alternative == 1)
     {
       rtx ops[3];
 
@@ -3214,18 +3623,30 @@
   return \"\";
 }")
 
+;slight optimisation to use clra instead of anda#0 if upper byte is zero
 (define_insn "*andhi3_gen"
   [(set (match_operand:HI 0 "register_operand" "=d,d,!*A")
-	(and:HI (match_operand:HI 1 "register_operand" "%0,0,0")
-		(match_operand:HI 2 "general_operand" "mi,!u*A,!um*A")))]
+	(and:HI (match_operand:HI 1 "splitable_operand" "%0,0,0")
+		(match_operand:HI 2 "splitable_operand" "mi,!u*A,!um*Ai")))]
   ""
   "*
 {
   if (A_REG_P (operands[0]) || H_REG_P (operands[2]))
     return \"#\";
 
-  CC_STATUS_INIT;
-  return \"anda\\t%h2\\n\\tandb\\t%b2\";
+  int val = INTVAL (operands[2]);
+
+  if (val & 0xff00)
+    {
+      CC_STATUS_INIT;
+      return \"anda\\t%h2\\n\\tandb\\t%b2\";
+    }
+  else
+    {
+/* In this clause try leaving CC alone so the status from the ANDB is carried through */
+/* In QI bit test cases the clra is redundant but a step in the right direction. */
+    return \"clra\\n\\tandb\\t%b2\";
+    }
 }")
 
 (define_expand "andqi3"
@@ -3236,10 +3657,10 @@
   "")
 
 (define_insn "*andqi3_mem"
-  [(set (match_operand:QI 0 "memory_operand" "=Q,R")
+  [(set (match_operand:QI 0 "memory_operand" "=R,Q")
 	(and:QI (match_dup 0)
 	        (match_operand:QI 1 "const_int_operand" "i,i")))
-   (clobber (match_scratch:HI 2 "=xy,X"))]
+   (clobber (match_scratch:HI 2 "=X,xy"))]
   "TARGET_RELAX && !TARGET_M6812"
   "*
 {
@@ -3257,7 +3678,7 @@
   /* When destination is a global variable, generate a .relax instruction
      and load the address in the clobber register.  That load can be
      eliminated by the linker if the address is in page0.  */
-  if (which_alternative == 0)
+  if (which_alternative == 1)
     {
       rtx ops[3];
 
@@ -3310,8 +3731,8 @@
 
 (define_insn "*andqi3_gen"
   [(set (match_operand:QI 0 "register_operand" "=d,d,d,?*A,?*A,!*q")
-        (and:QI (match_operand:QI 1 "register_operand" "%0,0,0,0,0,0")
-             (match_operand:QI 2 "general_operand" "mi,!u,?*A,!um,?*A*d,!um*A")))]
+        (and:QI (match_operand:QI 1 "general_operand" "%0,0,0,0,0,0")
+             (match_operand:QI 2 "general_operand" "mi,!*u,?*A,!*um,?*A*d,!*um*A")))]
   ""
   "*
 {
@@ -3330,34 +3751,42 @@
 ;;- Bit set or instructions.
 ;;--------------------------------------------------------------------
 
-(define_insn "iordi3"
+(define_insn_and_split "iordi3"
   [(set (match_operand:DI 0 "reg_or_some_mem_operand" "=m,u")
 	(ior:DI (match_operand:DI 1 "reg_or_some_mem_operand" "%imu,imu")
 		(match_operand:DI 2 "general_operand" "imu,imu")))
    (clobber (match_scratch:HI 3 "=d,d"))]
   ""
-  "#")
+  "#"
+  "reload_completed"
+  [(const_int 0)]
+  "m68hc11_split_logical (SImode, IOR, operands);
+   DONE;")
 
-(define_insn "iorsi3"
+(define_insn_and_split "iorsi3"
   [(set (match_operand:SI 0 "register_operand" "=D,!u")
 	(ior:SI (match_operand:SI 1 "register_operand" "%0,0")
 		(match_operand:SI 2 "general_operand" "Dimu,imu")))
    (clobber (match_scratch:HI 3 "=X,d"))]
   ""
-  "#")
+  "#"
+  "reload_completed"
+  [(const_int 0)]
+  "m68hc11_split_logical (HImode, IOR, operands);
+   DONE;")
 
 (define_expand "iorhi3"
   [(set (match_operand:HI 0 "register_operand" "")
 	(ior:HI (match_operand:HI 1 "register_operand" "")
-		(match_operand:HI 2 "general_operand" "")))]
+		(match_operand:HI 2 "splitable_operand" "")))]
   ""
   "")
 
 (define_insn "*iorhi3_mem"
-  [(set (match_operand:HI 0 "memory_operand" "=Q,R")
+  [(set (match_operand:HI 0 "memory_operand" "=R,Q")
 	(ior:HI (match_dup 0)
 	        (match_operand:HI 1 "const_int_operand" "")))
-   (clobber (match_scratch:HI 2 "=xy,X"))]
+   (clobber (match_scratch:HI 2 "=X,xy"))]
   "TARGET_RELAX && !TARGET_M6812"
   "*
 {
@@ -3369,7 +3798,7 @@
       return \"\";
     }
   CC_STATUS_INIT;
-  if (which_alternative == 0)
+  if (which_alternative == 1)
     {
       rtx ops[3];
 
@@ -3437,8 +3866,8 @@
 
 (define_insn "*iorhi3_gen"
   [(set (match_operand:HI 0 "register_operand" "=d,d,!*A")
-	(ior:HI (match_operand:HI 1 "register_operand" "%0,0,0")
-		(match_operand:HI 2 "general_operand" "mi,!u*A,!um*A")))]
+	(ior:HI (match_operand:HI 1 "splitable_operand" "%0,0,0")
+		(match_operand:HI 2 "splitable_operand" "mi,!u*A,!um*Ai")))]
   ""
   "*
 {
@@ -3457,10 +3886,10 @@
   "")
 
 (define_insn "*iorqi3_mem"
-  [(set (match_operand:QI 0 "memory_operand" "=Q,R")
+  [(set (match_operand:QI 0 "memory_operand" "=R,Q")
 	(ior:QI (match_dup 0)
 	        (match_operand:QI 1 "const_int_operand" "")))
-   (clobber (match_scratch:HI 2 "=xy,X"))]
+   (clobber (match_scratch:HI 2 "=X,xy"))]
   "TARGET_RELAX && !TARGET_M6812"
   "*
 {
@@ -3471,7 +3900,7 @@
       cc_status = cc_prev_status;
       return \"\";
     }
-  if (which_alternative == 0)
+  if (which_alternative == 1)
     {
       rtx ops[3];
 
@@ -3520,8 +3949,8 @@
 
 (define_insn "*iorqi3_gen"
   [(set (match_operand:QI 0 "register_operand" "=d,d,d,?*A,?*A,!*q")
-	(ior:QI (match_operand:QI 1 "register_operand" "%0,0,0,0,0,0")
-	     (match_operand:QI 2 "general_operand" "mi,!u,!*A,!um,?*A*d,!um*A")))]
+	(ior:QI (match_operand:QI 1 "general_operand" "%0,0,0,0,0,0")
+	     (match_operand:QI 2 "general_operand" "mi,!*u,!*A,!*um,?*A*d,!*um*A")))]
   ""
   "*
 {
@@ -3541,26 +3970,34 @@
 ;;- xor instructions.
 ;;--------------------------------------------------------------------
 
-(define_insn "xordi3"
+(define_insn_and_split "xordi3"
   [(set (match_operand:DI 0 "reg_or_some_mem_operand" "=m,u")
 	(xor:DI (match_operand:DI 1 "reg_or_some_mem_operand" "%imu,imu")
 		(match_operand:DI 2 "general_operand" "imu,imu")))
    (clobber (match_scratch:HI 3 "=d,d"))]
   ""
-  "#")
+  "#"
+  "reload_completed"
+  [(const_int 0)]
+  "m68hc11_split_logical (SImode, XOR, operands);
+   DONE;")
 
-(define_insn "xorsi3"
+(define_insn_and_split "xorsi3"
   [(set (match_operand:SI 0 "register_operand" "=D,!u")
 	(xor:SI (match_operand:SI 1 "register_operand" "%0,0")
 		(match_operand:SI 2 "general_operand" "Dimu,imu")))
    (clobber (match_scratch:HI 3 "=X,d"))]
   ""
-  "#")
+  "#"
+  "reload_completed"
+  [(const_int 0)]
+  "m68hc11_split_logical (HImode, XOR, operands);
+   DONE;")
 
 (define_insn "xorhi3"
   [(set (match_operand:HI 0 "register_operand" "=d,d,!*A")
-	(xor:HI (match_operand:HI 1 "register_operand" "%0,0,0")
-		(match_operand:HI 2 "general_operand" "im,!u*A,!ium*A")))]
+	(xor:HI (match_operand:HI 1 "splitable_operand" "%0,0,0")
+		(match_operand:HI 2 "splitable_operand" "im,!u*A,!ium*A")))]
   ""
   "*
 {
@@ -3604,8 +4041,8 @@
 
 (define_insn "xorqi3"
   [(set (match_operand:QI 0 "register_operand" "=d,d,d,?*A,?*A,!*q")
-        (xor:QI (match_operand:QI 1 "register_operand" "%0,0,0,0,0,0")
-             (match_operand:QI 2 "general_operand" "im,!u,!*A,!ium,?*A*d,!ium*A")))]
+        (xor:QI (match_operand:QI 1 "general_operand" "%0,0,0,0,0,0")
+             (match_operand:QI 2 "general_operand" "im,!*u,!*A,!i*um,?*A*d,!i*um*A")))]
   ""
   "*
 {
@@ -3641,30 +4078,47 @@
 ;;- Bit set or instructions.
 ;;--------------------------------------------------------------------
 
-(define_insn "*logicalsi3_zexthi"
+(define_insn_and_split "*logicalsi3_zexthi"
   [(set (match_operand:SI 0 "register_operand" "=D")
 	(match_operator:SI 3 "m68hc11_logical_operator"
 		[(zero_extend:SI
 		     (match_operand:HI 1 "general_operand" "imudA"))
 		 (match_operand:SI 2 "general_operand" "Dimu")]))]
   ""
-  "#")
+  "#"
+  "reload_completed"
+  [(set (reg:HI D_REGNUM) (match_dup 4))
+   (set (reg:HI D_REGNUM) (match_op_dup 3 [(reg:HI D_REGNUM) (match_dup 5)]))
+   (set (reg:HI X_REGNUM) (match_dup 6))]
+  "PUT_MODE (operands[3], HImode);
+   if (X_REG_P (operands[2]))
+     {
+       operands[5] = operands[1];
+       /* Make all the (set (REG:x) (REG:y)) a nop set.  */
+       operands[4] = gen_rtx (REG, HImode, HARD_D_REGNUM);
+       operands[6] = gen_rtx (REG, HImode, HARD_X_REGNUM);
+     }
+   else
+     {
+       operands[4] = operands[1];
+       operands[5] = m68hc11_gen_lowpart (HImode, operands[2]);
+       operands[6] = m68hc11_gen_highpart (HImode, operands[2]);
+     }
+   /* For an AND, make sure the high 16-bit part is cleared.  */
+   if (GET_CODE (operands[3]) == AND)
+     {
+       operands[6] = const0_rtx;
+     }
+   ")
 
-(define_insn "*logicalsi3_zextqi"
+(define_insn_and_split "*logicalsi3_zextqi"
   [(set (match_operand:SI 0 "register_operand" "=D,D,D")
 	(match_operator:SI 3 "m68hc11_logical_operator"
 		[(zero_extend:SI
 		     (match_operand:QI 1 "general_operand" "d,*A,imu"))
 		 (match_operand:SI 2 "general_operand" "imu,imu,0")]))]
   ""
-  "#")
-
-(define_split /* logicalsi3_zextqi */
-  [(set (match_operand:SI 0 "register_operand" "")
-	(match_operator:SI 3 "m68hc11_logical_operator"
-	         [(zero_extend:SI
-		     (match_operand:QI 1 "general_operand" ""))
-		  (match_operand:SI 2 "general_operand" "")]))]
+  "#"
   "z_replacement_completed == 2"
   [(set (reg:QI A_REGNUM) (match_dup 4))
    (set (reg:QI D_REGNUM) (match_dup 7))
@@ -3695,63 +4149,47 @@
      }
    ")
 
-(define_split /* logicalsi3_zexthi */
-  [(set (match_operand:SI 0 "register_operand" "")
-	(match_operator:SI 3 "m68hc11_logical_operator"
-	         [(zero_extend:SI
-		     (match_operand:HI 1 "general_operand" ""))
-		  (match_operand:SI 2 "general_operand" "")]))]
-  "reload_completed"
-  [(set (reg:HI D_REGNUM) (match_dup 4))
-   (set (reg:HI D_REGNUM) (match_op_dup 3 [(reg:HI D_REGNUM) (match_dup 5)]))
-   (set (reg:HI X_REGNUM) (match_dup 6))]
-  "PUT_MODE (operands[3], HImode);
-   if (X_REG_P (operands[2]))
-     {
-       operands[5] = operands[1];
-       /* Make all the (set (REG:x) (REG:y)) a nop set.  */
-       operands[4] = gen_rtx (REG, HImode, HARD_D_REGNUM);
-       operands[6] = gen_rtx (REG, HImode, HARD_X_REGNUM);
-     }
-   else
-     {
-       operands[4] = operands[1];
-       operands[5] = m68hc11_gen_lowpart (HImode, operands[2]);
-       operands[6] = m68hc11_gen_highpart (HImode, operands[2]);
-     }
-   /* For an AND, make sure the high 16-bit part is cleared.  */
-   if (GET_CODE (operands[3]) == AND)
-     {
-       operands[6] = const0_rtx;
-     }
-   ")
-
-(define_insn "*logicalhi3_zexthi_ashift8"
+(define_insn_and_split "*logicalhi3_zexthi_ashift8"
   [(set (match_operand:HI 0 "register_operand" "=d")
 	(match_operator:HI 3 "m68hc11_logical_operator"
 		[(zero_extend:HI
-		     (match_operand:QI 1 "general_operand" "imud"))
+		     (match_operand:QI 1 "general_operand" "imud*A"))
 		 (ashift:HI
-		     (match_operand:HI 2 "general_operand" "dimu")
+		     (match_operand:HI 2 "general_operand" "imud*A")
 		     (const_int 8))]))]
   ""
-  "#")
+  "#"
+  "z_replacement_completed == 2"
+  [(set (reg:QI A_REGNUM) (match_dup 4))
+   (set (reg:QI B_REGNUM) (match_dup 5))]
+  "
+   if (GET_CODE (operands[3]) == AND)
+     {
+       emit_insn (gen_movhi (operands[0], const0_rtx));
+       DONE;
+     }
+   else
+     {
+       operands[5] = operands[1];
+       if (D_REG_P (operands[2]))
+         {
+           operands[4] = gen_rtx (REG, QImode, HARD_B_REGNUM);
+         }
+       else
+         {
+           operands[4] = m68hc11_gen_lowpart (QImode, operands[2]);
+         }
+     }
+  ")
 
-(define_insn "*logicalhi3_zexthi"
+(define_insn_and_split "*logicalhi3_zexthi"
   [(set (match_operand:HI 0 "register_operand" "=d,d")
 	(match_operator:HI 3 "m68hc11_logical_operator"
 		[(zero_extend:HI
 		     (match_operand:QI 1 "general_operand" "imd*A,?u"))
 		 (match_operand:HI 2 "general_operand" "dim,?dimu")]))]
   ""
-  "#")
-
-(define_split /* logicalhi3_zexthi */
-  [(set (match_operand:HI 0 "register_operand" "")
-	(match_operator:HI 3 "m68hc11_logical_operator"
-		[(zero_extend:HI
-		     (match_operand:QI 1 "general_operand" ""))
-		 (match_operand:HI 2 "general_operand" "")]))]
+  "#"
   "z_replacement_completed == 2"
   [(set (reg:QI B_REGNUM) (match_dup 6))
    (set (reg:QI A_REGNUM) (match_dup 4))
@@ -3780,54 +4218,16 @@
      }
   ")
 
-(define_split /* logicalhi3_zexthi_ashift8 */
-  [(set (match_operand:HI 0 "register_operand" "")
-	(match_operator:HI 3 "m68hc11_logical_operator"
-		[(zero_extend:HI
-		     (match_operand:QI 1 "general_operand" ""))
-		 (ashift:HI
-		     (match_operand:HI 2 "general_operand" "")
-		     (const_int 8))]))]
-  "z_replacement_completed == 2"
-  [(set (reg:QI A_REGNUM) (match_dup 4))
-   (set (reg:QI B_REGNUM) (match_dup 5))]
-  "
-   if (GET_CODE (operands[3]) == AND)
-     {
-       emit_insn (gen_movhi (operands[0], const0_rtx));
-       DONE;
-     }
-   else
-     {
-       operands[5] = operands[1];
-       if (D_REG_P (operands[2]))
-         {
-           operands[4] = gen_rtx (REG, QImode, HARD_B_REGNUM);
-         }
-       else
-         {
-           operands[4] = m68hc11_gen_lowpart (QImode, operands[2]);
-         }
-     }
-  ")
 
-(define_insn "*logicalsi3_silshr16"
-  [(set (match_operand:SI 0 "register_operand" "=D,D,D")
+(define_insn_and_split "*logicalsi3_silshr16"
+  [(set (match_operand:SI 0 "register_operand" "=D,D,D,?D")
           (match_operator:SI 3 "m68hc11_logical_operator"
-	      [(lshiftrt:SI 
-		   (match_operand:SI 1 "general_operand" "uim,uim,?D")
+	      [(lshiftrt:SI
+		   (match_operand:SI 1 "general_operand" "uim,uim,0,0")
 		   (const_int 16))
-		(match_operand:SI 2 "general_operand" "uim,0,0")]))]
+		(match_operand:SI 2 "general_operand" "uim,0,uim,0")]))]
   ""
-  "#")
-
-(define_split /* logicalsi3_silshr16 */
-  [(set (match_operand:SI 0 "register_operand" "")
-          (match_operator:SI 3 "m68hc11_logical_operator"
-		[(lshiftrt:SI 
-			(match_operand:SI 1 "general_operand" "")
-			(const_int 16))
-		 (match_operand:SI 2 "general_operand" "")]))]
+  "#"
   "reload_completed"
   [(set (reg:HI D_REGNUM) (match_dup 4))
    (set (reg:HI D_REGNUM) (match_op_dup 3 [(reg:HI D_REGNUM) (match_dup 5)]))
@@ -3852,23 +4252,15 @@
      }
 ")
 
-(define_insn "*logicalsi3_silshl16"
+(define_insn_and_split "*logicalsi3_silshl16"
   [(set (match_operand:SI 0 "register_operand" "=D,D")
           (match_operator:SI 3 "m68hc11_logical_operator"
-	      [(ashift:SI 
+	      [(ashift:SI
 		   (match_operand:SI 1 "general_operand" "uim,?D")
 		   (const_int 16))
 		(match_operand:SI 2 "general_operand" "0,0")]))]
   ""
-  "#")
-
-(define_split /* logicalsi3_silshl16 */
-  [(set (match_operand:SI 0 "register_operand" "")
-          (match_operator:SI 3 "m68hc11_logical_operator"
-		[(ashift:SI 
-			(match_operand:SI 1 "general_operand" "")
-			(const_int 16))
-		 (match_operand:SI 2 "general_operand" "")]))]
+  "#"
   "z_replacement_completed == 2"
   [(set (reg:HI X_REGNUM) (match_op_dup 3 [(reg:HI X_REGNUM) (match_dup 4)]))
    (set (reg:HI D_REGNUM) (match_dup 5))]
@@ -3881,48 +4273,45 @@
      operands[5] = gen_rtx (REG, HImode, HARD_D_REGNUM);
    ")
 
-
-;;--------------------------------------------------------------------
-;;- 64/32-bit Logical Operations.  Patterns are defined so that GCC
-;; can optimize correctly.  These insns are split by the `final'
-;; pass (# pattern).  They are split to fall in the corresponding
-;; 16-bit logical patterns.
-;;--------------------------------------------------------------------
-
-;; Split 64-bit logical operations: anddi3, iordi3, xordi3
-(define_split
-  [(set (match_operand:DI 0 "reg_or_some_mem_operand" "")
-	(match_operator:DI 4 "m68hc11_logical_operator"
-	     [(match_operand:DI 1 "reg_or_some_mem_operand" "")
-	      (match_operand:DI 2 "general_operand" "")]))
-   (clobber (match_scratch:HI 3 ""))]
+(define_insn_and_split "*logicalsi3_silshl16_zext"
+  [(set (match_operand:SI 0 "register_operand" "=D,D,D")
+          (match_operator:SI 3 "m68hc11_logical_operator"
+	      [(ashift:SI
+	          (zero_extend:SI
+		     (match_operand:HI 1 "general_operand" "uim,udA,!dA"))
+		  (const_int 16))
+	    (zero_extend:SI (match_operand:HI 2 "general_operand" "uidA,um,!dA"))]))]
+  ""
+  "#"
+  ;; Must split before z register replacement
   "reload_completed"
-  [(const_int 0)]
-  "m68hc11_split_logical (SImode, GET_CODE (operands[4]), operands);
-   DONE;")
-
-;; Split 32-bit logical operations: andsi3, iorsi3, xorsi3
-(define_split
-  [(set (match_operand:SI 0 "register_operand" "")
-	(match_operator:SI 3 "m68hc11_logical_operator"
-	     [(match_operand:SI 1 "register_operand" "")
-	      (match_operand:SI 2 "general_operand" "")]))]
-  "0 && reload_completed"
-  [(const_int 0)]
-  "m68hc11_split_logical (HImode, GET_CODE (operands[3]), operands);
-   DONE;")
+  [(set (match_dup 4) (match_dup 5))
+   (set (match_dup 6) (match_dup 7))]
+  "
+    /* set (X_REGNUM) (d), set (D_REGNUM) (1) */
+   if (GET_CODE (operands[1]) == HARD_D_REGNUM
+       && GET_CODE (operands[3]) != AND)
+     {
+       /* This particular case is too early to be split before
+          Z register replacement because the cse-reg pass we do
+	  does not recognize the 'swap_areg'.  It is ok to handle
+	  this case after.  */
+       if (z_replacement_completed != 2)
+         {
+	   FAIL;
+	 }
+       emit_move_insn (gen_rtx (REG, HImode, HARD_X_REGNUM), operands[2]);
+       emit_insn (gen_swap_areg (gen_rtx (REG, HImode, HARD_D_REGNUM),
+			         gen_rtx (REG, HImode, HARD_X_REGNUM)));
+     }
+   operands[4] = gen_rtx (REG, HImode, HARD_D_REGNUM);
+   operands[6] = gen_rtx (REG, HImode, HARD_X_REGNUM);
+   operands[5] = operands[2];
+   operands[7] = operands[1];
 
-;; Split 32-bit logical operations: andsi3, iorsi3, xorsi3
-(define_split
-  [(set (match_operand:SI 0 "reg_or_some_mem_operand" "")
-	(match_operator:SI 4 "m68hc11_logical_operator"
-	     [(match_operand:SI 1 "reg_or_some_mem_operand" "")
-	      (match_operand:SI 2 "general_operand" "")]))
-   (clobber (match_scratch:HI 3 ""))]
-  "reload_completed"
-  [(const_int 0)]
-  "m68hc11_split_logical (HImode, GET_CODE (operands[4]), operands);
-   DONE;")
+   if (GET_CODE (operands[3]) == AND)
+     operands[5] = operands[7] = const0_rtx;
+   ")
 
 ;;--------------------------------------------------------------------
 ;; 16-bit Arithmetic and logical operations on X and Y:
@@ -3951,8 +4340,8 @@
   "z_replacement_completed == 2
    /* If we are adding a small constant to X or Y, it's
      better to use one or several inx/iny instructions.  */
-   && !(GET_CODE (operands[3]) == PLUS 
-        && ((TARGET_M6812 
+   && !(GET_CODE (operands[3]) == PLUS
+        && ((TARGET_M6812
 	     && (immediate_operand (operands[2], HImode)
 		 || hard_reg_operand (operands[2], HImode)))
             || (GET_CODE (operands[2]) == CONST_INT
@@ -4005,7 +4394,7 @@
 	   operands[6] = operands[8];
 	   operands[5] = operands[2];
 	 }
-       else 
+       else
 	 {
        operands[4] = gen_rtx (REG, HImode, SOFT_TMP_REGNUM);
        operands[6] = operands[4];
@@ -4038,8 +4427,8 @@
   "z_replacement_completed == 2
    /* If we are adding a small constant to X or Y, it's
      better to use one or several inx/iny instructions.  */
-   && !(GET_CODE (operands[3]) == PLUS 
-        && ((TARGET_M6812 
+   && !(GET_CODE (operands[3]) == PLUS
+        && ((TARGET_M6812
 	    && (immediate_operand (operands[2], HImode)
 		|| hard_reg_operand (operands[2], HImode)))
             || (GET_CODE (operands[2]) == CONST_INT
@@ -4134,7 +4523,7 @@
       || reg_mentioned_p (operands[0], operands[1]))
     {
       /* Move to the destination register, before the xgdx.  */
-      operands[4] = gen_rtx (REG, GET_MODE (operands[1]), 
+      operands[4] = gen_rtx (REG, GET_MODE (operands[1]),
 			     REGNO (operands[0]));
       operands[5] = operands[1];
 
@@ -4305,8 +4694,16 @@
   ops[0] = gen_label_rtx ();
 
   /* 32-bit complement and add 1.  */
+  if (TARGET_M68S12X)
+    {
+      output_asm_insn (\"comx\\n\\txgdx\\n\\tcomx\", operands);
+    }
+  else
+    {
   output_asm_insn (\"comb\\n\\tcoma\\n\\txgdx\", operands);
-  output_asm_insn (\"comb\\n\\tcoma\\n\\tinx\\n\\txgdx\", operands);
+      output_asm_insn (\"comb\\n\\tcoma\\n\", operands);
+    }
+  output_asm_insn (\"inx\\n\\txgdx\", operands);
   output_asm_insn (\"bne\\t%l0\", ops);
   output_asm_insn (\"inx\", operands);
   ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\", CODE_LABEL_NUMBER (ops[0]));
@@ -4317,14 +4714,33 @@
   [(set (match_operand:HI 0 "register_operand" "=d,d,x*y")
 	(neg:HI (match_operand:HI 1 "general_operand" "0,!duim,0")))]
   ""
-  "@
-   coma\\n\\tcomb\\n\\taddd\\t#1
-   clra\\n\\tclrb\\n\\tsubd\\t%1
-   xgd%0\\n\\tcoma\\n\\tcomb\\n\\txgd%0\\n\\tin%0")
+  "*
+    {
+    if (which_alternative == 0)
+      {
+        return \"coma\\n\\tcomb\\n\\taddd\\t#1\";
+      }
+    else if (which_alternative == 1)
+      {
+        return \"clra\\n\\tclrb\\n\\tsubd\\t%1\";
+      }
+    else
+      {
+        if (TARGET_M68S12X)
+          {
+            return \"com%0\\n\\tin%0\";
+          }
+        else
+          {
+            return \"xgd%0\\n\\tcoma\\n\\tcomb\\n\\txgd%0\\n\\tin%0\";
+          }
+      }
+    }
+  ")
 
 (define_insn "negqi2"
-  [(set (match_operand:QI 0 "nonimmediate_operand" "=d,m,!u,!*A")
-	(neg:QI (match_operand:QI 1 "nonimmediate_operand" "0,0,0,0")))]
+  [(set (match_operand:QI 0 "nonimmediate_noinc_operand" "=d,m,!u,!*A")
+	(neg:QI (match_operand:QI 1 "nonimmediate_noinc_operand" "0,0,0,0")))]
   ""
   "@
    negb
@@ -4405,7 +4821,7 @@
 ;;- arithmetic shifts
 ;;--------------------------------------------------------------------
 ;;
-;; Provide some 64-bit shift patterns. 
+;; Provide some 64-bit shift patterns.
 (define_expand "ashldi3"
   [(parallel [(set (match_operand:DI 0 "nonimmediate_operand" "")
 	             (ashift:DI (match_operand:DI 1 "general_operand" "")
@@ -4414,26 +4830,20 @@
    ""
    "
 {
-  if (GET_CODE (operands[2]) != CONST_INT 
+  if (GET_CODE (operands[2]) != CONST_INT
       || (INTVAL (operands[2]) != 32 && INTVAL (operands[2]) != 1))
     {
       FAIL;
     }
 }")
 
-(define_insn "*ashldi3_const32"
+(define_insn_and_split "*ashldi3_const32"
   [(set (match_operand:DI 0 "nonimmediate_operand" "=<,m,u")
 	(ashift:DI (match_operand:DI 1 "general_operand" "umi,umi,umi")
 		   (const_int 32)))
    (clobber (match_scratch:HI 2 "=&A,d,d"))]
    ""
-   "#")
-
-(define_split
-  [(set (match_operand:DI 0 "nonimmediate_operand" "")
-	(ashift:DI (match_operand:DI 1 "general_operand" "")
-		   (const_int 32)))
-   (clobber (match_scratch:HI 2 ""))]
+   "#"
    "reload_completed"
    [(const_int 0)]
    "/* Move the lowpart in the highpart first in case the shift
@@ -4442,6 +4852,13 @@
       {
          m68hc11_split_move (m68hc11_gen_lowpart (SImode, operands[0]),
 			     const0_rtx, operands[2]);
+
+         /* Adjust first operand if it uses SP so that we take into
+            account the above push.  Can occur only for 68HC12.  */
+         if (reg_mentioned_p (gen_rtx (REG, HImode, HARD_SP_REGNUM),
+	                      operands[1]))
+           operands[1] = adjust_address (operands[1],
+	                                 GET_MODE (operands[0]), 4);
       }
     m68hc11_split_move (m68hc11_gen_highpart (SImode, operands[0]),
 		        m68hc11_gen_lowpart (SImode, operands[1]),
@@ -4453,19 +4870,13 @@
       }
     DONE;")
 
-(define_insn "*ashldi3_const1"
+(define_insn_and_split "*ashldi3_const1"
   [(set (match_operand:DI 0 "non_push_operand" "=m,m,u")
 	(ashift:DI (match_operand:DI 1 "general_operand" "mi,u,umi")
 		   (const_int 1)))
    (clobber (match_scratch:HI 2 "=d,d,d"))]
    ""
-   "#")
-
-(define_split
-  [(set (match_operand:DI 0 "non_push_operand" "")
-	(ashift:DI (match_operand:DI 1 "general_operand" "")
-		   (const_int 1)))
-   (clobber (match_scratch:HI 2 ""))]
+   "#"
    "z_replacement_completed == 2"
    [(set (match_dup 2) (match_dup 3))
     (set (match_dup 2) (ashift:HI (match_dup 2) (const_int 1)))
@@ -4505,10 +4916,10 @@
     operands[8] = m68hc11_gen_lowpart (HImode, operands[8]);")
 
 (define_insn "addsi_silshr16"
-  [(set (match_operand:SI 0 "register_operand" "=D,D")
-          (plus:SI (lshiftrt:SI (match_operand:SI 1 "general_operand" "!*uim,0")
+  [(set (match_operand:SI 0 "register_operand" "=D,D,!D")
+          (plus:SI (lshiftrt:SI (match_operand:SI 1 "general_operand" "!*uim,0,0")
 				(const_int 16))
-		   (match_operand:SI 2 "general_operand" "0,m!*u")))]
+		   (match_operand:SI 2 "general_operand" "0,m!*u,0")))]
   ""
   "#")
 
@@ -4530,18 +4941,28 @@
 				(const_int 16))
 		   (match_operand:SI 2 "general_operand" "")))]
   "z_replacement_completed == 2 && X_REG_P (operands[1])"
-  [(set (reg:HI D_REGNUM) (reg:HI X_REGNUM))
+  [(set (reg:HI D_REGNUM) (match_dup 5))
    (set (reg:HI X_REGNUM) (match_dup 3))
    (set (reg:HI D_REGNUM) (plus:HI (reg:HI D_REGNUM) (match_dup 4)))
    (set (reg:HI X_REGNUM) (plus:HI (plus:HI (reg:HI X_REGNUM)
 					    (const_int 0))
 				   (reg:HI CC_REGNUM)))]
   "operands[3] = m68hc11_gen_highpart (HImode, operands[2]);
-   operands[4] = m68hc11_gen_lowpart (HImode, operands[2]);")
+   if (X_REG_P (operands[2]))
+     {
+       operands[4] = gen_rtx (REG, HImode, HARD_X_REGNUM);
+       operands[5] = gen_rtx (REG, HImode, HARD_D_REGNUM);
+     }
+   else
+     {
+       operands[4] = m68hc11_gen_lowpart (HImode, operands[2]);
+       operands[5] = gen_rtx (REG, HImode, HARD_X_REGNUM);
+     }
+")
 
 (define_insn "addsi_ashift16"
   [(set (match_operand:SI 0 "register_operand" "=D")
-          (plus:SI 
+          (plus:SI
 		   (mult:SI (match_operand:SI 2 "general_operand" "uim")
 			    (const_int 65536))
 		(match_operand:SI 1 "general_operand" "0")))
@@ -4551,7 +4972,7 @@
 
 (define_split
   [(set (match_operand:SI 0 "register_operand" "")
-          (plus:SI 
+          (plus:SI
 		   (mult:SI (match_operand:SI 2 "general_operand" "")
 			    (const_int 65536))
 		   (match_operand:SI 1 "general_operand" "")))
@@ -4563,24 +4984,27 @@
   operands[4] = m68hc11_gen_lowpart (HImode, operands[2]);
 }")
 
-(define_insn "addsi_andshr16"
+(define_insn_and_split "addsi_andshr16"
   [(set (match_operand:SI 0 "register_operand" "=D")
           (plus:SI (and:SI (match_operand:SI 1 "general_operand" "%uim")
 			   (const_int 65535))
 		   (match_operand:SI 2 "general_operand" "0")))]
   ""
-  "#")
-
-(define_split
-  [(set (match_operand:SI 0 "register_operand" "")
-          (plus:SI (and:SI (match_operand:SI 1 "general_operand" "")
-			   (const_int 65535))
-		   (match_operand:SI 2 "general_operand" "")))]
+  "#"
   "z_replacement_completed == 2"
   [(set (reg:HI D_REGNUM) (plus:HI (reg:HI D_REGNUM) (match_dup 3)))
    (set (reg:HI X_REGNUM) (plus:HI (plus:HI (reg:HI X_REGNUM) (const_int 0)) (reg:HI CC_REGNUM)))]
   "operands[3] = m68hc11_gen_lowpart (HImode, operands[1]);")
 
+(define_insn "subhi_ashlhi8"
+  [(set (match_operand:HI 0 "register_operand" "=d")
+          (minus:HI (match_operand:HI 1 "register_operand" "0")
+                    (mult:HI (match_operand:HI 2 "register_operand" "0")
+			     (const_int 256))))]
+  "0"
+  "@
+   sba")
+
 ;;
 ;; 32-bit shifts are made by a small library routine that uses
 ;; a specific passing convention for parameters (for efficiency reasons).
@@ -4592,7 +5016,7 @@
 ;;
 (define_expand "ashlsi3"
   [(parallel
-       [(set (match_operand:SI 0 "register_operand" "") 
+       [(set (match_operand:SI 0 "register_operand" "")
 	     (match_operand:SI 1 "general_operand" ""))
 	(clobber (scratch:HI))])
    (parallel
@@ -4622,38 +5046,38 @@
    ""
    "#")
 
-(define_insn "*ashlsi3_const16_zexthi"
+(define_insn_and_split "*ashlsi3_const16_zexthi"
   [(set (match_operand:SI 0 "nonimmediate_operand" "=D")
-	(ashift:SI (zero_extend:HI 
+	(ashift:SI (zero_extend:HI
 			(match_operand:HI 1 "general_operand" "duim*A"))
 	           (const_int 16)))
    (clobber (match_scratch:HI 2 "=X"))]
    ""
-   "#")
-
-(define_split /* "*ashlsi3_const16_zexthi"*/
-  [(set (match_operand:SI 0 "nonimmediate_operand" "")
-	(ashift:SI (zero_extend:HI 
-			(match_operand:HI 1 "general_operand" ""))
-	           (const_int 16)))
-   (clobber (match_scratch:HI 2 "=X"))]
+   "#"
    "reload_completed"
    [(set (reg:HI X_REGNUM) (match_dup 1))
     (set (reg:HI D_REGNUM) (const_int 0))]
    "")
 
 (define_insn "*ashlsi3_const1"
-  [(set (match_operand:SI 0 "non_push_operand" "=D,D,m,!*u,?*um")
-	(ashift:SI (match_operand:SI 1 "nonimmediate_operand" "0,*um,0,0,*um")
+  [(set (match_operand:SI 0 "non_push_operand" "=D,D,D,m,*u,*u")
+	(ashift:SI (match_operand:SI 1 "nonimmediate_operand" "0,m,*u,m,*u,m")
 	           (const_int 1)))
-   (clobber (match_scratch:HI 2 "=X,X,&d,&d,&d"))]
+   (clobber (match_scratch:HI 2 "=X,X,X,&d,&d,&d"))]
    ""
    "*
 {
   CC_STATUS_INIT;
   if (X_REG_P (operands[1]))
     {
-      return \"lsld\\n\\txgdx\\n\\trolb\\n\\trola\\n\\txgdx\";
+      if (TARGET_M68S12X)
+        {
+          return \"lsld\\n\\trolx\";
+        }
+      else
+        {
+          return \"lsld\\n\\txgdx\\n\\trolb\\n\\trola\\n\\txgdx\";
+        }
     }
   else
     {
@@ -4669,30 +5093,33 @@
 	  ops[0] = m68hc11_gen_lowpart (HImode, operands[0]);
 	  m68hc11_gen_movhi (insn, ops);
 	  ops[0] = ops[1];
-          ops[1] = m68hc11_gen_highpart (HImode, operands[1]);
-          m68hc11_gen_movhi (insn, ops);
-	}
-      else
-	{
-	  /* Load the high part in X in case the source operand
-	     uses X as a memory pointer.  */
-	  ops[0] = gen_rtx (REG, HImode, HARD_X_REGNUM);
-          ops[1] = m68hc11_gen_highpart (HImode, operands[1]);
-          m68hc11_gen_movhi (insn, ops);
-          output_asm_insn (\"xgdx\", ops);
-	}
+      ops[1] = m68hc11_gen_highpart (HImode, operands[1]);
+      m68hc11_gen_movhi (insn, ops);
       output_asm_insn (\"rolb\", ops);
       output_asm_insn (\"rola\", ops);
-      if (!X_REG_P (operands[0]))
-	{
 	  ops[1] = ops[0];
 	  ops[0] = m68hc11_gen_highpart (HImode, operands[0]);
 	  m68hc11_gen_movhi (insn, ops);
+    }
+    else
+	{
+	  /* Load the high part in X in case the source operand
+	     uses X as a memory pointer.  */
+	  ops[0] = gen_rtx (REG, HImode, HARD_X_REGNUM);
+    ops[1] = m68hc11_gen_highpart (HImode, operands[1]);
+    m68hc11_gen_movhi (insn, ops);
+    if (TARGET_M68S12X)
+      {
+        output_asm_insn (\"rolx\", ops);
+      }
+    else
+      {
+        output_asm_insn (\"xgdx\", ops);
+        output_asm_insn (\"rolb\", ops);
+        output_asm_insn (\"rola\", ops);
+        output_asm_insn (\"xgdx\", ops);
+      }
 	}
-      else
-        {
-          output_asm_insn (\"xgdx\", ops);
-        }
       return \"\";
     }
 }")
@@ -4702,7 +5129,7 @@
 	(ashift:SI (match_dup 0)
 	           (match_operand:HI 1 "const_int_operand" "")))
    (clobber (match_scratch:HI 2 "=y"))]
-   ""
+   "TARGET_M6811 /* See *ashlsi3 note.  */"
    "*
 {
   CC_STATUS_INIT;
@@ -4712,7 +5139,7 @@
 (define_insn "*ashlsi3"
   [(set (match_operand:SI 0 "register_operand" "+D,D")
 	(ashift:SI (match_dup 0)
-	           (match_operand:HI 1 "general_operand" "y,m")))
+	           (match_operand:HI 1 "general_operand" "y,mi")))
    (clobber (match_scratch:HI 2 "=1,X"))]
    ""
    "*
@@ -4724,8 +5151,13 @@
      and this conflicts with all reloads.  Since X, Y, Z are used there
      is not enough register in class A_REGS.
 
-     Assuming that 'operands[1]' does not refer to the stack (which 
-     is true for 68hc11 only, we save temporary the value of Y.  */
+     Assuming that 'operands[1]' does not refer to the stack (which
+     is true for 68hc11 only, we save temporary the value of Y.
+
+     For 68HC12 we must also accept a constant because Z register is
+     disabled when compiling with -fomit-frame-pointer.  We can come up
+     with a reload problem and the *lshrsi3_const pattern was disabled
+     for that reason.  */
   if (!Y_REG_P (operands[2]))
     {
       rtx ops[1];
@@ -4752,7 +5184,7 @@
    ""
    "
 {
-  if (GET_CODE (operands[2]) != CONST_INT) 
+  if (GET_CODE (operands[2]) != CONST_INT)
     {
       rtx scratch = gen_reg_rtx (HImode);
       emit_move_insn (scratch, operands[2]);
@@ -4780,9 +5212,16 @@
     {
       return \"asld\";
     }
-  
-  output_asm_insn (\"asl\\t%b0\", operands);
-  output_asm_insn (\"rol\\t%h0\", operands);
+
+  if (TARGET_M68S12X)
+    {
+    output_asm_insn (\"aslw\\t%0\", operands);
+    }
+  else
+    {
+    output_asm_insn (\"asl\\t%b0\", operands);
+    output_asm_insn (\"rol\\t%h0\", operands);
+  }
   CC_STATUS_INIT;
   return \"\";
 }")
@@ -4846,7 +5285,7 @@
 	  }
       return \"clrb\";
     }
-  for (i = 0; i < INTVAL (operands[2]) - 1; i++) 
+  for (i = 0; i < INTVAL (operands[2]) - 1; i++)
     {
       output_asm_insn (\"asld\", operands);
     }
@@ -4861,8 +5300,8 @@
    "")
 
 (define_insn "*ashlqi3_const1"
-  [(set (match_operand:QI 0 "nonimmediate_operand" "=d,m,!u,!*q,!*A")
-	(ashift:QI (match_operand:QI 1 "nonimmediate_operand" "0,0,0,0,0")
+  [(set (match_operand:QI 0 "nonimmediate_noinc_operand" "=d,m,!u,!*q,!*A")
+	(ashift:QI (match_operand:QI 1 "nonimmediate_noinc_operand" "0,0,0,0,0")
 	           (const_int 1)))]
   ""
   "@
@@ -4939,7 +5378,7 @@
 (define_insn "*ashlqi3"
   [(set (match_operand:QI 0 "register_operand" "=d,!*q,!*A")
 	(ashift:QI (match_operand:QI 1 "register_operand" "0,0,0")
-	             (match_operand:QI 2 "nonimmediate_operand" 
+	             (match_operand:QI 2 "nonimmediate_operand"
 					 "m*u*d*A,m*u*d*A,m*u")))]
   ""
   "*
@@ -4964,7 +5403,7 @@
    ""
    "
 {
-  if (GET_CODE (operands[2]) != CONST_INT) 
+  if (GET_CODE (operands[2]) != CONST_INT)
     {
       rtx scratch = gen_reg_rtx (HImode);
 
@@ -4994,7 +5433,7 @@
     {
       return \"asra\\n\\trorb\";
     }
-  
+
   output_asm_insn (\"asr\\t%h0\", operands);
   output_asm_insn (\"ror\\t%b0\", operands);
   return \"\";
@@ -5092,7 +5531,7 @@
     return \"#\";
 
   output_asm_insn (\"bsr\\t___ashrhi3\", operands);
-  return \"\"; 
+  return \"\";
 }")
 
 (define_expand "ashrsi3"
@@ -5112,7 +5551,7 @@
 	(ashiftrt:SI (match_dup 0)
 	             (match_operand:HI 1 "const_int_operand" "")))
    (clobber (match_scratch:HI 2 "=y"))]
-   ""
+   "TARGET_M6811 /* See *ashrsi3 note.  */"
    "*
 {
   CC_STATUS_INIT;
@@ -5122,7 +5561,7 @@
 (define_insn "*ashrsi3"
   [(set (match_operand:SI 0 "register_operand" "+D,D")
 	(ashiftrt:SI (match_dup 0)
-	             (match_operand:HI 1 "general_operand" "y,m")))
+	             (match_operand:HI 1 "general_operand" "y,mi")))
    (clobber (match_scratch:HI 2 "=1,X"))]
    ""
    "*
@@ -5133,8 +5572,13 @@
      and this conflicts with all reloads.  Since X, Y, Z are used there
      is not enough register in class A_REGS.
 
-     Assuming that 'operands[1]' does not refer to the stack (which 
-     is true for 68hc11 only, we save temporary the value of Y.  */
+     Assuming that 'operands[1]' does not refer to the stack (which
+     is true for 68hc11 only, we save temporary the value of Y.
+
+     For 68HC12 we must also accept a constant because Z register is
+     disabled when compiling with -fomit-frame-pointer.  We can come up
+     with a reload problem and the *lshrsi3_const pattern was disabled
+     for that reason.  */
   if (!Y_REG_P (operands[2]))
     {
       rtx ops[1];
@@ -5162,8 +5606,8 @@
    "")
 
 (define_insn "*ashrqi3_const1"
-  [(set (match_operand:QI 0 "nonimmediate_operand" "=d,m,!u,!*q,!*A")
-	(ashiftrt:QI (match_operand:QI 1 "nonimmediate_operand" "0,0,0,0,0")
+  [(set (match_operand:QI 0 "nonimmediate_noinc_operand" "=d,m,!u,!*q,!*A")
+	(ashiftrt:QI (match_operand:QI 1 "nonimmediate_noinc_operand" "0,0,0,0,0")
 		     (const_int 1)))]
   ""
   "@
@@ -5203,7 +5647,7 @@
 (define_insn "*ashrqi3"
   [(set (match_operand:QI 0 "register_operand" "=d,!*q,!*A")
 	(ashiftrt:QI (match_operand:QI 1 "register_operand" "0,0,0")
-	             (match_operand:QI 2 "nonimmediate_operand" 
+	             (match_operand:QI 2 "nonimmediate_operand"
 					 "m*u*d*A,m*u*d*A,m*u")))]
   ""
   "*
@@ -5232,7 +5676,7 @@
    ""
    "
 {
-  if (GET_CODE (operands[2]) != CONST_INT 
+  if (GET_CODE (operands[2]) != CONST_INT
      || (INTVAL (operands[2]) != 32 && INTVAL (operands[2]) < 48
          && INTVAL (operands[2]) != 1))
     {
@@ -5240,19 +5684,13 @@
     }
 }")
 
-(define_insn "*lshrdi3_const32"
+(define_insn_and_split "*lshrdi3_const32"
   [(set (match_operand:DI 0 "nonimmediate_operand" "=<,m,u")
 	(lshiftrt:DI (match_operand:DI 1 "general_operand" "umi,umi,umi")
 		     (const_int 32)))
    (clobber (match_scratch:HI 2 "=&A,d,d"))]
    ""
-   "#")
-
-(define_split
-  [(set (match_operand:DI 0 "nonimmediate_operand" "")
-	(lshiftrt:DI (match_operand:DI 1 "general_operand" "")
-		     (const_int 32)))
-   (clobber (match_scratch:HI 2 "=&A,d"))]
+   "#"
    "reload_completed"
    [(const_int 0)]
    "m68hc11_split_move (m68hc11_gen_lowpart (SImode, operands[0]),
@@ -5302,7 +5740,7 @@
 	(lshiftrt:DI (match_operand:DI 1 "general_operand" "")
 		     (match_operand:DI 2 "const_int_operand" "")))
    (clobber (match_scratch:HI 3 "=d"))]
-   "z_replacement_completed && INTVAL (operands[2]) >= 48 
+   "z_replacement_completed && INTVAL (operands[2]) >= 48
     && INTVAL (operands[2]) < 56"
    [(set (reg:HI D_REGNUM) (match_dup 9))
     (set (reg:HI D_REGNUM) (lshiftrt:HI (reg:HI D_REGNUM) (match_dup 8)))
@@ -5322,19 +5760,13 @@
     operands[7] = m68hc11_gen_highpart (HImode, operands[6]);
     operands[6] = m68hc11_gen_lowpart (HImode, operands[6]);")
 
-(define_insn "*lshrdi_const1"
+(define_insn_and_split "*lshrdi_const1"
   [(set (match_operand:DI 0 "non_push_operand" "=m,u")
 	(lshiftrt:DI (match_operand:DI 1 "general_operand" "umi,umi")
 		     (const_int 1)))
    (clobber (match_scratch:HI 2 "=d,d"))]
    ""
-   "#")
-
-(define_split
-  [(set (match_operand:DI 0 "non_push_operand" "")
-	(lshiftrt:DI (match_operand:DI 1 "general_operand" "")
-		     (const_int 1)))
-   (clobber (match_scratch:HI 2 ""))]
+   "#"
    "z_replacement_completed == 2"
    [(set (match_dup 2) (match_dup 3))
     (set (match_dup 2) (lshiftrt:HI (match_dup 2) (const_int 1)))
@@ -5407,17 +5839,24 @@
     #")
 
 (define_insn "*lshrsi3_const1"
-  [(set (match_operand:SI 0 "non_push_operand" "=D,m,*u")
-	(lshiftrt:SI (match_operand:SI 1 "nonimmediate_operand" "D*um,*um,*um")
+  [(set (match_operand:SI 0 "non_push_operand" "=D,D,D,m,*u,*u")
+	(lshiftrt:SI (match_operand:SI 1 "nonimmediate_operand" "0,m,*u,m,*u,m")
 	             (const_int 1)))
-   (clobber (match_scratch:HI 2 "=X,&d,&d"))]
+   (clobber (match_scratch:HI 2 "=X,X,X,&d,&d,&d"))]
    ""
    "*
 {
   CC_STATUS_INIT;
   if (X_REG_P (operands[1]))
     {
+      if (TARGET_M68S12X)
+        {
+          return \"lsrx\\n\\trora\\n\\trorb\";
+        }
+      else
+        {
       return \"xgdx\\n\\tlsrd\\n\\txgdx\\n\\trora\\n\\trorb\";
+        }
     }
   else
     {
@@ -5461,7 +5900,7 @@
 	(lshiftrt:SI (match_dup 0)
 	             (match_operand:HI 1 "const_int_operand" "")))
    (clobber (match_scratch:HI 2 "=y"))]
-   ""
+   "TARGET_M6811 /* See *lshrsi3 note.  */"
    "*
 {
   CC_STATUS_INIT;
@@ -5471,7 +5910,7 @@
 (define_insn "*lshrsi3"
   [(set (match_operand:SI 0 "register_operand" "+D,D")
 	(lshiftrt:SI (match_dup 0)
-	             (match_operand:HI 1 "general_operand" "y,m")))
+	             (match_operand:HI 1 "general_operand" "y,mi")))
    (clobber (match_scratch:HI 2 "=1,X"))]
    ""
    "*
@@ -5482,8 +5921,13 @@
      and this conflicts with all reloads.  Since X, Y, Z are used there
      is not enough register in class A_REGS.
 
-     Assuming that 'operands[1]' does not refer to the stack (which 
-     is true for 68hc11 only, we save temporary the value of Y.  */
+     Assuming that 'operands[1]' does not refer to the stack (which
+     is true for 68hc11 only, we save temporary the value of Y.
+
+     For 68HC12 we must also accept a constant because Z register is
+     disabled when compiling with -fomit-frame-pointer.  We can come up
+     with a reload problem and the *lshrsi3_const pattern was disabled
+     for that reason.  */
   if (!Y_REG_P (operands[2]))
     {
       rtx ops[1];
@@ -5544,8 +5988,8 @@
 }")
 
 (define_insn "lshrhi3_const"
-  [(set (match_operand:HI 0 "nonimmediate_operand" "=d,d,!*A,!*A")
-	(lshiftrt:HI (match_operand:HI 1 "general_operand" "dm*A,!u,dm,!u")
+  [(set (match_operand:HI 0 "nonimmediate_noinc_operand" "=d,d,!*A,!*A")
+	(lshiftrt:HI (match_operand:HI 1 "nonimmediate_noinc_operand" "dm*A,!u,dm,!u")
 		     (match_operand:HI 2 "const_int_operand" "i,i,i,i")))]
   ""
   "*
@@ -5577,7 +6021,7 @@
           output_asm_insn (\"clra\", operands);
         }
       val -= 8;
-      switch (val) 
+      switch (val)
 	{
 	case 7:
 	  output_asm_insn (\"rolb\", operands);
@@ -5618,7 +6062,7 @@
       break;
 
     default:
-      while (val > 0) 
+      while (val > 0)
 	{
 	  val --;
 	  output_asm_insn (\"lsrd\", operands);
@@ -5649,8 +6093,8 @@
    "")
 
 (define_insn "*lshrqi3_const1"
-  [(set (match_operand:QI 0 "nonimmediate_operand" "=m,d,!u,!*q,!*A")
-	(lshiftrt:QI (match_operand:QI 1 "nonimmediate_operand" "0,0,0,0,0")
+  [(set (match_operand:QI 0 "nonimmediate_noinc_operand" "=m,d,!u,!*q,!*A")
+	(lshiftrt:QI (match_operand:QI 1 "nonimmediate_noinc_operand" "0,0,0,0,0")
 		     (const_int 1)))]
   ""
   "@
@@ -5727,7 +6171,7 @@
 (define_insn "*lshrqi3"
   [(set (match_operand:QI 0 "register_operand" "=d,!*q,!*A")
 	(lshiftrt:QI (match_operand:QI 1 "register_operand" "0,0,0")
-		     (match_operand:QI 2 "nonimmediate_operand" 
+		     (match_operand:QI 2 "nonimmediate_operand"
 					 "m*u*d*A,m*u*d*A,m*u")))]
   ""
   "*
@@ -5929,7 +6373,7 @@
   "z_replacement_completed == 2"
   [(parallel [(set (reg:HI D_REGNUM) (match_dup 0))
               (set (match_dup 0) (reg:HI D_REGNUM))])
-   (parallel [(set (reg:HI D_REGNUM) 
+   (parallel [(set (reg:HI D_REGNUM)
 		   (match_op_dup 3 [(reg:HI D_REGNUM) (match_dup 0)]))
 	      (clobber (match_dup 0))])
    (parallel [(set (reg:HI D_REGNUM) (match_dup 0))
@@ -5937,6 +6381,98 @@
   "")
 
 ;;--------------------------------------------------------------------
+;;-  Bit test and branch
+;;--------------------------------------------------------------------
+;; Logical and, test if zero and branch to use "brset/brclr" instruction
+;;
+(define_insn "brclr"
+  [(set (pc)
+	(if_then_else
+	  (eq (and:QI (match_operand:QI 0 "memory_operand" "R,Q")
+		      (match_operand:QI 1 "const_int_operand" ""))
+              (const_int 0))
+	 (label_ref (match_operand 2 "" ""))
+	 (pc)))
+   (clobber (match_scratch:HI 3 "=X,xy"))]
+  "0"
+  "*
+{
+  cc_status = cc_prev_status;
+  if (which_alternative == 0 || TARGET_M6812)
+    {
+      return \"brclr\\t%0,%1,%l2\";
+    }
+  else
+    {
+      rtx ops[3];
+
+      ops[0] = operands[3];
+      ops[1] = XEXP (operands[0], 0);
+      ops[2] = gen_label_rtx ();
+      output_asm_insn (\".relax\\t%l2\", ops);
+      m68hc11_gen_movhi (insn, ops);
+      output_asm_insn (\"brclr\\t0,%3,%1,%l2\", operands);
+      ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\",
+				 CODE_LABEL_NUMBER (ops[2]));
+      return \"\";
+    }
+}")
+
+(define_insn "brset"
+  [(set (pc)
+	(if_then_else
+	  (eq (and:QI (not:QI (match_operand:QI 0 "memory_operand" "R,Q"))
+		      (match_operand:QI 1 "const_int_operand" ""))
+              (const_int 0))
+	 (label_ref (match_operand 2 "" ""))
+	 (pc)))
+   (clobber (match_scratch:HI 3 "=X,xy"))]
+  "0"
+  "*
+{
+  cc_status = cc_prev_status;
+  if (which_alternative == 0 || TARGET_M6812)
+    {
+      return \"brset\\t%0,%1,%l2\";
+    }
+  else
+    {
+      rtx ops[3];
+
+      ops[0] = operands[3];
+      ops[1] = XEXP (operands[0], 0);
+      ops[2] = gen_label_rtx ();
+      output_asm_insn (\".relax\\t%l2\", ops);
+      m68hc11_gen_movhi (insn, ops);
+      output_asm_insn (\"brset\\t0,%3,%1,%l2\", operands);
+      ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\",
+				 CODE_LABEL_NUMBER (ops[2]));
+      return \"\";
+    }
+}")
+
+(define_peephole2
+  [(set (match_operand:QI 0 "hard_reg_operand" "")
+        (match_operand:QI 1 "memory_operand" "m"))
+   (set (cc0) (and:HI (match_operand:HI 2 "hard_reg_operand" "")
+	              (match_operand:HI 3 "const_int_operand" "")))
+   (set (pc)
+        (if_then_else (eq (cc0) (const_int 0))
+		      (label_ref (match_operand 4 "" ""))
+		      (pc)))]
+  "0 && REGNO (operands[0]) == REGNO (operands[2])
+   && peep2_reg_dead_p (2, operands[0])"
+  [(parallel [
+      (set (pc)
+        (if_then_else
+           (eq (and:QI (match_dup 1) (match_dup 3))
+               (const_int 0))
+	   (label_ref (match_dup 4))
+           (pc)))
+      (clobber (match_dup 5))])]
+  "operands[5] = gen_rtx_SCRATCH (HImode);")
+
+;;--------------------------------------------------------------------
 ;;-  68HC12 Decrement/Increment and branch
 ;;--------------------------------------------------------------------
 ;; These patterns are used by loop optimization as well as peephole2
@@ -5976,17 +6512,24 @@
     {
       FAIL;
     }
+
+  /* Note that for xxx_dbcc_dec_yy the gen_rtx_NE is only used to pass
+     the operator and its operands are not relevant.  */
   if (GET_MODE (operands[0]) == HImode)
     {
       emit_jump_insn (gen_m68hc12_dbcc_dec_hi (operands[0],
-					       gen_rtx (NE, HImode),
+					       gen_rtx (NE, HImode,
+						        operands[0],
+							operands[1]),
 					       operands[4]));
       DONE;
     }
   if (GET_MODE (operands[0]) == QImode)
     {
       emit_jump_insn (gen_m68hc12_dbcc_dec_qi (operands[0],
-					       gen_rtx (NE, QImode),
+					       gen_rtx (NE, QImode,
+						        operands[0],
+							operands[1]),
 					       operands[4]));
       DONE;
     }
@@ -6159,7 +6702,7 @@
   "
 {
   m68hc11_expand_compare_and_branch (EQ, m68hc11_compare_op0,
-				     m68hc11_compare_op1, 
+				     m68hc11_compare_op1,
 				     operands[0]);
   DONE;
 }")
@@ -6174,7 +6717,7 @@
   "
 {
   m68hc11_expand_compare_and_branch (NE, m68hc11_compare_op0,
-				     m68hc11_compare_op1, 
+				     m68hc11_compare_op1,
 				     operands[0]);
   DONE;
 }")
@@ -6189,7 +6732,7 @@
   "
 {
   m68hc11_expand_compare_and_branch (GT, m68hc11_compare_op0,
-				     m68hc11_compare_op1, 
+				     m68hc11_compare_op1,
 				     operands[0]);
   DONE;
 }")
@@ -6204,7 +6747,7 @@
   "
 {
   m68hc11_expand_compare_and_branch (GTU, m68hc11_compare_op0,
-				     m68hc11_compare_op1, 
+				     m68hc11_compare_op1,
 				     operands[0]);
   DONE;
 }")
@@ -6219,7 +6762,7 @@
   "
 {
   m68hc11_expand_compare_and_branch (LT, m68hc11_compare_op0,
-				     m68hc11_compare_op1, 
+				     m68hc11_compare_op1,
 				     operands[0]);
   DONE;
 }")
@@ -6234,7 +6777,7 @@
   "
 {
   m68hc11_expand_compare_and_branch (LTU, m68hc11_compare_op0,
-				     m68hc11_compare_op1, 
+				     m68hc11_compare_op1,
 				     operands[0]);
   DONE;
 }")
@@ -6249,7 +6792,7 @@
   "
 {
   m68hc11_expand_compare_and_branch (GE, m68hc11_compare_op0,
-				     m68hc11_compare_op1, 
+				     m68hc11_compare_op1,
 				     operands[0]);
   DONE;
 }")
@@ -6264,7 +6807,7 @@
   "
 {
   m68hc11_expand_compare_and_branch (GEU, m68hc11_compare_op0,
-				     m68hc11_compare_op1, 
+				     m68hc11_compare_op1,
 				     operands[0]);
   DONE;
 }")
@@ -6279,7 +6822,7 @@
   "
 {
   m68hc11_expand_compare_and_branch (LE, m68hc11_compare_op0,
-				     m68hc11_compare_op1, 
+				     m68hc11_compare_op1,
 				     operands[0]);
   DONE;
 }")
@@ -6294,14 +6837,14 @@
   "
 {
   m68hc11_expand_compare_and_branch (LEU, m68hc11_compare_op0,
-				     m68hc11_compare_op1, 
+				     m68hc11_compare_op1,
 				     operands[0]);
   DONE;
 }")
 
 ;;
 ;; Test and branch instructions for 68HC12 for EQ and NE.
-;; 'z' must not appear in the constraints because the z replacement 
+;; 'z' must not appear in the constraints because the z replacement
 ;; pass does not know how to restore the replacement register.
 ;;
 (define_insn "*tbeq"
@@ -6710,13 +7253,13 @@
   [(const_int 0)]
   ""
   "nop")
-    
+
 (define_expand "prologue"
   [(const_int 0)]
   ""
   "
 {
-  expand_prologue (); 
+  expand_prologue ();
   DONE;
 }")
 
@@ -6928,18 +7471,81 @@
 ;;
 ;; Replace "leas 2,sp" with a "pulx" or a "puly".
 ;; On 68HC12, this is one cycle slower but one byte smaller.
-;; pr target/6899: This peephole is not valid because a register CSE
-;; pass removes the pulx/puly.
+;; pr target/6899: This peephole was not valid because a register CSE
+;; pass removes the pulx/puly.  The 'use' clause ensure that the pulx is
+;; not removed.
 ;;
 (define_peephole2
   [(set (reg:HI SP_REGNUM) (plus:HI (reg:HI SP_REGNUM) (const_int 2)))
    (match_scratch:HI 0 "xy")]
-  "0 && TARGET_M6812 && optimize_size"
-  [(set (match_dup 0) (match_dup 1))]
+  "TARGET_M6812 && optimize_size"
+  [(set (match_dup 0) (match_dup 1))
+   (use (match_dup 0))]
   "operands[1] = gen_rtx (MEM, HImode,
 			  gen_rtx (POST_INC, HImode,
 				   gen_rtx_REG (HImode, HARD_SP_REGNUM)));")
 
+;; Replace: "pshx; tfr d,x; stx 0,sp" into "pshd; tfr d,x"
+;;
+;; PR 14542: emit a use to pretend we need the value of initial register.
+;; Otherwise verify_local_live_at_start will abort due to a live change
+;; of that register.
+;;
+(define_peephole2
+  [(set (mem:HI (pre_dec:HI (reg:HI SP_REGNUM)))
+        (match_operand:HI 0 "hard_reg_operand" ""))
+   (set (match_dup 0)
+        (match_operand:HI 1 "hard_reg_operand" ""))
+   (set (mem:HI (reg:HI SP_REGNUM))
+        (match_dup 0))]
+  "TARGET_M6812"
+  [(use (match_dup 0))
+   (set (mem:HI (pre_dec:HI (reg:HI SP_REGNUM)))
+        (match_dup 1))
+   (set (match_dup 0) (match_dup 1))]
+  "")
+
+;;
+;; Change: "ldd 0,sp; pulx" into  "puld"
+;; This sequence usually appears at end a functions.
+(define_peephole2
+  [(set (match_operand:HI 0 "hard_reg_operand" "")
+        (mem:HI (reg:HI SP_REGNUM)))
+   (use (match_dup 0))
+   (set (match_operand:HI 1 "hard_reg_operand" "")
+        (mem:HI (post_inc:HI (reg:HI SP_REGNUM))))]
+  "peep2_reg_dead_p (2, operands[1])"
+  [(set (match_dup 0) (mem:HI (post_inc:HI (reg:HI SP_REGNUM))))
+   (use (match_dup 0))]
+  "")
+
+;; Replace: "pshx; clr 0,sp; clr 1,sp" by "clr 1,-sp; clr 1,-sp"
+;; Appears to allocate local variables.
+(define_peephole2
+  [(set (mem:HI (pre_dec:HI (reg:HI SP_REGNUM)))
+        (match_operand:HI 0 "hard_reg_operand" ""))
+   (set (mem:QI (plus:HI (reg:HI SP_REGNUM) (const_int 1)))
+        (const_int 0))
+   (set (mem:QI (reg:HI SP_REGNUM))
+        (const_int 0))]
+  "TARGET_M6812"
+  [(set (mem:HI (pre_dec:HI (reg:HI SP_REGNUM)))
+        (const_int 0))]
+  "")
+
+;; Likewise for HI mode
+(define_peephole2
+  [(set (mem:HI (pre_dec:HI (reg:HI SP_REGNUM)))
+        (match_operand:HI 0 "hard_reg_operand" ""))
+   (set (mem:HI (reg:HI SP_REGNUM))
+        (const_int 0))]
+  "TARGET_M6812"
+  [(set (mem:HI (pre_dec:HI (reg:HI SP_REGNUM)))
+        (const_int 0))]
+  "")
+;;--------------------------------------------------------------------
+;;-
+;;--------------------------------------------------------------------
 ;;
 ;; Optimize memory<->memory moves when the value is also loaded in
 ;; a register.
@@ -6989,6 +7595,32 @@
    (set (match_dup 0) (match_dup 2))]
   "")
 
+;;--------------------------------------------------------------------
+;;-
+;;--------------------------------------------------------------------
+;; SCz 2005-05-08: this peephole2 is not finished.  I'm not sure it is
+;; valid in all cases.  Disabled but kept for documentation and futur fix.
+;; (optimize 8-bit move to/from the X or Y registers; the issue with
+;; the first (set) is that since operand 0 is either X or Y, we have to
+;; use the scratch _.tmp memory location; the peephole uses a stack location
+;; instead to save D and use D for the load)
+;;
+(define_peephole2
+  [(set (match_operand:QI 0 "hard_reg_operand" "")
+	(match_operand:QI 1 "memory_operand" ""))
+   (set (match_operand:QI 2 "memory_operand" "")
+        (match_dup 0))]
+  "0 && A_REG_P (operands[0]) && peep2_reg_dead_p (2, operands[0])
+   && !reg_mentioned_p (gen_rtx (REG, HImode, HARD_D_REGNUM), operands[1])
+   && !reg_mentioned_p (gen_rtx (REG, HImode, HARD_D_REGNUM), operands[1])
+   && !reg_mentioned_p (gen_rtx (REG, HImode, REGNO (operands[0])), operands[2])"
+  [(set (mem:QI (pre_dec:HI (reg:HI SP_REGNUM))) (reg:QI D_REGNUM))
+   (set (reg:QI D_REGNUM) (match_dup 1))
+   (set (match_dup 2) (reg:QI D_REGNUM))
+   (set (reg:QI D_REGNUM) (mem:QI (post_inc:HI (reg:HI SP_REGNUM))))
+   (use (reg:HI SP_REGNUM))]
+   "")
+
 ;;
 ;; Reorganize to optimize address computations.
 ;;
@@ -7004,6 +7636,36 @@
   "")
 
 ;;
+;; Replace: "ldx #N; xgdx; addd <var>; xgdx" by "ldab #N; ldx <var>; abx"
+;;
+(define_peephole2
+  [(set (match_operand:HI 0 "hard_reg_operand" "")
+	(match_operand:HI 1 "const_int_operand" ""))
+   (set (match_dup 0)
+	(plus:HI (match_dup 0)
+	         (match_operand:HI 2 "general_operand" "")))
+   (match_scratch:QI 3 "d")]
+  "TARGET_M6811 && (INTVAL (operands[1]) >= 0 && INTVAL (operands[1]) <= 0x0ff)"
+  [(set (match_dup 3) (match_dup 4))
+   (set (match_dup 0) (match_dup 2))
+   (set (match_dup 0) (plus:HI (zero_extend:HI (match_dup 3)) (match_dup 0)))]
+  "operands[4] = m68hc11_gen_lowpart (QImode, operands[1]);")
+
+;;
+;; Replace: "ldx #N; xgdx; addd <var>; xgdx" by "ldab #N; ldx <var>; abx"
+;;
+(define_peephole2
+  [(set (match_operand:HI 0 "hard_reg_operand" "")
+	(match_operand:HI 1 "const_int_operand" ""))
+   (set (match_dup 0)
+	(plus:HI (match_dup 0)
+	         (match_operand:HI 2 "general_operand" "")))]
+  "TARGET_M6812"
+  [(set (match_dup 0) (match_dup 2))
+   (set (match_dup 0) (plus:HI (match_dup 0) (match_dup 1)))]
+  "")
+
+;;
 ;; Optimize an address register increment and a compare to use
 ;; a PRE_INC or PRE_DEC addressing mode (disabled on the tst insn
 ;; before reload, but can be enabled after).
@@ -7095,6 +7757,31 @@
   "")
 
 ;;
+;;
+;;
+(define_peephole2
+  [(parallel
+     [(set (match_operand:SI 0 "hard_reg_operand" "")
+	(ashift:SI (match_operand:SI 1 "general_operand" "")
+		   (const_int 1)))
+      (clobber (match_scratch:HI 2 ""))])
+   (set (match_operand:HI 3 "nonimmediate_operand" "") (reg:HI D_REGNUM))
+   (set (match_operand:HI 4 "nonimmediate_operand" "") (reg:HI X_REGNUM))]
+  "!X_REG_P (operands[1])
+   && peep2_reg_dead_p (2, gen_rtx (REG, HImode, D_REGNUM))
+   && peep2_reg_dead_p (3, gen_rtx (REG, HImode, X_REGNUM))"
+  [(set (reg:HI D_REGNUM) (match_dup 5))
+   (set (reg:HI D_REGNUM) (ashift:HI (reg:HI D_REGNUM) (const_int 1)))
+   (set (match_dup 3) (reg:HI D_REGNUM))
+   (set (reg:HI D_REGNUM) (match_dup 6))
+   (parallel [(set (reg:HI D_REGNUM)
+		   (rotate:HI (reg:HI D_REGNUM) (const_int 1)))
+              (clobber (reg:HI CC_REGNUM))])
+   (set (match_dup 4) (reg:HI D_REGNUM))]
+  "operands[5] = m68hc11_gen_lowpart (HImode, operands[1]);
+   operands[6] = m68hc11_gen_highpart (HImode, operands[1]);")
+
+;;
 ;; Replace a "ldd <mem>; psha; pshb" with a "ldx <mem>; pshx".
 ;;
 (define_peephole2
@@ -7109,6 +7796,25 @@
   "")
 
 ;;
+;; Remove one load when copying a value to/from memory and also
+;; to a register.  Take care not cloberring a possible register used
+;; by operand 2.
+;; Replace: "ldd 0,y; std 2,y; ldx 0,y" into "ldx 0,y; stx 2,y"
+;;
+(define_peephole2
+  [(set (match_operand:HI 0 "hard_reg_operand" "")
+        (match_operand:HI 1 "general_operand" ""))
+   (set (match_operand:HI 2 "nonimmediate_operand" "") (match_dup 0))
+   (set (match_operand:HI 3 "hard_reg_operand" "") (match_dup 1))]
+  "peep2_reg_dead_p (2, operands[0])
+   && !side_effects_p (operands[1])
+   && !side_effects_p (operands[2])
+   && !reg_mentioned_p (operands[3], operands[2])"
+  [(set (match_dup 3) (match_dup 1))
+   (set (match_dup 2) (match_dup 3))]
+  "")
+
+;;
 ;; Replace a "ldd <mem>; addd #N; std <mem>" into a
 ;; "ldx <mem>; leax; stx <mem>" if we have a free X/Y register
 ;; and the constant is small.
@@ -7122,7 +7828,7 @@
         (match_dup 0))
    (match_scratch:HI 4 "xy")]
   "D_REG_P (operands[0])
-   && (TARGET_M6812 
+   && (TARGET_M6812
        || (INTVAL (operands[2]) >= -2 && INTVAL (operands[2]) <= 2))
    && peep2_reg_dead_p (3, operands[0])"
   [(set (match_dup 4) (match_dup 1))
@@ -7131,9 +7837,177 @@
   "if (reg_mentioned_p (operands[4], operands[1])) FAIL;
    if (reg_mentioned_p (operands[4], operands[3])) FAIL;")
 
+;;--------------------------------------------------------------------
+;;- Bset peephole2
+;;--------------------------------------------------------------------
+;; These peepholes try to replace some logical sequences by 'bset' and 'bclr'.
+;;
+;; Replace 'ldab <mem>; orab #N; stab <mem>' by 'bset <mem> #N'.
+;; Register D must be dead and there must be no register side effects for mem.
+;; The <mem> *can* be volatile this is why we must not use 'side_effects_p'.
+;; The good side effect is that it makes the sequence atomic.
+;;
+(define_peephole2
+  [(set (match_operand:QI 0 "hard_reg_operand" "")
+	(match_operand:QI 1 "nonimmediate_operand" ""))
+   (set (match_dup 0) (ior:QI (match_dup 0)
+			      (match_operand:QI 2 "const_int_operand" "")))
+   (set (match_dup 1) (match_dup 0))]
+  "(TARGET_M6812 || m68hc11_indirect_p (operands[1], QImode))
+   && (GET_CODE (operands[1]) != MEM || !auto_inc_p (XEXP (operands[1], 0)))
+   && peep2_reg_dead_p (3, operands[0])"
+  [(set (match_dup 1) (ior:QI (match_dup 1) (match_dup 2)))]
+  "")
+
+(define_peephole2
+  [(set (match_operand:HI 0 "hard_reg_operand" "")
+	(match_operand:HI 1 "nonimmediate_operand" ""))
+   (set (match_dup 0) (ior:HI (match_dup 0)
+			      (match_operand:HI 2 "const_int_operand" "")))
+   (set (match_dup 1) (match_dup 0))]
+  "(TARGET_M6812 || m68hc11_indirect_p (operands[1], HImode))
+   && (GET_CODE (operands[1]) != MEM || !auto_inc_p (XEXP (operands[1], 0)))
+   && peep2_reg_dead_p (3, operands[0])"
+  [(set (match_dup 1) (ior:HI (match_dup 1) (match_dup 2)))]
+  "")
+
+;;--------------------------------------------------------------------
+;;- Bclr peephole2
+;;--------------------------------------------------------------------
+;; Replace 'ldab <mem>; andab #N; stab <mem>' by 'bclr <mem> #N'.
+;; See Bset peephole2.
+;;
+(define_peephole2
+  [(set (match_operand:QI 0 "hard_reg_operand" "")
+	(match_operand:QI 1 "nonimmediate_operand" ""))
+   (set (match_dup 0) (and:QI (match_dup 0)
+			      (match_operand:QI 2 "const_int_operand" "")))
+   (set (match_dup 1) (match_dup 0))]
+  "(TARGET_M6812 || m68hc11_indirect_p (operands[1], QImode))
+   && (GET_CODE (operands[1]) != MEM || !auto_inc_p (XEXP (operands[1], 0)))
+   && peep2_reg_dead_p (3, operands[0])"
+  [(set (match_dup 1) (and:QI (match_dup 1) (match_dup 2)))]
+  "")
+
+(define_peephole2
+  [(set (match_operand:HI 0 "hard_reg_operand" "")
+	(match_operand:HI 1 "nonimmediate_operand" ""))
+   (set (match_dup 0) (and:HI (match_dup 0)
+			      (match_operand:HI 2 "const_int_operand" "")))
+   (set (match_dup 1) (match_dup 0))]
+  "(TARGET_M6812 || m68hc11_indirect_p (operands[1], HImode))
+   && (GET_CODE (operands[1]) != MEM || !auto_inc_p (XEXP (operands[1], 0)))
+   && peep2_reg_dead_p (3, operands[0])"
+  [(set (match_dup 1) (and:HI (match_dup 1) (match_dup 2)))]
+  "")
+
+
+;;--------------------------------------------------------------------
+;;- Compare peephole2
+;;--------------------------------------------------------------------
+(define_peephole2
+  [(set (match_operand:HI 0 "hard_reg_operand" "")
+	(match_operand:HI 1 "hard_reg_operand" ""))
+   (set (match_dup 1) (plus:HI (match_dup 1)
+                               (match_operand:HI 2 "const_int_operand" "")))
+   (set (cc0) (match_dup 0))]
+  "peep2_reg_dead_p (3, operands[0]) && !Z_REG_P (operands[1])"
+  [(set (match_dup 1) (plus:HI (match_dup 1) (match_dup 2)))
+   (set (cc0) (compare (match_dup 1) (match_dup 2)))]
+  "")
+
+(define_peephole2
+  [(set (match_operand:HI 0 "hard_reg_operand" "")
+	(match_operand:HI 1 "hard_reg_operand" ""))
+   (set (match_operand:HI 2 "hard_reg_operand" "")
+        (plus:HI (match_dup 2)
+                 (match_operand:HI 3 "const_int_operand" "")))
+   (set (match_operand:HI 4 "memory_operand" "") (match_dup 2))
+   (set (cc0) (match_operand:HI 5 "hard_reg_operand" ""))]
+  "peep2_reg_dead_p (4, operands[5]) && !Z_REG_P (operands[2])
+   && !reg_mentioned_p (operands[2], operands[4])
+
+   && ((rtx_equal_p (operands[5], operands[0])
+        && rtx_equal_p (operands[2], operands[1]))
+
+       || (rtx_equal_p (operands[5], operands[1])
+           && rtx_equal_p (operands[2], operands[0])))"
+  [(set (match_dup 2) (match_dup 1))
+   (set (match_dup 2) (plus:HI (match_dup 2) (match_dup 3)))
+   (set (match_dup 4) (match_dup 2))
+   (set (cc0) (compare (match_dup 2) (match_dup 3)))]
+  "")
+
+
+;;--------------------------------------------------------------------
+;;- Load peephole2
+;;--------------------------------------------------------------------
+;;
+;; Optimize initialization of 2 hard regs from the same memory location
+;; Since we can't copy easily X, Y and D to each other, load the 2 registers
+;; from the same memory location.
+;;
+(define_peephole2
+  [(set (match_operand:HI 0 "hard_reg_operand" "")
+	(match_operand:HI 1 "memory_operand" ""))
+   (set (match_operand:HI 2 "hard_reg_operand" "") (match_dup 0))]
+  "TARGET_M6811
+   && !side_effects_p (operands[1])
+   && !reg_mentioned_p (operands[0], operands[1])"
+  [(set (match_dup 0) (match_dup 1))
+   (set (match_dup 2) (match_dup 1))]
+  "")
+
+;; Replace "ldd #N; addd <op>" with "ldd <op>; addd #N".
+;;
+(define_peephole2
+  [(set (match_operand:HI 0 "nonimmediate_operand" "") (const_int 0))
+   (set (match_operand:HI 1 "nonimmediate_operand" "") (const_int 0))
+   (set (match_operand:HI 2 "nonimmediate_operand" "") (const_int 0))
+   (set (match_operand:HI 3 "nonimmediate_operand" "") (const_int 0))
+   (match_scratch:HI 4 "d")]
+  ""
+  [(set (match_dup 4) (const_int 0))
+   (set (match_dup 0) (match_dup 4))
+   (set (match_dup 1) (match_dup 4))
+   (set (match_dup 2) (match_dup 4))
+   (set (match_dup 3) (match_dup 4))]
+  "")
+
+;;
+;; Replace "ldd #N; addd <op>" with "ldd <op>; addd #N".
+;;
+(define_peephole2
+  [(set (match_operand:HI 0 "nonimmediate_operand" "") (const_int 0))
+   (set (match_operand:HI 1 "nonimmediate_operand" "") (const_int 0))
+   (set (match_operand:HI 2 "nonimmediate_operand" "") (const_int 0))
+   (match_scratch:HI 3 "d")]
+  ""
+  [(set (match_dup 3) (const_int 0))
+   (set (match_dup 0) (match_dup 3))
+   (set (match_dup 1) (match_dup 3))
+   (set (match_dup 2) (match_dup 3))]
+  "")
+
+;;
+;; Replace "ldd #N; addd <op>" with "ldd <op>; addd #N".
+;;
+(define_peephole2
+  [(set (match_operand:HI 0 "hard_reg_operand" "") (const_int 0))
+   (set (match_operand:HI 1 "push_operand" "") (match_dup 0))
+   (set (match_operand:HI 2 "push_operand" "") (match_dup 0))
+   (set (match_operand:HI 3 "push_operand" "") (match_dup 0))
+   (match_scratch:HI 4 "x")]
+  "TARGET_M6811 && D_REG_P (operands[0]) && peep2_reg_dead_p (4, operands[0])"
+  [(set (match_dup 4) (const_int 0))
+   (set (match_dup 1) (match_dup 4))
+   (set (match_dup 2) (match_dup 4))
+   (set (match_dup 3) (match_dup 4))]
+  "")
+
 ;;
 ;; This peephole catches the address computations generated by the reload
-;; pass. 
+;; pass.
 (define_peephole
   [(set (match_operand:HI 0 "hard_reg_operand" "xy")
 	(match_operand:HI 1 "const_int_operand" ""))
@@ -7189,6 +8063,8 @@
 }
 ")
 
+;; SCz 2005-04-03: this peephole is not valid anymore because it appears
+;; we can't rely on the REG_DEAD note
 (define_peephole
   [(set (match_operand:HI 0 "hard_reg_operand" "h")
 	(match_operand:HI 1 "non_push_operand" "g"))
@@ -7279,7 +8155,7 @@
 
 ;;;
 ;;; Catch an xgdx/xgdy followed by a (set D X/Y). If X/Y is dead, we don't
-;;; need to emit anything. Otherwise, we just need an copy of D to X/Y.
+;;; need to emit anything. Otherwise, we just need a copy of D to X/Y.
 ;;;
 (define_peephole
   [(parallel [(set (reg:HI D_REGNUM) (match_operand:HI 0 "hard_reg_operand" "A"))
@@ -7295,7 +8171,7 @@
 
 ;;;
 ;;; Catch an xgdx/xgdy followed by a (set D X/Y). If X/Y is dead, we don't
-;;; need to emit anything. Otherwise, we just need an copy of D to X/Y.
+;;; need to emit anything. Otherwise, we just need a copy of D to X/Y.
 ;;;
 (define_peephole
   [(parallel [(set (reg:HI D_REGNUM) (match_operand:HI 0 "hard_reg_operand" "A"))
@@ -7400,3 +8276,41 @@
   return \"sts\\t%t0\\n\\tld%0\\t%t0\";
 }
 ")
+
+(define_peephole
+  [(set (match_operand:HI 0 "hard_reg_operand" "")
+	(match_operand:HI 1 "memory_operand" ""))
+   (set (match_operand:HI 2 "hard_reg_operand" "") (match_dup 0))]
+  "TARGET_M6811
+   && !side_effects_p (operands[1])
+   && !reg_mentioned_p (operands[0], operands[1])"
+  "*
+{
+  rtx ops[2];
+
+  ops[0] = operands[0];
+  ops[1] = operands[1];
+  m68hc11_gen_movhi (insn, ops);
+  ops[0] = operands[2];
+  m68hc11_gen_movhi (insn, ops);
+  return \"\";
+}")
+
+;; Peephole for Z register replacement.
+;; Avoid to use _.tmp register when comparing D and X if we can compare
+;; with soft register
+(define_peephole
+  [(set (match_operand:HI 0 "hard_reg_operand" "") (reg:HI SOFT_XY_REGNUM))
+   (set (reg:HI SOFT_TMP_REGNUM) (match_dup 0))
+   (set (cc0) (compare (match_operand:HI 2 "hard_reg_operand" "")
+                       (reg:HI SOFT_TMP_REGNUM)))]
+  "X_REG_P (operands[0]) || Y_REG_P (operands[0])"
+  "*
+{
+  rtx ops[2];
+
+  ops[0] = operands[0];
+  ops[1] = operands[1];
+  m68hc11_gen_movhi (insn, ops);
+  return \"cp%2\\t%1\";
+}")
--- a/gcc/config/m68hc11/m68hc12.h
+++ b/gcc/config/m68hc11/m68hc12.h
@@ -19,11 +19,13 @@
 the Free Software Foundation, 59 Temple Place - Suite 330,
 Boston, MA 02111-1307, USA.  */
 
-/* Compile and assemble for a 68hc12 unless there is a -m68hc11 option.  */
+/* Default to compile and assemble for a 68hc12 */
 #define ASM_SPEC                                                \
 "%{m68hc11:-m68hc11}"                                           \
+"%{m6812:-m68hc12}"                                         \
 "%{m68hcs12:-m68hcs12}"                                         \
-"%{!m68hc11:%{!m68hcs12:-m68hc12}}"
+"%{m9s12x:-mm9s12x}"                                         \
+"%{!m68hc11:%{!m68hcs12:%{!m9s12x:-m68hc12}}}"
 #define LIB_SPEC       ""
 #define CC1_SPEC       ""
 
@@ -31,19 +33,23 @@
    emulation option.  This can be overriden by -Wl option of gcc.  */
 #define LINK_SPEC                                               \
 "%{m68hc11:-m m68hc11elf}"                                      \
+"%{m9s12x:-m m9s12xelf}"                                     \
 "%{m68hcs12:-m m68hc12elf}"                                     \
-"%{!m68hc11:%{!m68hcs12:-m m68hc11elf}} %{mrelax:-relax}"
+"%{!m68hc11:%{!m68hcs12:%{!m9s12x:-m m68hc11elf}} %{mrelax:-relax}"
 
 #define CPP_SPEC  \
 "%{mshort:-D__HAVE_SHORT_INT__ -D__INT__=16}\
  %{!mshort:-D__INT__=32}\
  %{m68hc11:-Dmc6811 -DMC6811 -Dmc68hc11}\
- %{!m68hc11:%{!m68hc12:-Dmc6812 -DMC6812 -Dmc68hc12}}\
+ %{m68hc12:-Dmc6812 -DMC6812 -Dmc68hc12}\
+ %{m9s12x:-Dmc6812 -DMC6812 -Dmc68hcs12 -Dm9s12x}\
  %{m68hcs12:-Dmc6812 -DMC6812 -Dmc68hcs12}\
- %{!m68hc11:-Dmc6812 -DMC6812 -Dmc68hc12}\
+ %{!m68hc11:%{!m68hc12:%{!m9s12x:-Dmc6812 -DMC6812 -Dmc68hc12 -m68hc12}}}\
  %{fshort-double:-D__HAVE_SHORT_DOUBLE__}"
 
 /* Default target_flags if no switches specified.  */
 #define TARGET_DEFAULT		(MASK_M6812)
 
 #define TARGET_M68HC12
+
+#define CPP_PREDEFINES		"-Dmc68hc1x -Dtarget12"
--- /dev/null
+++ b/gcc/config/m68hc11/m9s12x.h
@@ -0,0 +1,59 @@
+/* Definitions of target machine for GNU compiler, for m68hc12.
+   Copyright (C) 1999, 2000, 2001, 2003 Free Software Foundation, Inc.
+   Contributed by Stephane Carrez (stcarrez@nerim.fr).
+
+This file is part of GNU CC.
+
+GNU CC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU CC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU CC; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+/* Default to compile and assemble for a m9s12x */
+#define ASM_SPEC                                                \
+"%{m68hc11:-m68hc11}"                                           \
+"%{m6812:-m68hc12}"                                         \
+"%{m9s12x:-mm9s12x}"                                         \
+"%{m68hcs12:-m68hcs12}"                                         \
+"%{!m68hc11:%{!m68hcs12:%{!m68hc12: -mm9s12x}}}"
+/* last line was "%{!m68hc11:%{!m68hcs12:%{!m68hc12:%{!m9s12x:-mm9s12x}}}}" */
+#define LIB_SPEC       ""
+#define CC1_SPEC       ""
+
+/* We need to tell the linker the target elf format.  Just pass an
+   emulation option.  This can be overriden by -Wl option of gcc.  */
+#define LINK_SPEC                                               \
+"%{m68hc11:-m m68hc11elf}"                                      \
+"%{m9s12x:-m m68hc12elf}"                                     \
+"%{m68hcs12:-m m68hc12elf}"                                     \
+"%{!m68hc11:%{!m68hcs12:%{!m9s12x:-m m68hc11elf}}} %{mrelax:-relax}"
+
+#define CPP_SPEC  \
+"%{mshort:-D__HAVE_SHORT_INT__ -D__INT__=16}\
+ %{!mshort:-D__INT__=32}\
+ %{m68hc11:-Dmc68hc11}\
+ %{m68hc12:-Dmc68hc12 -Dm68hc12}\
+ %{m9s12x:-Dmc68hc12 -Dmc68hcs12 -Dm9s12x -m9s12x}\
+ %{m68hcs12:-Dmc6812 -DMC6812 -Dmc68hc12 -Dmc68hcs12}\
+ %{!m68hc11:%{!m68hc12:%{!m68hcs12:-Dmc68hc12 -Dmc68hcs12 -Dm9s12x -m9s12x}}}\
+ %{fshort-double:-D__HAVE_SHORT_DOUBLE__}"
+/* penultimate was %{!m68hc11:%{!m68hc12:%{!m68hcs12:%{!m9s12x:-Dmc6812 -DMC6812 -Dmc68hc12 -Dmc68hcs12 -Dm9s12x -m9s12x}}}} */
+
+/* Default target_flags if no switches specified. Just causes problems if defaulting to S12X */
+#define TARGET_DEFAULT		(MASK_M6812)
+
+#define TARGET_M68HC12
+
+#define MULTILIB_DEFAULTS { "m9s12x" }
+
+#define CPP_PREDEFINES		"-Dmc68hc1x -Dtargets12x"
--- a/gcc/config/m68hc11/t-m68hc11-gas
+++ b/gcc/config/m68hc11/t-m68hc11-gas
@@ -31,13 +31,14 @@
 
 # C implementation of 32-bit div/mod.
 LIB2FUNCS_EXTRA = $(srcdir)/config/udivmodsi4.c \
-	$(srcdir)/config/divmod.c $(srcdir)/config/udivmod.c
+	$(srcdir)/config/divmod.c $(srcdir)/config/udivmod.c \
+	$(srcdir)/config/m68hc11/ldivmod.asm
 
 # Don't compile with -g1 this reduces the size of some sections (.eh_frame).
 LIBGCC2_DEBUG_CFLAGS =-g
-LIBGCC2_CFLAGS = -Os -mrelax $(LIBGCC2_INCLUDES) $(TARGET_LIBGCC2_CFLAGS) $(LIBGCC2_DEBUG_CFLAGS) $(GTHREAD_FLAGS) -DIN_LIBGCC2
-
-MULTILIB_OPTIONS  = m68hc11/m68hc12 mshort fshort-double
+LIBGCC2_CFLAGS = -O -mrelax $(LIBGCC2_INCLUDES) $(TARGET_LIBGCC2_CFLAGS) $(LIBGCC2_DEBUG_CFLAGS) $(GTHREAD_FLAGS) -DIN_LIBGCC2
+# -m9s12x
+MULTILIB_OPTIONS  = m68hc11/m68hc12/m9s12x mshort fshort-double mlong-calls
 MULTILIB_DIRNAMES =
 MULTILIB_MATCHES  = m68hc11=m6811 m68hc12=m6812 m68hc12=m68hcs12
 MULTILIB_EXCEPTIONS = -mnoshort -mno68hc11
--- a/gcc/config/m68k/mot3300-crt0.S
+++ b/gcc/config/m68k/mot3300-crt0.S
@@ -93,6 +93,6 @@
 	COMM	splimit%,4
 	COMM	environ,4
 
-	IDENT ("$Id: mot3300-crt0.S,v 1.2 1998/12/16 21:07:03 law Exp $")
+	IDENT ("$Id: mot3300-crt0.S,v 1.1 2012/05/02 15:45:37 jsmcortina Exp $")
 	IDENT ("Contributed by Manfred Hollstein (manfred@lts.sel.alcatel.de)")
 	IDENT ("Corrections by Philippe De Muyter (phdm@macqel.be)")
--- a/gcc/config/m68k/mot3300Mcrt0.S
+++ b/gcc/config/m68k/mot3300Mcrt0.S
@@ -137,6 +137,6 @@
 	COMM	environ,4
 	COMM	_countbase,4
 
-	IDENT ("$Id: mot3300Mcrt0.S,v 1.2 1998/12/16 21:07:05 law Exp $")
+	IDENT ("$Id: mot3300Mcrt0.S,v 1.1 2012/05/02 15:45:37 jsmcortina Exp $")
 	IDENT ("Contributed by Manfred Hollstein (manfred@lts.sel.alcatel.de)")
 	IDENT ("Corrections by Philippe De Muyter (phdm@macqel.be)")
--- a/gcc/config/udivmod.c
+++ b/gcc/config/udivmod.c
@@ -1,14 +1,36 @@
-long udivmodsi4 ();
+/* cover the root directory case */
+#if !defined(mc68hc11) && !defined(mc68hc12) && !defined(m9s12x)
+#if defined(target11)
+#define mc68hc11
+#endif
+#if defined(target12)
+#define mc68hc12
+#endif
+#if defined(targets12x)
+#define m9s12x
+#define mc68hc12
+#endif
+#endif
 
-long
-__udivsi3 (long a, long b)
+#ifndef mc68hc12
+extern unsigned long __udivmodsi4 (unsigned long num, unsigned long den,
+                                   unsigned long *mod);
+
+unsigned long
+__inline __udivsi3 (unsigned long a, unsigned long b)
 {
-  return udivmodsi4 (a, b, 0);
+  return __udivmodsi4 (a, b, 0);
 }
 
-long
-__umodsi3 (long a, long b)
+unsigned long
+__inline __umodsi3 (unsigned long a, unsigned long b)
 {
-  return udivmodsi4 (a, b, 1);
+  unsigned long mod;
+
+  __udivmodsi4 (a, b, &mod);
+  return mod;
 }
 
+
+
+#endif /* !mc68hc12 */
--- a/gcc/config/udivmodsi4.c
+++ b/gcc/config/udivmodsi4.c
@@ -1,10 +1,71 @@
+#if !defined(mc68hc11) && !defined(mc68hc12) && !defined(m9s12x)
+#if defined(target11)
+#define mc68hc11
+#endif
+#if defined(target12)
+#define mc68hc12
+#endif
+#if defined(targets12x)
+#define m9s12x
+#define mc68hc12
+#endif
+#endif
+
+#ifndef mc68hc12
 unsigned long
-udivmodsi4(unsigned long num, unsigned long den, int modwanted)
+__udivmodsi4 (unsigned long num, unsigned long den, unsigned long* mod)
 {
-  unsigned long bit = 1;
-  unsigned long res = 0;
+  unsigned long bit;
+  unsigned long res;
+
+  if ((unsigned short) (den >> 16) == 0)
+    {
+#ifdef mc68hc11
+      if ((unsigned short) (num >> 16) == 0)
+        {
+          /* Both numbers are 16-bit quantities, use 16-bit div/mod.  */
+          unsigned short sden = (unsigned short) den;
+          unsigned short snum = (unsigned short) num;
+          unsigned short sres = snum / sden;
+          unsigned short smod = snum % sden;;
+
+          if (mod)
+            *mod = (unsigned long) smod;
+          return (unsigned long) sres;
+        }
+#endif
+#ifdef mc68hc12
+        {
+          /* To avoid to stress the gcc reload, use + operand modifier
+             and pass the input values in the same variables as the
+             outputs.  */
+          unsigned short status = (unsigned short) den;
+          unsigned short smod = (unsigned short) (num & 0x0ffff);
+          unsigned short sres = (unsigned short) (num >> 16);
 
-  while (den < num && bit && !(den & (1L<<31)))
+          __asm__ __volatile__ ("ediv\n"
+                                "tfr ccr,x"
+                                : "+x" (status), "+y" (sres),
+                                  "+d" (smod));
+          /* check for overflow */
+          if (!(status & 0x03))
+            {
+              if (mod)
+                *mod = (unsigned long) smod;
+              return (unsigned long) sres;
+            }
+        }
+#endif
+      if ((unsigned short) den == 0)
+        {
+          if (mod)
+            *mod = 0;
+          return 0;
+        }
+    }
+  bit = 1;
+  res = 0;
+  while (den < num && !((unsigned short) (den >> 16) & (1L<<15)))
     {
       den <<=1;
       bit <<=1;
@@ -19,6 +80,28 @@
       bit >>=1;
       den >>=1;
     }
-  if (modwanted) return num;
+  if (mod)
+    *mod = num;
   return res;
 }
+
+#ifdef L_udivmodsi4
+unsigned long
+udivmodsi4 (unsigned long num, unsigned long den, int modwanted)
+{
+  unsigned long mod;
+
+  if (modwanted)
+    {
+      __udivmodsi4 (num, den, &mod);
+      return mod;
+    }
+  else
+    {
+      return __udivmodsi4 (num, den, 0);
+    }
+}
+#endif
+
+#endif /*!mc68hc12 */
+
--- a/gcc/cppdefault.c
+++ b/gcc/cppdefault.c
@@ -76,11 +76,15 @@
 
 #ifdef GCC_INCLUDE_DIR
 const char cpp_GCC_INCLUDE_DIR[] = GCC_INCLUDE_DIR;
+#if GNU_HC1X_DONT_PATCH
 const size_t cpp_GCC_INCLUDE_DIR_len = sizeof GCC_INCLUDE_DIR - 8;
+#endif
 #else
 const char cpp_GCC_INCLUDE_DIR[] = "";
+#if GNU_HC1X_DONT_PATCH
 const size_t cpp_GCC_INCLUDE_DIR_len = 0;
 #endif
+#endif
 
 #ifdef TARGET_SYSTEM_ROOT
 const char *cpp_SYSROOT = TARGET_SYSTEM_ROOT;
--- a/gcc/cppdefault.h
+++ b/gcc/cppdefault.h
@@ -67,7 +67,17 @@
 
 extern const struct default_include cpp_include_defaults[];
 extern const char cpp_GCC_INCLUDE_DIR[];
+
+/* Don't use sizeof GCC_INCLUDE_DIR because for Mingw32 we patch the
+   executable to replace this path with the good path.  We must then
+   use strlen() to find the correct length.  */
+#undef GNU_HC1X_DONT_PATCH
+#if GNU_HC1X_DONT_PATCH
 extern const size_t cpp_GCC_INCLUDE_DIR_len;
+#else
+#define cpp_GCC_INCLUDE_DIR_len \
+(strlen (cpp_GCC_INCLUDE_DIR) > 7 ? strlen (cpp_GCC_INCLUDE_DIR) - 7 : 0)
+#endif
 
 extern const char *cpp_SYSROOT;
 
--- a/gcc/doc/cpp.1
+++ b/gcc/doc/cpp.1
@@ -1,15 +1,7 @@
-.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.14
+.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
 .\"
 .\" Standard preamble:
 .\" ========================================================================
-.de Sh \" Subsection heading
-.br
-.if t .Sp
-.ne 5
-.PP
-\fB\\$1\fR
-.PP
-..
 .de Sp \" Vertical space (when we can't use .PP)
 .if t .sp .5v
 .if n .sp
@@ -25,11 +17,11 @@
 ..
 .\" Set up some character translations and predefined strings.  \*(-- will
 .\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
-.\" double quote, and \*(R" will give a right double quote.  | will give a
-.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
-.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
-.\" expand to `' in nroff, nothing in troff, for use with C<>.
-.tr \(*W-|\(bv\*(Tr
+.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
+.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
+.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
+.\" nothing in troff, for use with C<>.
+.tr \(*W-
 .ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
 .ie n \{\
 .    ds -- \(*W-
@@ -48,22 +40,25 @@
 .    ds R" ''
 'br\}
 .\"
+.\" Escape single quotes in literal strings from groff's Unicode transform.
+.ie \n(.g .ds Aq \(aq
+.el       .ds Aq '
+.\"
 .\" If the F register is turned on, we'll generate index entries on stderr for
-.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
+.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
 .\" entries marked with X<> in POD.  Of course, you'll have to process the
 .\" output yourself in some meaningful fashion.
-.if \nF \{\
+.ie \nF \{\
 .    de IX
 .    tm Index:\\$1\t\\n%\t"\\$2"
 ..
 .    nr % 0
 .    rr F
 .\}
-.\"
-.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
-.\" way too many mistakes in technical documents.
-.hy 0
-.if n .na
+.el \{\
+.    de IX
+..
+.\}
 .\"
 .\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
 .\" Fear.  Run.  Save yourself.  No user-serviceable parts.
@@ -129,7 +124,11 @@
 .\" ========================================================================
 .\"
 .IX Title "CPP 1"
-.TH CPP 1 "2005-05-03" "gcc-3.3.6" "GNU"
+.TH CPP 1 "2013-10-10" "gcc-3.3.6-9s12x-20120502" "GNU"
+.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
+.\" way too many mistakes in technical documents.
+.if n .ad l
+.nh
 .SH "NAME"
 cpp \- The C Preprocessor
 .SH "SYNOPSIS"
@@ -180,7 +179,7 @@
 of a program which does not expect them.  To get strict \s-1ISO\s0 Standard C,
 you should use the \fB\-std=c89\fR or \fB\-std=c99\fR options, depending
 on which version of the standard you want.  To get all the mandatory
-diagnostics, you must also use \fB\-pedantic\fR.  
+diagnostics, you must also use \fB\-pedantic\fR.
 .PP
 This manual describes the behavior of the \s-1ISO\s0 preprocessor.  To
 minimize gratuitous differences, where the \s-1ISO\s0 preprocessor's
@@ -384,7 +383,7 @@
 slight change in semantics from \s-1GCC\s0 versions 3.0 and earlier.
 .IP "\fB\-MF\fR \fIfile\fR" 4
 .IX Item "-MF file"
-@anchor{\-MF}
+\&\f(CW@anchor\fR{\-MF}
 When used with \fB\-M\fR or \fB\-MM\fR, specifies a
 file to write the dependencies to.  If no \fB\-MF\fR switch is given
 the preprocessor sends the rules to the same place it would have sent
@@ -414,9 +413,7 @@
 .Sp
 .Vb 1
 \&        test.o: test.c test.h
-.Ve
-.Sp
-.Vb 1
+\&
 \&        test.h:
 .Ve
 .IP "\fB\-MT\fR \fItarget\fR" 4
@@ -475,7 +472,7 @@
 .IP "\fB\-x assembler-with-cpp\fR" 4
 .IX Item "-x assembler-with-cpp"
 .PD
-Specify the source language: C, \*(C+, Objective\-C, or assembly.  This has
+Specify the source language: C, \*(C+, Objective-C, or assembly.  This has
 nothing to do with standards conformance or extensions; it merely
 selects which base syntax to expect.  If you give none of these options,
 cpp will deduce the language from the extension of the source file:
@@ -678,7 +675,7 @@
 Assuming you have no file \fIfoo.h\fR, the command
 .Sp
 .Vb 1
-\&        touch foo.h; cpp -dM foo.h
+\&        touch foo.h; cpp \-dM foo.h
 .Ve
 .Sp
 will show all the predefined macros.
@@ -738,7 +735,7 @@
 .IP "\fB\-remap\fR" 4
 .IX Item "-remap"
 Enable special code to work around file systems which only permit very
-short file names, such as \s-1MS\-DOS\s0.
+short file names, such as MS-DOS.
 .IP "\fB\-\-help\fR" 4
 .IX Item "--help"
 .PD 0
--- a/gcc/doc/extend.texi
+++ b/gcc/doc/extend.texi
@@ -2528,11 +2528,14 @@
 
 On 68HC11 the compiler will generate a sequence of instructions
 to invoke a board-specific routine to switch the memory bank and call the
-real function. The board-specific routine simulates a @code{call}.
+real function.  The board-specific routine simulates a @code{call}.
 At the end of a function, it will jump to a board-specific routine
-instead of using @code{rts}. The board-specific return routine simulates
+instead of using @code{rts}.  The board-specific return routine simulates
 the @code{rtc}.
 
+The @code{far} attribute must not be used when the @code{interrupt} or
+@code{trap} attributes are used.
+
 @item near
 @cindex functions which do not handle memory bank switching on 68HC11/68HC12
 On 68HC11 and 68HC12 the @code{near} attribute causes the compiler to
@@ -2540,6 +2543,21 @@
 This attribute can be used to cancel the effect of the @option{-mlong-calls}
 option.
 
+@item page0
+@cindex variables in page0 section for which direct addressing mode can be used
+On 68HC11 and 68HC12, the @code{page0} attribute indicates that a global
+or static variable is put in the @code{page0} section and the compiler can
+use the direct addressing mode.  On 68HC11 the compiler will be able to
+use @code{bset} and @code{bclr} on these variables.  Note that the @code{page0}
+is limited to the absolute address range @code{0}..@code{0x0ff}.
+
+@item trap
+@cindex functions which are used as trap handlers (@code{swi} or @code{trap})
+On 68HC11 and 68HC12, the @code{trap} attribute marks the function as being
+a trap handler.  It will use @code{rti} instead of @code{rts} to return
+from the function.  Offset of function parameters are also adjusted to take
+into account the trap frame.
+
 @item dllimport
 @cindex @code{__declspec(dllimport)}
 On Windows targets, the @code{dllimport} attribute causes the compiler
--- a/gcc/doc/fsf-funding.7
+++ b/gcc/doc/fsf-funding.7
@@ -1,15 +1,7 @@
-.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.14
+.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
 .\"
 .\" Standard preamble:
 .\" ========================================================================
-.de Sh \" Subsection heading
-.br
-.if t .Sp
-.ne 5
-.PP
-\fB\\$1\fR
-.PP
-..
 .de Sp \" Vertical space (when we can't use .PP)
 .if t .sp .5v
 .if n .sp
@@ -25,11 +17,11 @@
 ..
 .\" Set up some character translations and predefined strings.  \*(-- will
 .\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
-.\" double quote, and \*(R" will give a right double quote.  | will give a
-.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
-.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
-.\" expand to `' in nroff, nothing in troff, for use with C<>.
-.tr \(*W-|\(bv\*(Tr
+.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
+.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
+.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
+.\" nothing in troff, for use with C<>.
+.tr \(*W-
 .ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
 .ie n \{\
 .    ds -- \(*W-
@@ -48,22 +40,25 @@
 .    ds R" ''
 'br\}
 .\"
+.\" Escape single quotes in literal strings from groff's Unicode transform.
+.ie \n(.g .ds Aq \(aq
+.el       .ds Aq '
+.\"
 .\" If the F register is turned on, we'll generate index entries on stderr for
-.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
+.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
 .\" entries marked with X<> in POD.  Of course, you'll have to process the
 .\" output yourself in some meaningful fashion.
-.if \nF \{\
+.ie \nF \{\
 .    de IX
 .    tm Index:\\$1\t\\n%\t"\\$2"
 ..
 .    nr % 0
 .    rr F
 .\}
-.\"
-.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
-.\" way too many mistakes in technical documents.
-.hy 0
-.if n .na
+.el \{\
+.    de IX
+..
+.\}
 .\"
 .\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
 .\" Fear.  Run.  Save yourself.  No user-serviceable parts.
@@ -129,12 +124,16 @@
 .\" ========================================================================
 .\"
 .IX Title "FSF-FUNDING 7"
-.TH FSF-FUNDING 7 "2005-05-03" "gcc-3.3.6" "GNU"
+.TH FSF-FUNDING 7 "2013-10-10" "gcc-3.3.6-9s12x-20120502" "GNU"
+.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
+.\" way too many mistakes in technical documents.
+.if n .ad l
+.nh
 .SH "NAME"
 fsf\-funding \- Funding Free Software
 .SH "DESCRIPTION"
 .IX Header "DESCRIPTION"
-.Sh "Funding Free Software"
+.SS "Funding Free Software"
 .IX Subsection "Funding Free Software"
 If you want to have more free software a few years from now, it makes
 sense for you to help encourage people to contribute funds for its
--- a/gcc/doc/gcc.1
+++ b/gcc/doc/gcc.1
@@ -1,15 +1,7 @@
-.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.14
+.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
 .\"
 .\" Standard preamble:
 .\" ========================================================================
-.de Sh \" Subsection heading
-.br
-.if t .Sp
-.ne 5
-.PP
-\fB\\$1\fR
-.PP
-..
 .de Sp \" Vertical space (when we can't use .PP)
 .if t .sp .5v
 .if n .sp
@@ -25,11 +17,11 @@
 ..
 .\" Set up some character translations and predefined strings.  \*(-- will
 .\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
-.\" double quote, and \*(R" will give a right double quote.  | will give a
-.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
-.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
-.\" expand to `' in nroff, nothing in troff, for use with C<>.
-.tr \(*W-|\(bv\*(Tr
+.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
+.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
+.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
+.\" nothing in troff, for use with C<>.
+.tr \(*W-
 .ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
 .ie n \{\
 .    ds -- \(*W-
@@ -48,22 +40,25 @@
 .    ds R" ''
 'br\}
 .\"
+.\" Escape single quotes in literal strings from groff's Unicode transform.
+.ie \n(.g .ds Aq \(aq
+.el       .ds Aq '
+.\"
 .\" If the F register is turned on, we'll generate index entries on stderr for
-.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
+.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
 .\" entries marked with X<> in POD.  Of course, you'll have to process the
 .\" output yourself in some meaningful fashion.
-.if \nF \{\
+.ie \nF \{\
 .    de IX
 .    tm Index:\\$1\t\\n%\t"\\$2"
 ..
 .    nr % 0
 .    rr F
 .\}
-.\"
-.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
-.\" way too many mistakes in technical documents.
-.hy 0
-.if n .na
+.el \{\
+.    de IX
+..
+.\}
 .\"
 .\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
 .\" Fear.  Run.  Save yourself.  No user-serviceable parts.
@@ -129,7 +124,11 @@
 .\" ========================================================================
 .\"
 .IX Title "GCC 1"
-.TH GCC 1 "2005-05-03" "gcc-3.3.6" "GNU"
+.TH GCC 1 "2013-10-10" "gcc-3.3.6-9s12x-20120502" "GNU"
+.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
+.\" way too many mistakes in technical documents.
+.if n .ad l
+.nh
 .SH "NAME"
 gcc \- GNU project C and C++ compiler
 .SH "SYNOPSIS"
@@ -180,7 +179,7 @@
 only one of these two forms, whichever one is not the default.
 .SH "OPTIONS"
 .IX Header "OPTIONS"
-.Sh "Option Summary"
+.SS "Option Summary"
 .IX Subsection "Option Summary"
 Here is a summary of all the options, grouped by type.  Explanations are
 in the following sections.
@@ -345,8 +344,8 @@
 \&\-malign\-int  \-mstrict\-align\fR
 .Sp
 \&\fIM68hc1x Options\fR
-\&\fB\-m6811  \-m6812  \-m68hc11  \-m68hc12  \-m68hcs12 
-\&\-mauto\-incdec  \-minmax  \-mlong\-calls  \-mshort 
+\&\fB\-m6811  \-m6812  \-m68hc11  \-m68hc12  \-m68hcs12
+\&\-mauto\-incdec  \-minmax  \-mlong\-calls  \-mrelax  \-mshort
 \&\-msoft\-reg\-count=\fR\fIcount\fR
 .Sp
 \&\fI\s-1VAX\s0 Options\fR
@@ -681,7 +680,7 @@
 \&\-fargument\-noalias\-global  \-fleading\-underscore 
 \&\-ftls\-model=\fR\fImodel\fR 
 \&\fB\-ftrapv  \-fbounds\-check\fR
-.Sh "Options Controlling the Kind of Output"
+.SS "Options Controlling the Kind of Output"
 .IX Subsection "Options Controlling the Kind of Output"
 Compilation can involve up to four stages: preprocessing, compilation
 proper, assembly and linking, always in that order.  The first three
@@ -781,12 +780,12 @@
 the next \fB\-x\fR option.  Possible values for \fIlanguage\fR are:
 .Sp
 .Vb 8
-\&        c  c-header  cpp-output
-\&        c++  c++-cpp-output
-\&        objective-c  objc-cpp-output
-\&        assembler  assembler-with-cpp
+\&        c  c\-header  cpp\-output
+\&        c++  c++\-cpp\-output
+\&        objective\-c  objc\-cpp\-output
+\&        assembler  assembler\-with\-cpp
 \&        ada
-\&        f77  f77-cpp-input  ratfor
+\&        f77  f77\-cpp\-input  ratfor
 \&        java
 \&        treelang
 .Ve
@@ -882,7 +881,7 @@
 .IP "\fB\-\-version\fR" 4
 .IX Item "--version"
 Display the version number and copyrights of the invoked \s-1GCC\s0.
-.Sh "Compiling \*(C+ Programs"
+.SS "Compiling \*(C+ Programs"
 .IX Subsection "Compiling  Programs"
 \&\*(C+ source files conventionally use one of the suffixes \fB.C\fR,
 \&\fB.cc\fR, \fB.cpp\fR, \fB.c++\fR, \fB.cp\fR, or \fB.cxx\fR;
@@ -904,10 +903,10 @@
 command-line options that you use for compiling programs in any
 language; or command-line options meaningful for C and related
 languages; or options that are meaningful only for \*(C+ programs.
-.Sh "Options Controlling C Dialect"
+.SS "Options Controlling C Dialect"
 .IX Subsection "Options Controlling C Dialect"
 The following options control the dialect of C (or languages derived
-from C, such as \*(C+ and Objective\-C) that the compiler accepts:
+from C, such as \*(C+ and Objective-C) that the compiler accepts:
 .IP "\fB\-ansi\fR" 4
 .IX Item "-ansi"
 In C mode, support all \s-1ISO\s0 C90 programs.  In \*(C+ mode,
@@ -932,7 +931,7 @@
 .Sp
 The \fB\-ansi\fR option does not cause non-ISO programs to be
 rejected gratuitously.  For that, \fB\-pedantic\fR is required in
-addition to \fB\-ansi\fR.  
+addition to \fB\-ansi\fR.
 .Sp
 The macro \f(CW\*(C`_\|_STRICT_ANSI_\|_\*(C'\fR is predefined when the \fB\-ansi\fR
 option is used.  Some header files may notice this macro and refrain
@@ -942,7 +941,7 @@
 .Sp
 Functions which would normally be built in but do not have semantics
 defined by \s-1ISO\s0 C (such as \f(CW\*(C`alloca\*(C'\fR and \f(CW\*(C`ffs\*(C'\fR) are not built-in
-functions with \fB\-ansi\fR is used.  
+functions with \fB\-ansi\fR is used.
 .IP "\fB\-std=\fR" 4
 .IX Item "-std="
 Determine the language standard.  This option is currently only
@@ -1038,7 +1037,7 @@
 .IX Item "-fno-builtin-function"
 .PD
 Don't recognize built-in functions that do not begin with
-\&\fB_\|_builtin_\fR as prefix.  
+\&\fB_\|_builtin_\fR as prefix.
 .Sp
 \&\s-1GCC\s0 normally generates special code to handle certain built-in functions
 more efficiently; for instance, calls to \f(CW\*(C`alloca\*(C'\fR may become single
@@ -1058,8 +1057,8 @@
 \&\fB\-ffreestanding\fR, you may define macros such as:
 .Sp
 .Vb 2
-\&        #define abs(n)          __builtin_abs ((n))
-\&        #define strcpy(d, s)    __builtin_strcpy ((d), (s))
+\&        #define abs(n)          _\|_builtin_abs ((n))
+\&        #define strcpy(d, s)    _\|_builtin_strcpy ((d), (s))
 .Ve
 .IP "\fB\-fhosted\fR" 4
 .IX Item "-fhosted"
@@ -1154,7 +1153,7 @@
 .Sp
 Writing into string constants is a very bad idea; ``constants'' should
 be constant.
-.Sh "Options Controlling \*(C+ Dialect"
+.SS "Options Controlling \*(C+ Dialect"
 .IX Subsection "Options Controlling  Dialect"
 This section describes the command-line options that are only meaningful
 for \*(C+ programs; but you can also use most of the \s-1GNU\s0 compiler options
@@ -1162,7 +1161,7 @@
 might compile a file \f(CW\*(C`firstClass.C\*(C'\fR like this:
 .PP
 .Vb 1
-\&        g++ -g -frepo -O -c firstClass.C
+\&        g++ \-g \-frepo \-O \-c firstClass.C
 .Ve
 .PP
 In this example, only \fB\-frepo\fR is an option meant
@@ -1239,7 +1238,7 @@
 .IX Item "-fexternal-templates"
 Cause \fB#pragma interface\fR and \fBimplementation\fR to apply to
 template instantiation; template instances are emitted or not according
-to the location of the template definition.  
+to the location of the template definition.
 .Sp
 This option is deprecated.
 .IP "\fB\-falt\-external\-templates\fR" 4
@@ -1311,7 +1310,7 @@
 .IP "\fB\-frepo\fR" 4
 .IX Item "-frepo"
 Enable automatic template instantiation at link time.  This option also
-implies \fB\-fno\-implicit\-templates\fR.  
+implies \fB\-fno\-implicit\-templates\fR.
 .IP "\fB\-fno\-rtti\fR" 4
 .IX Item "-fno-rtti"
 Disable generation of information about every class with virtual
@@ -1351,7 +1350,7 @@
 .IX Item "-fno-weak"
 Do not use weak symbol support, even if it is provided by the linker.
 By default, G++ will use weak symbols if they are available.  This
-option exists only for testing, and should not be used by end\-users;
+option exists only for testing, and should not be used by end-users;
 it will result in inferior code and has no benefits.  This option may
 be removed in a future release of G++.
 .IP "\fB\-nostdinc++\fR" 4
@@ -1383,8 +1382,8 @@
 .Sp
 The known incompatibilities at this point include:
 .RS 4
-.IP "*" 4
-Incorrect handling of tail-padding for bit\-fields.  G++ may attempt to
+.IP "\(bu" 4
+Incorrect handling of tail-padding for bit-fields.  G++ may attempt to
 pack data into the same byte as a base class.  For example:
 .Sp
 .Vb 2
@@ -1397,7 +1396,7 @@
 by explicitly padding \f(CW\*(C`A\*(C'\fR so that its size is a multiple of the
 byte size on your platform; that will cause G++ and other compilers to
 layout \f(CW\*(C`B\*(C'\fR identically.
-.IP "*" 4
+.IP "\(bu" 4
 Incorrect handling of tail-padding for virtual bases.  G++ does not use
 tail padding when laying out virtual bases.  For example:
 .Sp
@@ -1412,7 +1411,7 @@
 explicitly padding \f(CW\*(C`A\*(C'\fR so that its size is a multiple of its
 alignment (ignoring virtual base classes); that will cause G++ and other
 compilers to layout \f(CW\*(C`C\*(C'\fR identically.
-.IP "*" 4
+.IP "\(bu" 4
 Incorrect handling of bit-fields with declared widths greater than that
 of their underlying types, when the bit-fields appear in a union.  For
 example:
@@ -1423,37 +1422,31 @@
 .Sp
 Assuming that an \f(CW\*(C`int\*(C'\fR does not have 4096 bits, G++ will make the
 union too small by the number of bits in an \f(CW\*(C`int\*(C'\fR.
-.IP "*" 4
+.IP "\(bu" 4
 Empty classes can be placed at incorrect offsets.  For example:
 .Sp
 .Vb 1
 \&        struct A {};
-.Ve
-.Sp
-.Vb 4
+\&
 \&        struct B {
 \&          A a;
 \&          virtual void f ();
 \&        };
-.Ve
-.Sp
-.Vb 1
+\&
 \&        struct C : public B, public A {};
 .Ve
 .Sp
 G++ will place the \f(CW\*(C`A\*(C'\fR base class of \f(CW\*(C`C\*(C'\fR at a nonzero offset;
 it should be placed at offset zero.  G++ mistakenly believes that the
 \&\f(CW\*(C`A\*(C'\fR data member of \f(CW\*(C`B\*(C'\fR is already at offset zero.
-.IP "*" 4
+.IP "\(bu" 4
 Names of template functions whose types involve \f(CW\*(C`typename\*(C'\fR or
 template template parameters can be mangled incorrectly.
 .Sp
 .Vb 2
 \&        template <typename Q>
 \&        void f(typename Q::X) {}
-.Ve
-.Sp
-.Vb 2
+\&
 \&        template <template <typename> class Q>
 \&        void f(typename Q<int>::X) {}
 .Ve
@@ -1495,26 +1488,26 @@
 Warn about violations of the following style guidelines from Scott Meyers'
 \&\fIEffective \*(C+\fR book:
 .RS 4
-.IP "*" 4
+.IP "\(bu" 4
 Item 11:  Define a copy constructor and an assignment operator for classes
 with dynamically allocated memory.
-.IP "*" 4
+.IP "\(bu" 4
 Item 12:  Prefer initialization to assignment in constructors.
-.IP "*" 4
+.IP "\(bu" 4
 Item 14:  Make destructors virtual in base classes.
-.IP "*" 4
+.IP "\(bu" 4
 Item 15:  Have \f(CW\*(C`operator=\*(C'\fR return a reference to \f(CW*this\fR.
-.IP "*" 4
+.IP "\(bu" 4
 Item 23:  Don't try to return a reference when you must return an object.
 .RE
 .RS 4
 .Sp
 Also warn about violations of the following style guidelines from 
 Scott Meyers' \fIMore Effective \*(C+\fR book:
-.IP "*" 4
+.IP "\(bu" 4
 Item 6:  Distinguish between prefix and postfix forms of increment and
 decrement operators.
-.IP "*" 4
+.IP "\(bu" 4
 Item 7:  Never overload \f(CW\*(C`&&\*(C'\fR, \f(CW\*(C`||\*(C'\fR, or \f(CW\*(C`,\*(C'\fR.
 .RE
 .RS 4
@@ -1525,7 +1518,7 @@
 .RE
 .IP "\fB\-Wno\-deprecated\fR (\*(C+ only)" 4
 .IX Item "-Wno-deprecated ( only)"
-Do not warn about usage of deprecated features.  
+Do not warn about usage of deprecated features.
 .IP "\fB\-Wno\-non\-template\-friend\fR (\*(C+ only)" 4
 .IX Item "-Wno-non-template-friend ( only)"
 Disable warnings when non-templatized friend functions are declared
@@ -1556,9 +1549,7 @@
 \&        struct A {
 \&          virtual void f();
 \&        };
-.Ve
-.Sp
-.Vb 3
+\&
 \&        struct B: public A {
 \&          void f(int);
 \&        };
@@ -1569,7 +1560,7 @@
 .Sp
 .Vb 2
 \&        B* b;
-\&        b->f();
+\&        b\->f();
 .Ve
 .Sp
 will fail to compile.
@@ -1583,7 +1574,7 @@
 enumeral type to a signed type, over a conversion to an unsigned type of
 the same size.  Previous versions of G++ would try to preserve
 unsignedness, but the standard mandates the current behavior.
-.Sh "Options Controlling Objective-C Dialect"
+.SS "Options Controlling Objective-C Dialect"
 .IX Subsection "Options Controlling Objective-C Dialect"
 This section describes the command-line options that are only meaningful
 for Objective-C programs, but you can also use most of the \s-1GNU\s0 compiler
@@ -1591,7 +1582,7 @@
 you might compile a file \f(CW\*(C`some_class.m\*(C'\fR like this:
 .PP
 .Vb 1
-\&        gcc -g -fgnu-runtime -O -c some_class.m
+\&        gcc \-g \-fgnu\-runtime \-O \-c some_class.m
 .Ve
 .PP
 In this example, \fB\-fgnu\-runtime\fR is an option meant only for
@@ -1652,7 +1643,7 @@
 while \f(CW\*(C`\-Wselector\*(C'\fR only performs its checks in the final stage of
 compilation.  This also enforces the coding style convention
 that methods and selectors must be declared before being used.
-.Sh "Options to Control Diagnostic Messages Formatting"
+.SS "Options to Control Diagnostic Messages Formatting"
 .IX Subsection "Options to Control Diagnostic Messages Formatting"
 Traditionally, diagnostic messages have been formatted irrespective of
 the output device's aspect (e.g. its width, ...).  The options described
@@ -1682,7 +1673,7 @@
 messages reporter to emit the same source location information (as
 prefix) for physical lines that result from the process of breaking
 a message which is too long to fit on a single line.
-.Sh "Options to Request or Suppress Warnings"
+.SS "Options to Request or Suppress Warnings"
 .IX Subsection "Options to Request or Suppress Warnings"
 Warnings are diagnostic messages that report constructions which
 are not inherently erroneous but which are risky or suggest there
@@ -1777,7 +1768,7 @@
 particular library's limitations.  However, if \fB\-pedantic\fR is used
 with \fB\-Wformat\fR, warnings will be given about format features not
 in the selected standard version (but not for \f(CW\*(C`strfmon\*(C'\fR formats,
-since those are not in any version of the C standard).  
+since those are not in any version of the C standard).
 .Sp
 Since \fB\-Wformat\fR also checks for null format arguments for
 several functions, \fB\-Wformat\fR also implies \fB\-Wnonnull\fR.
@@ -1820,7 +1811,7 @@
 warns about calls to \f(CW\*(C`printf\*(C'\fR and \f(CW\*(C`scanf\*(C'\fR functions where the
 format string is not a string literal and there are no format arguments,
 as in \f(CW\*(C`printf (foo);\*(C'\fR.  This may be a security hole if the format
-string came from untrusted input and contains \fB%n\fR.  (This is
+string came from untrusted input and contains \fB\f(CB%n\fB\fR.  (This is
 currently a subset of what \fB\-Wformat\-nonliteral\fR warns about, but
 in future warnings may be added to \fB\-Wformat\-security\fR that are not
 included in \fB\-Wformat\-nonliteral\fR.)
@@ -2080,7 +2071,7 @@
 in fact be called at the place which would cause a problem.
 .Sp
 Some spurious warnings can be avoided if you declare all the functions
-you use that never return as \f(CW\*(C`noreturn\*(C'\fR.  
+you use that never return as \f(CW\*(C`noreturn\*(C'\fR.
 .IP "\fB\-Wunknown\-pragmas\fR" 4
 .IX Item "-Wunknown-pragmas"
 Warn when a #pragma directive is encountered which is not understood by
@@ -2113,7 +2104,7 @@
 .IX Item "-W"
 Print extra warning messages for these events:
 .RS 4
-.IP "*" 4
+.IP "\(bu" 4
 A function can return either with or without a value.  (Falling
 off the end of the function body is considered returning without
 a value.)  For example, this function would evoke such a
@@ -2126,35 +2117,35 @@
 \&            return a;
 \&        }
 .Ve
-.IP "*" 4
+.IP "\(bu" 4
 An expression-statement or the left-hand side of a comma expression
 contains no side effects.
 To suppress the warning, cast the unused expression to void.
 For example, an expression such as \fBx[i,j]\fR will cause a warning,
 but \fBx[(void)i,j]\fR will not.
-.IP "*" 4
+.IP "\(bu" 4
 An unsigned value is compared against zero with \fB<\fR or \fB>=\fR.
-.IP "*" 4
+.IP "\(bu" 4
 A comparison like \fBx<=y<=z\fR appears; this is equivalent to
 \&\fB(x<=y ? 1 : 0) <= z\fR, which is a different interpretation from
 that of ordinary mathematical notation.
-.IP "*" 4
+.IP "\(bu" 4
 Storage-class specifiers like \f(CW\*(C`static\*(C'\fR are not the first things in
 a declaration.  According to the C Standard, this usage is obsolescent.
-.IP "*" 4
+.IP "\(bu" 4
 The return type of a function has a type qualifier such as \f(CW\*(C`const\*(C'\fR.
 Such a type qualifier has no effect, since the value returned by a
 function is not an lvalue.  (But don't warn about the \s-1GNU\s0 extension of
 \&\f(CW\*(C`volatile void\*(C'\fR return types.  That extension will be warned about
 if \fB\-pedantic\fR is specified.)
-.IP "*" 4
+.IP "\(bu" 4
 If \fB\-Wall\fR or \fB\-Wunused\fR is also specified, warn about unused
 arguments.
-.IP "*" 4
+.IP "\(bu" 4
 A comparison between signed and unsigned values could produce an
 incorrect result when the signed value is converted to unsigned.
 (But don't warn if \fB\-Wno\-sign\-compare\fR is also specified.)
-.IP "*" 4
+.IP "\(bu" 4
 An aggregate has a partly bracketed initializer.
 For example, the following code would evoke such a warning,
 because braces are missing around the initializer for \f(CW\*(C`x.h\*(C'\fR:
@@ -2164,7 +2155,7 @@
 \&        struct t { struct s h; int i; };
 \&        struct t x = { 1, 2, 3 };
 .Ve
-.IP "*" 4
+.IP "\(bu" 4
 An aggregate has an initializer which does not initialize all members.
 For example, the following code would cause such a warning, because
 \&\f(CW\*(C`x.h\*(C'\fR would be implicitly initialized to zero:
@@ -2211,11 +2202,11 @@
 \&\s-1ISO\s0 C.  Also warn about \s-1ISO\s0 C constructs that have no traditional C
 equivalent, and/or problematic constructs which should be avoided.
 .RS 4
-.IP "*" 4
+.IP "\(bu" 4
 Macro parameters that appear within string literals in the macro body.
 In traditional C macro replacement takes place within string literals,
 but does not in \s-1ISO\s0 C.
-.IP "*" 4
+.IP "\(bu" 4
 In traditional C, some preprocessor directives did not exist.
 Traditional preprocessors would only consider a line to be a directive
 if the \fB#\fR appeared in column 1 on the line.  Therefore
@@ -2225,11 +2216,11 @@
 \&\fB#pragma\fR not understood by traditional C by indenting them.  Some
 traditional implementations would not recognize \fB#elif\fR, so it
 suggests avoiding it altogether.
-.IP "*" 4
+.IP "\(bu" 4
 A function-like macro that appears without arguments.
-.IP "*" 4
+.IP "\(bu" 4
 The unary plus operator.
-.IP "*" 4
+.IP "\(bu" 4
 The \fBU\fR integer constant suffix, or the \fBF\fR or \fBL\fR floating point
 constant suffixes.  (Traditional C does support the \fBL\fR suffix on integer
 constants.)  Note, these suffixes appear in macros defined in the system
@@ -2237,38 +2228,38 @@
 Use of these macros in user code might normally lead to spurious
 warnings, however gcc's integrated preprocessor has enough context to
 avoid warning in these cases.
-.IP "*" 4
+.IP "\(bu" 4
 A function declared external in one block and then used after the end of
 the block.
-.IP "*" 4
+.IP "\(bu" 4
 A \f(CW\*(C`switch\*(C'\fR statement has an operand of type \f(CW\*(C`long\*(C'\fR.
-.IP "*" 4
+.IP "\(bu" 4
 A non\-\f(CW\*(C`static\*(C'\fR function declaration follows a \f(CW\*(C`static\*(C'\fR one.
 This construct is not accepted by some traditional C compilers.
-.IP "*" 4
+.IP "\(bu" 4
 The \s-1ISO\s0 type of an integer constant has a different width or
 signedness from its traditional type.  This warning is only issued if
 the base of the constant is ten.  I.e. hexadecimal or octal values, which
 typically represent bit patterns, are not warned about.
-.IP "*" 4
+.IP "\(bu" 4
 Usage of \s-1ISO\s0 string concatenation is detected.
-.IP "*" 4
+.IP "\(bu" 4
 Initialization of automatic aggregates.
-.IP "*" 4
+.IP "\(bu" 4
 Identifier conflicts with labels.  Traditional C lacks a separate
 namespace for labels.
-.IP "*" 4
+.IP "\(bu" 4
 Initialization of unions.  If the initializer is zero, the warning is
 omitted.  This is done under the assumption that the zero initializer in
 user code appears conditioned on e.g. \f(CW\*(C`_\|_STDC_\|_\*(C'\fR to avoid missing
 initializer warnings and relies on default initialization to zero in the
 traditional C case.
-.IP "*" 4
+.IP "\(bu" 4
 Conversions by prototypes between fixed/floating point values and vice
 versa.  The absence of these prototypes when compiling with traditional
 C would cause serious problems.  This is a subset of the possible
 conversion warnings, for the full set use \fB\-Wconversion\fR.
-.IP "*" 4
+.IP "\(bu" 4
 Use of \s-1ISO\s0 C style function definitions.  This warning intentionally is
 \&\fInot\fR issued for prototype declarations or variadic functions
 because these \s-1ISO\s0 C features will appear in your code when using
@@ -2408,7 +2399,7 @@
 \&        struct foo {
 \&          int x;
 \&          char a, b, c, d;
-\&        } __attribute__((packed));
+\&        } _\|_attribute_\|_((packed));
 \&        struct bar {
 \&          char z;
 \&          struct foo f;
@@ -2447,12 +2438,12 @@
 version of a program there is often substantial code which checks
 correct functioning of the program and is, hopefully, unreachable
 because the program does work.  Another common use of unreachable
-code is to provide behavior which is selectable at compile\-time.
+code is to provide behavior which is selectable at compile-time.
 .IP "\fB\-Winline\fR" 4
 .IX Item "-Winline"
 Warn if a function can not be inlined and it was declared as inline.
 Even with this option, the compiler will not warn about failures to
-inline functions declared in system headers.  
+inline functions declared in system headers.
 .Sp
 The compiler uses a variety of heuristics to determine whether or not
 to inline a function.  For example, the compiler takes into account
@@ -2477,7 +2468,7 @@
 .IP "\fB\-Werror\fR" 4
 .IX Item "-Werror"
 Make all warnings into errors.
-.Sh "Options for Debugging Your Program or \s-1GCC\s0"
+.SS "Options for Debugging Your Program or \s-1GCC\s0"
 .IX Subsection "Options for Debugging Your Program or GCC"
 \&\s-1GCC\s0 has various special options that are used for debugging
 either your program or \s-1GCC:\s0
@@ -2973,7 +2964,7 @@
 that enable them.  The directory name is separated from the switches by
 \&\fB;\fR, and each switch starts with an \fB@} instead of the
 \&\f(CB@samp\fB{\-\fR, without spaces between multiple switches.  This is supposed to
-ease shell\-processing.
+ease shell-processing.
 .IP "\fB\-print\-prog\-name=\fR\fIprogram\fR" 4
 .IX Item "-print-prog-name=program"
 Like \fB\-print\-file\-name\fR, but searches for a program such as \fBcpp\fR.
@@ -2985,7 +2976,7 @@
 but you do want to link with \fIlibgcc.a\fR.  You can do
 .Sp
 .Vb 1
-\&        gcc -nostdlib <files>... `gcc -print-libgcc-file-name`
+\&        gcc \-nostdlib <files>... \`gcc \-print\-libgcc\-file\-name\`
 .Ve
 .IP "\fB\-print\-search\-dirs\fR" 4
 .IX Item "-print-search-dirs"
@@ -3009,8 +3000,8 @@
 .IP "\fB\-dumpspecs\fR" 4
 .IX Item "-dumpspecs"
 Print the compiler's built-in specs\-\-\-and don't do anything else.  (This
-is used when \s-1GCC\s0 itself is being built.)  
-.Sh "Options That Control Optimization"
+is used when \s-1GCC\s0 itself is being built.)
+.SS "Options That Control Optimization"
 .IX Subsection "Options That Control Optimization"
 These options control various sorts of optimizations.
 .PP
@@ -3138,7 +3129,7 @@
 arithmetic on them.  This produces better code by making all memory
 references potential common subexpressions.  When they are not common
 subexpressions, instruction combination should eliminate the separate
-register\-load.
+register-load.
 .Sp
 Enabled at levels \fB\-O2\fR, \fB\-O3\fR, \fB\-Os\fR.
 .IP "\fB\-fforce\-addr\fR" 4
@@ -3158,7 +3149,7 @@
 the standard calling sequence automatically handles the frame pointer
 and nothing is saved by pretending it doesn't exist.  The
 machine-description macro \f(CW\*(C`FRAME_POINTER_REQUIRED\*(C'\fR controls
-whether a target machine supports this flag.  
+whether a target machine supports this flag.
 .Sp
 Enabled at levels \fB\-O\fR, \fB\-O2\fR, \fB\-O3\fR, \fB\-Os\fR.
 .IP "\fB\-foptimize\-sibling\-calls\fR" 4
@@ -3203,15 +3194,15 @@
 .RS 4
 .Sp
 .Vb 10
-\& @item max-inline-insns
+\& @item max\-inline\-insns
 \&  is set to I<n>.
-\& @item max-inline-insns-single
+\& @item max\-inline\-insns\-single
 \&  is set to I<n>/2.
-\& @item max-inline-insns-auto
+\& @item max\-inline\-insns\-auto
 \&  is set to I<n>/2.
-\& @item min-inline-insns
+\& @item min\-inline\-insns
 \&  is set to 130 or I<n>/4, whichever is smaller.
-\& @item max-inline-insns-rtl
+\& @item max\-inline\-insns\-rtl
 \&  is set to I<n>.
 .Ve
 .RE
@@ -3373,7 +3364,7 @@
 .IP "\fB\-fcrossjumping\fR" 4
 .IX Item "-fcrossjumping"
 Perform cross-jumping transformation. This transformation unifies equivalent code and save code size. The
-resulting code may or may not perform better than without cross\-jumping.
+resulting code may or may not perform better than without cross-jumping.
 .Sp
 Enabled at levels \fB\-O\fR, \fB\-O2\fR, \fB\-O3\fR, \fB\-Os\fR.
 .IP "\fB\-fif\-conversion\fR" 4
@@ -3485,7 +3476,7 @@
 .IP "\fB\-freduce\-all\-givs\fR" 4
 .IX Item "-freduce-all-givs"
 Forces all general-induction variables in loops to be
-strength\-reduced.
+strength-reduced.
 .Sp
 \&\fINote:\fR When compiling programs written in Fortran,
 \&\fB\-fmove\-all\-movables\fR and \fB\-freduce\-all\-givs\fR are enabled
@@ -3529,7 +3520,7 @@
 In a hard real-time system, people don't want different runs of the
 compiler to produce code that has different behavior; minimizing
 non-determinism is of paramount import.  This switch allows users to
-reduce non\-determinism, possibly at the expense of inferior
+reduce non-determinism, possibly at the expense of inferior
 optimization.
 .Sp
 The default is \fB\-fguess\-branch\-probability\fR at levels
@@ -3571,9 +3562,7 @@
 \&          int i;
 \&          double d;
 \&        };
-.Ve
-.Sp
-.Vb 5
+\&
 \&        int f() {
 \&          a_union t;
 \&          t.d = 3.0;
@@ -3740,7 +3729,7 @@
 .IX Item "-funsafe-math-optimizations"
 Allow optimizations for floating-point arithmetic that (a) assume
 that arguments and results are valid and (b) may violate \s-1IEEE\s0 or
-\&\s-1ANSI\s0 standards.  When used at link\-time, it may include libraries
+\&\s-1ANSI\s0 standards.  When used at link-time, it may include libraries
 or startup files that change the default \s-1FPU\s0 control word or other
 similar optimizations.
 .Sp
@@ -4062,7 +4051,7 @@
 .RE
 .RS 4
 .RE
-.Sh "Options Controlling the Preprocessor"
+.SS "Options Controlling the Preprocessor"
 .IX Subsection "Options Controlling the Preprocessor"
 These options control the C preprocessor, which is run on each C source
 file before actual compilation.
@@ -4253,7 +4242,7 @@
 slight change in semantics from \s-1GCC\s0 versions 3.0 and earlier.
 .IP "\fB\-MF\fR \fIfile\fR" 4
 .IX Item "-MF file"
-@anchor{\-MF}
+\&\f(CW@anchor\fR{\-MF}
 When used with \fB\-M\fR or \fB\-MM\fR, specifies a
 file to write the dependencies to.  If no \fB\-MF\fR switch is given
 the preprocessor sends the rules to the same place it would have sent
@@ -4283,9 +4272,7 @@
 .Sp
 .Vb 1
 \&        test.o: test.c test.h
-.Ve
-.Sp
-.Vb 1
+\&
 \&        test.h:
 .Ve
 .IP "\fB\-MT\fR \fItarget\fR" 4
@@ -4344,7 +4331,7 @@
 .IP "\fB\-x assembler-with-cpp\fR" 4
 .IX Item "-x assembler-with-cpp"
 .PD
-Specify the source language: C, \*(C+, Objective\-C, or assembly.  This has
+Specify the source language: C, \*(C+, Objective-C, or assembly.  This has
 nothing to do with standards conformance or extensions; it merely
 selects which base syntax to expect.  If you give none of these options,
 cpp will deduce the language from the extension of the source file:
@@ -4547,7 +4534,7 @@
 Assuming you have no file \fIfoo.h\fR, the command
 .Sp
 .Vb 1
-\&        touch foo.h; cpp -dM foo.h
+\&        touch foo.h; cpp \-dM foo.h
 .Ve
 .Sp
 will show all the predefined macros.
@@ -4614,13 +4601,13 @@
 The nine trigraphs and their replacements are
 .Sp
 .Vb 2
-\&        Trigraph:       ??(  ??)  ??<  ??>  ??=  ??/  ??'  ??!  ??-
+\&        Trigraph:       ??(  ??)  ??<  ??>  ??=  ??/  ??\*(Aq  ??!  ??\-
 \&        Replacement:      [    ]    {    }    #    \e    ^    |    ~
 .Ve
 .IP "\fB\-remap\fR" 4
 .IX Item "-remap"
 Enable special code to work around file systems which only permit very
-short file names, such as \s-1MS\-DOS\s0.
+short file names, such as MS-DOS.
 .IP "\fB\-\-help\fR" 4
 .IX Item "--help"
 .PD 0
@@ -4646,14 +4633,14 @@
 .PD
 Print out \s-1GNU\s0 \s-1CPP\s0's version number.  With one dash, proceed to
 preprocess as normal.  With two dashes, exit immediately.
-.Sh "Passing Options to the Assembler"
+.SS "Passing Options to the Assembler"
 .IX Subsection "Passing Options to the Assembler"
 You can pass options to the assembler.
 .IP "\fB\-Wa,\fR\fIoption\fR" 4
 .IX Item "-Wa,option"
 Pass \fIoption\fR as an option to the assembler.  If \fIoption\fR
 contains commas, it is split into multiple options at the commas.
-.Sh "Options for Linking"
+.SS "Options for Linking"
 .IX Subsection "Options for Linking"
 These options come into play when the compiler links object files into
 an executable output file.  They are meaningless if the compiler is
@@ -4674,7 +4661,7 @@
 .IX Item "-E"
 .PD
 If any of these options is used, then the linker is not run, and
-object file names should not be used as arguments.  
+object file names should not be used as arguments.
 .IP "\fB\-l\fR\fIlibrary\fR" 4
 .IX Item "-llibrary"
 .PD 0
@@ -4825,7 +4812,7 @@
 Pretend the symbol \fIsymbol\fR is undefined, to force linking of
 library modules to define it.  You can use \fB\-u\fR multiple times with
 different symbols to force loading of additional library modules.
-.Sh "Options for Directory Search"
+.SS "Options for Directory Search"
 .IX Subsection "Options for Directory Search"
 These options specify directories to search for header files, for
 libraries and for parts of the compiler:
@@ -4909,7 +4896,7 @@
 out of the link if it is not found by those means.
 .Sp
 Another way to specify a prefix much like the \fB\-B\fR prefix is to use
-the environment variable \fB\s-1GCC_EXEC_PREFIX\s0\fR.  
+the environment variable \fB\s-1GCC_EXEC_PREFIX\s0\fR.
 .Sp
 As a special kludge, if the path provided by \fB\-B\fR is
 \&\fI[dir/]stage\fIN\fI/\fR, where \fIN\fR is a number in the range 0 to
@@ -4923,10 +4910,10 @@
 \&\fIcc1plus\fR, \fIas\fR, \fIld\fR, etc.  More than one
 \&\fB\-specs=\fR\fIfile\fR can be specified on the command line, and they
 are processed in order, from left to right.
-.Sh "Specifying Target Machine and Compiler Version"
+.SS "Specifying Target Machine and Compiler Version"
 .IX Subsection "Specifying Target Machine and Compiler Version"
 The usual way to run \s-1GCC\s0 is to run the executable called \fIgcc\fR, or
-\&\fI<machine>\-gcc\fR when cross\-compiling, or
+\&\fI<machine>\-gcc\fR when cross-compiling, or
 \&\fI<machine>\-gcc\-<version>\fR to run a version other than the one that
 was installed last.  Sometimes this is inconvenient, so \s-1GCC\s0 provides
 options that will switch to another cross-compiler or version.
@@ -4935,7 +4922,7 @@
 The argument \fImachine\fR specifies the target machine for compilation.
 .Sp
 The value to use for \fImachine\fR is the same as was specified as the
-machine type when configuring \s-1GCC\s0 as a cross\-compiler.  For
+machine type when configuring \s-1GCC\s0 as a cross-compiler.  For
 example, if a cross-compiler was configured with \fBconfigure
 i386v\fR, meaning to compile for an 80386 running System V, then you
 would specify \fB\-b i386v\fR to run that cross compiler.
@@ -4948,7 +4935,7 @@
 The \fB\-V\fR and \fB\-b\fR options work by running the
 \&\fI<machine>\-gcc\-<version>\fR executable, so there's no real reason to
 use them if you can just run that directly.
-.Sh "Hardware Models and Configurations"
+.SS "Hardware Models and Configurations"
 .IX Subsection "Hardware Models and Configurations"
 Earlier we discussed the standard option \fB\-b\fR which chooses among
 different installed compilers for completely different target
@@ -5055,9 +5042,9 @@
 Generate output containing library calls for floating point.
 \&\fBWarning:\fR the requisite libraries are not available for all m68k
 targets.  Normally the facilities of the machine's usual C compiler are
-used, but this can't be done directly in cross\-compilation.  You must
+used, but this can't be done directly in cross-compilation.  You must
 make your own arrangements to provide suitable library functions for
-cross\-compilation.  The embedded targets \fBm68k\-*\-aout\fR and
+cross-compilation.  The embedded targets \fBm68k\-*\-aout\fR and
 \&\fBm68k\-*\-coff\fR do provide software floating point support.
 .IP "\fB\-mshort\fR" 4
 .IX Item "-mshort"
@@ -5154,7 +5141,7 @@
 .IP "\fB\-m68hcs12\fR" 4
 .IX Item "-m68hcs12"
 .PD
-Generate output for a 68HCS12.  
+Generate output for a 68HCS12.
 .IP "\fB\-mauto\-incdec\fR" 4
 .IX Item "-mauto-incdec"
 Enable the use of 68HC12 pre and post auto-increment and auto-decrement
@@ -5174,7 +5161,19 @@
 .PD
 Treat all calls as being far away (near).  If calls are assumed to be
 far away, the compiler will use the \f(CW\*(C`call\*(C'\fR instruction to
-call a function and the \f(CW\*(C`rtc\*(C'\fR instruction for returning.
+call a function and the \f(CW\*(C`rtc\*(C'\fR instruction for returning.  An interrupt
+or a trap handler is not affected by this option and is always considered near.
+.IP "\fB\-mrelax\fR" 4
+.IX Item "-mrelax"
+Indicate to the compiler and linker that they should perform a relaxation
+optimization pass to shorten branches, calls and absolute memory addresses.
+The compiler will not use direct addressing mode for pseudo-soft registers and
+it will also emit some \f(CW\*(C`bset\*(C'\fR and \f(CW\*(C`bclr\*(C'\fR sequences that can be
+optimized by the linker.  The linker option \fB\-relax\fR will be used
+and the linker will transform 16\-bit addressing modes into direct addressing
+modes if possible.
+.Sp
+This option makes symbolic debugging impossible.
 .IP "\fB\-mshort\fR" 4
 .IX Item "-mshort"
 Consider type \f(CW\*(C`int\*(C'\fR to be 16 bits wide, like \f(CW\*(C`short int\*(C'\fR.
@@ -5236,9 +5235,9 @@
 Generate output containing library calls for floating point.
 \&\fBWarning:\fR the requisite libraries are not available for all \s-1SPARC\s0
 targets.  Normally the facilities of the machine's usual C compiler are
-used, but this cannot be done directly in cross\-compilation.  You must make
+used, but this cannot be done directly in cross-compilation.  You must make
 your own arrangements to provide suitable library functions for
-cross\-compilation.  The embedded targets \fBsparc\-*\-aout\fR and
+cross-compilation.  The embedded targets \fBsparc\-*\-aout\fR and
 \&\fBsparclite\-*\-*\fR do provide software floating point support.
 .Sp
 \&\fB\-msoft\-float\fR changes the calling convention in the output file;
@@ -5310,11 +5309,11 @@
 \&\fB\-mimpure\-text\fR, used in addition to \fB\-shared\fR, tells
 the compiler to not pass \fB\-z text\fR to the linker when linking a
 shared object.  Using this option, you can link position-dependent
-code into a shared object.  
+code into a shared object.
 .Sp
 \&\fB\-mimpure\-text\fR suppresses the ``relocations remain against
 allocatable but non-writable sections'' linker error message.
-However, the necessary relocations will trigger copy\-on\-write, and the
+However, the necessary relocations will trigger copy-on-write, and the
 shared object is not actually shared across processes.  Instead of
 using \fB\-mimpure\-text\fR, you should compile all source code with
 \&\fB\-fpic\fR or \fB\-fPIC\fR.
@@ -5533,9 +5532,9 @@
 Generate output containing library calls for floating point.
 \&\fBWarning:\fR the requisite libraries are not available for all \s-1ARM\s0
 targets.  Normally the facilities of the machine's usual C compiler are
-used, but this cannot be done directly in cross\-compilation.  You must make
+used, but this cannot be done directly in cross-compilation.  You must make
 your own arrangements to provide suitable library functions for
-cross\-compilation.
+cross-compilation.
 .Sp
 \&\fB\-msoft\-float\fR changes the calling convention in the output file;
 therefore, it is only useful if you compile \fIall\fR of a program with
@@ -5693,7 +5692,7 @@
 Disable support for the \f(CW\*(C`dllimport\*(C'\fR attribute.
 .IP "\fB\-msingle\-pic\-base\fR" 4
 .IX Item "-msingle-pic-base"
-Treat the register used for \s-1PIC\s0 addressing as read\-only, rather than
+Treat the register used for \s-1PIC\s0 addressing as read-only, rather than
 loading it in the prologue for each function.  The run-time system is
 responsible for initializing this register with an appropriate value
 before execution begins.
@@ -5711,7 +5710,7 @@
 \&                 .ascii "arm_poke_function_name", 0
 \&                 .align
 \&             t1
-\&                 .word 0xff000000 + (t1 - t0)
+\&                 .word 0xff000000 + (t1 \- t0)
 \&             arm_poke_function_name
 \&                 mov     ip, sp
 \&                 stmfd   sp!, {fp, ip, lr, pc}
@@ -6139,7 +6138,7 @@
 .Sp
 \&\s-1GCC\s0 defaults to the mnemonics appropriate for the architecture in
 use.  Specifying \fB\-mcpu=\fR\fIcpu_type\fR sometimes overrides the
-value of these option.  Unless you are building a cross\-compiler, you
+value of these option.  Unless you are building a cross-compiler, you
 should normally not specify either \fB\-mnew\-mnemonics\fR or
 \&\fB\-mold\-mnemonics\fR, but should instead accept the default.
 .IP "\fB\-mcpu=\fR\fIcpu_type\fR" 4
@@ -6403,7 +6402,7 @@
 .PD
 On System V.4 and embedded PowerPC systems do not (do) force structures
 and unions that contain bit-fields to be aligned to the base type of the
-bit\-field.
+bit-field.
 .Sp
 For example, by default a structure containing nothing but 8
 \&\f(CW\*(C`unsigned\*(C'\fR bit-fields of length 1 would be aligned to a 4 byte
@@ -7008,7 +7007,7 @@
 .PD
 The \fB\-mrnames\fR switch says to output code using the \s-1MIPS\s0 software
 names for the registers, instead of the hardware names (ie, \fIa0\fR
-instead of \fI$4\fR).  The only known assembler that supports this option
+instead of \fI\f(CI$4\fI\fR).  The only known assembler that supports this option
 is the Algorithmics assembler.
 .IP "\fB\-mgpopt\fR" 4
 .IX Item "-mgpopt"
@@ -7061,9 +7060,9 @@
 Generate output containing library calls for floating point.
 \&\fBWarning:\fR the requisite libraries are not part of \s-1GCC\s0.
 Normally the facilities of the machine's usual C compiler are used, but
-this can't be done directly in cross\-compilation.  You must make your
+this can't be done directly in cross-compilation.  You must make your
 own arrangements to provide suitable library functions for
-cross\-compilation.
+cross-compilation.
 .IP "\fB\-mhard\-float\fR" 4
 .IX Item "-mhard-float"
 Generate output containing floating point instructions.  This is the
@@ -7170,7 +7169,7 @@
 Put global and static items less than or equal to \fInum\fR bytes into
 the small data or bss sections instead of the normal data or bss
 section.  This allows the assembler to emit one word memory reference
-instructions based on the global pointer (\fIgp\fR or \fI$28\fR),
+instructions based on the global pointer (\fIgp\fR or \fI\f(CI$28\fI\fR),
 instead of the normal two words used.  By default, \fInum\fR is 8 when
 the \s-1MIPS\s0 assembler is used, and 0 when the \s-1GNU\s0 assembler is used.  The
 \&\fB\-G\fR \fInum\fR switch is also passed to the assembler and linker.
@@ -7316,9 +7315,9 @@
 Generate output containing library calls for floating point.
 \&\fBWarning:\fR the requisite libraries are not part of \s-1GCC\s0.
 Normally the facilities of the machine's usual C compiler are used, but
-this can't be done directly in cross\-compilation.  You must make your
+this can't be done directly in cross-compilation.  You must make your
 own arrangements to provide suitable library functions for
-cross\-compilation.
+cross-compilation.
 .Sp
 On machines where a function returns floating point results in the 80387
 register stack, some floating point opcodes may be emitted even if
@@ -7376,13 +7375,13 @@
 conforming to the \s-1ABI\s0, this would not be possible.  So specifying a 
 \&\fB\-m128bit\-long\-double\fR will align \f(CW\*(C`long double\*(C'\fR
 to a 16 byte boundary by padding the \f(CW\*(C`long double\*(C'\fR with an additional
-32 bit zero. 
+32 bit zero.
 .Sp
 In the x86\-64 compiler, \fB\-m128bit\-long\-double\fR is the default choice as
 its \s-1ABI\s0 specifies that \f(CW\*(C`long double\*(C'\fR is to be aligned on 16 byte boundary.
 .Sp
 Notice that neither of these options enable any extra precision over the x87
-standard of 80 bits for a \f(CW\*(C`long double\*(C'\fR. 
+standard of 80 bits for a \f(CW\*(C`long double\*(C'\fR.
 .Sp
 \&\fBWarning:\fR if you override the default value for your target \s-1ABI\s0, the
 structures and arrays containing \f(CW\*(C`long double\*(C'\fR variables will change their size as
@@ -7409,7 +7408,7 @@
 You can specify that an individual function is called with this calling
 sequence with the function attribute \fBstdcall\fR.  You can also
 override the \fB\-mrtd\fR option by using the function attribute
-\&\fBcdecl\fR.  
+\&\fBcdecl\fR.
 .Sp
 \&\fBWarning:\fR this calling convention is incompatible with the one
 normally used on Unix, so you cannot use it if you need to call
@@ -7662,9 +7661,9 @@
 Generate output containing library calls for floating point.
 \&\fBWarning:\fR the requisite libraries are not available for all \s-1HPPA\s0
 targets.  Normally the facilities of the machine's usual C compiler are
-used, but this cannot be done directly in cross\-compilation.  You must make
+used, but this cannot be done directly in cross-compilation.  You must make
 your own arrangements to provide suitable library functions for
-cross\-compilation.  The embedded target \fBhppa1.1\-*\-pro\fR
+cross-compilation.  The embedded target \fBhppa1.1\-*\-pro\fR
 does provide software floating point support.
 .Sp
 \&\fB\-msoft\-float\fR changes the calling convention in the output file;
@@ -7677,7 +7676,7 @@
 Generate the predefine, \f(CW\*(C`_SIO\*(C'\fR, for server \s-1IO\s0.  The default is
 \&\fB\-mwsio\fR.  This generates the predefines, \f(CW\*(C`_\|_hp9000s700\*(C'\fR,
 \&\f(CW\*(C`_\|_hp9000s700_\|_\*(C'\fR and \f(CW\*(C`_WSIO\*(C'\fR, for workstation \s-1IO\s0.  These
-options are available under HP-UX and \s-1HI\-UX\s0.
+options are available under HP-UX and HI-UX.
 .IP "\fB\-mgnu\-ld\fR" 4
 .IX Item "-mgnu-ld"
 Use \s-1GNU\s0 ld specific options.  This passes \fB\-shared\fR to ld when
@@ -7745,7 +7744,7 @@
 .IP "\fB\-threads\fR" 4
 .IX Item "-threads"
 Add support for multithreading with the \fIdce thread\fR library
-under \s-1HP\-UX\s0.  This option sets flags for both the preprocessor and
+under HP-UX.  This option sets flags for both the preprocessor and
 linker.
 .PP
 \fIIntel 960 Options\fR
@@ -8194,7 +8193,7 @@
 .IP "\fB\-mrelax\fR" 4
 .IX Item "-mrelax"
 Shorten some address references at link time, when possible; uses the
-linker option \fB\-relax\fR.  
+linker option \fB\-relax\fR.
 .IP "\fB\-mh\fR" 4
 .IX Item "-mh"
 Generate code for the H8/300H.
@@ -8276,7 +8275,7 @@
 Comply with the calling conventions defined by Renesas.
 .IP "\fB\-mnomacsave\fR" 4
 .IX Item "-mnomacsave"
-Mark the \f(CW\*(C`MAC\*(C'\fR register as call\-clobbered, even if
+Mark the \f(CW\*(C`MAC\*(C'\fR register as call-clobbered, even if
 \&\fB\-mhitachi\fR is given.
 .IP "\fB\-mieee\fR" 4
 .IX Item "-mieee"
@@ -8812,7 +8811,7 @@
 .IP "\fB\-mno\-wide\-bitfields\fR" 4
 .IX Item "-mno-wide-bitfields"
 .PD
-Always treat bit-fields as int\-sized.
+Always treat bit-fields as int-sized.
 .IP "\fB\-m4byte\-functions\fR" 4
 .IX Item "-m4byte-functions"
 .PD 0
@@ -8855,7 +8854,7 @@
 These are the \fB\-m\fR options defined for the Intel \s-1IA\-64\s0 architecture.
 .IP "\fB\-mbig\-endian\fR" 4
 .IX Item "-mbig-endian"
-Generate code for a big endian target.  This is the default for \s-1HP\-UX\s0.
+Generate code for a big endian target.  This is the default for HP-UX.
 .IP "\fB\-mlittle\-endian\fR" 4
 .IX Item "-mlittle-endian"
 Generate code for a little endian target.  This is the default for \s-1AIX5\s0
@@ -8911,7 +8910,7 @@
 useful when compiling kernel code.
 .IP "\fB\-mauto\-pic\fR" 4
 .IX Item "-mauto-pic"
-Generate code that is self\-relocatable.  This implies \fB\-mconstant\-gp\fR.
+Generate code that is self-relocatable.  This implies \fB\-mconstant\-gp\fR.
 This is useful when compiling firmware code.
 .IP "\fB\-minline\-float\-divide\-min\-latency\fR" 4
 .IX Item "-minline-float-divide-min-latency"
@@ -9061,7 +9060,7 @@
 Generate code for the specified architecture.  The choices for
 \&\fIarchitecture-type\fR are \fBv3\fR, \fBv8\fR and \fBv10\fR for
 respectively \s-1ETRAX\s0\ 4, \s-1ETRAX\s0\ 100, and \s-1ETRAX\s0\ 100\ \s-1LX\s0.
-Default is \fBv0\fR except for cris\-axis\-linux\-gnu, where the default is
+Default is \fBv0\fR except for cris-axis-linux-gnu, where the default is
 \&\fBv10\fR.
 .IP "\fB\-mtune=\fR\fIarchitecture-type\fR" 4
 .IX Item "-mtune=architecture-type"
@@ -9106,7 +9105,7 @@
 .IP "\fB\-mno\-side\-effects\fR" 4
 .IX Item "-mno-side-effects"
 Do not emit instructions with side-effects in addressing modes other than
-post\-increment.
+post-increment.
 .IP "\fB\-mstack\-align\fR" 4
 .IX Item "-mstack-align"
 .PD 0
@@ -9121,8 +9120,8 @@
 .IP "\fB\-mno\-const\-align\fR" 4
 .IX Item "-mno-const-align"
 .PD
-These options (no\-options) arranges (eliminate arrangements) for the
-stack\-frame, individual data and constants to be aligned for the maximum
+These options (no-options) arranges (eliminate arrangements) for the
+stack-frame, individual data and constants to be aligned for the maximum
 single data access size for the chosen \s-1CPU\s0 model.  The default is to
 arrange for 32\-bit alignment.  \s-1ABI\s0 details such as structure layout are
 not affected by these options.
@@ -9135,7 +9134,7 @@
 .IX Item "-m8-bit"
 .PD
 Similar to the stack\- data\- and const-align options above, these options
-arrange for stack\-frame, writable data and constants to all be 32\-bit,
+arrange for stack-frame, writable data and constants to all be 32\-bit,
 16\-bit or 8\-bit aligned.  The default is 32\-bit alignment.
 .IP "\fB\-mno\-prologue\-epilogue\fR" 4
 .IX Item "-mno-prologue-epilogue"
@@ -9707,7 +9706,7 @@
 instructions\-\-\-look at the disassembled object code to see the actual
 instructions.  Note that the assembler will use an indirect call for
 every cross-file call, not just those that really will be out of range.
-.Sh "Options for Code Generation Conventions"
+.SS "Options for Code Generation Conventions"
 .IX Subsection "Options for Code Generation Conventions"
 These machine-independent options control the interface conventions
 used in code generation.
@@ -9721,7 +9720,7 @@
 .IX Item "-fbounds-check"
 For front-ends that support it, generate additional code to check that
 indices used to access arrays are within the declared range.  This is
-currently only supported by the Java and Fortran 77 front\-ends, where
+currently only supported by the Java and Fortran 77 front-ends, where
 this option defaults to true and false respectively.
 .IP "\fB\-ftrapv\fR" 4
 .IX Item "-ftrapv"
@@ -9891,7 +9890,7 @@
 Position-independent code requires special support, and therefore works
 only on certain machines.  For the 386, \s-1GCC\s0 supports \s-1PIC\s0 for System V
 but not for the Sun 386i.  Code generated for the \s-1IBM\s0 \s-1RS/6000\s0 is always
-position\-independent.
+position-independent.
 .IP "\fB\-fPIC\fR" 4
 .IX Item "-fPIC"
 If supported for the target machine, emit position-independent code,
@@ -9961,9 +9960,9 @@
 profiling functions otherwise.)
 .Sp
 .Vb 4
-\&        void __cyg_profile_func_enter (void *this_fn,
+\&        void _\|_cyg_profile_func_enter (void *this_fn,
 \&                                       void *call_site);
-\&        void __cyg_profile_func_exit  (void *this_fn,
+\&        void _\|_cyg_profile_func_exit  (void *this_fn,
 \&                                       void *call_site);
 .Ve
 .Sp
--- a/gcc/doc/gfdl.7
+++ b/gcc/doc/gfdl.7
@@ -1,15 +1,7 @@
-.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.14
+.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
 .\"
 .\" Standard preamble:
 .\" ========================================================================
-.de Sh \" Subsection heading
-.br
-.if t .Sp
-.ne 5
-.PP
-\fB\\$1\fR
-.PP
-..
 .de Sp \" Vertical space (when we can't use .PP)
 .if t .sp .5v
 .if n .sp
@@ -25,11 +17,11 @@
 ..
 .\" Set up some character translations and predefined strings.  \*(-- will
 .\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
-.\" double quote, and \*(R" will give a right double quote.  | will give a
-.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
-.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
-.\" expand to `' in nroff, nothing in troff, for use with C<>.
-.tr \(*W-|\(bv\*(Tr
+.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
+.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
+.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
+.\" nothing in troff, for use with C<>.
+.tr \(*W-
 .ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
 .ie n \{\
 .    ds -- \(*W-
@@ -48,22 +40,25 @@
 .    ds R" ''
 'br\}
 .\"
+.\" Escape single quotes in literal strings from groff's Unicode transform.
+.ie \n(.g .ds Aq \(aq
+.el       .ds Aq '
+.\"
 .\" If the F register is turned on, we'll generate index entries on stderr for
-.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
+.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
 .\" entries marked with X<> in POD.  Of course, you'll have to process the
 .\" output yourself in some meaningful fashion.
-.if \nF \{\
+.ie \nF \{\
 .    de IX
 .    tm Index:\\$1\t\\n%\t"\\$2"
 ..
 .    nr % 0
 .    rr F
 .\}
-.\"
-.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
-.\" way too many mistakes in technical documents.
-.hy 0
-.if n .na
+.el \{\
+.    de IX
+..
+.\}
 .\"
 .\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
 .\" Fear.  Run.  Save yourself.  No user-serviceable parts.
@@ -129,25 +124,28 @@
 .\" ========================================================================
 .\"
 .IX Title "GFDL 7"
-.TH GFDL 7 "2005-05-03" "gcc-3.3.6" "GNU"
+.TH GFDL 7 "2013-10-10" "gcc-3.3.6-9s12x-20120502" "GNU"
+.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
+.\" way too many mistakes in technical documents.
+.if n .ad l
+.nh
 .SH "NAME"
 gfdl \- GNU Free Documentation License
 .SH "DESCRIPTION"
 .IX Header "DESCRIPTION"
-.Sh "\s-1GNU\s0 Free Documentation License"
+.SS "\s-1GNU\s0 Free Documentation License"
 .IX Subsection "GNU Free Documentation License"
-.Sh "Version 1.2, November 2002"
+.SS "Version 1.2, November 2002"
 .IX Subsection "Version 1.2, November 2002"
 .Vb 2
 \&        Copyright (c) 2000,2001,2002 Free Software Foundation, Inc.
-\&        59 Temple Place, Suite 330, Boston, MA  02111-1307, USA
-.Ve
-.PP
-.Vb 2
+\&        59 Temple Place, Suite 330, Boston, MA  02111\-1307, USA
+\&
 \&        Everyone is permitted to copy and distribute verbatim copies
 \&        of this license document, but changing it is not allowed.
 .Ve
 .IP "0." 4
+.IX Item "0."
 \&\s-1PREAMBLE\s0
 .Sp
 The purpose of this License is to make a manual, textbook, or other
@@ -171,12 +169,13 @@
 whether it is published as a printed book.  We recommend this License
 principally for works whose purpose is instruction or reference.
 .IP "1." 4
+.IX Item "1."
 \&\s-1APPLICABILITY\s0 \s-1AND\s0 \s-1DEFINITIONS\s0
 .Sp
 This License applies to any manual or other work, in any medium, that
 contains a notice placed by the copyright holder saying it can be
 distributed under the terms of this License.  Such a notice grants a
-world\-wide, royalty-free license, unlimited in duration, to use that
+world-wide, royalty-free license, unlimited in duration, to use that
 work under the conditions stated herein.  The ``Document'', below,
 refers to any such manual or work.  Any member of the public is a
 licensee, and is addressed as ``you''.  You accept the license if you
@@ -259,6 +258,7 @@
 implication that these Warranty Disclaimers may have is void and has
 no effect on the meaning of this License.
 .IP "2." 4
+.IX Item "2."
 \&\s-1VERBATIM\s0 \s-1COPYING\s0
 .Sp
 You may copy and distribute the Document in any medium, either
@@ -274,6 +274,7 @@
 You may also lend copies, under the same conditions stated above, and
 you may publicly display copies.
 .IP "3." 4
+.IX Item "3."
 \&\s-1COPYING\s0 \s-1IN\s0 \s-1QUANTITY\s0
 .Sp
 If you publish printed copies (or copies in media that commonly have
@@ -311,6 +312,7 @@
 Document well before redistributing any large number of copies, to give
 them a chance to provide you with an updated version of the Document.
 .IP "4." 4
+.IX Item "4."
 \&\s-1MODIFICATIONS\s0
 .Sp
 You may copy and distribute a Modified Version of the Document under
@@ -321,35 +323,44 @@
 of it.  In addition, you must do these things in the Modified Version:
 .RS 4
 .IP "A." 4
+.IX Item "A."
 Use in the Title Page (and on the covers, if any) a title distinct
 from that of the Document, and from those of previous versions
 (which should, if there were any, be listed in the History section
 of the Document).  You may use the same title as a previous version
 if the original publisher of that version gives permission.
 .IP "B." 4
+.IX Item "B."
 List on the Title Page, as authors, one or more persons or entities
 responsible for authorship of the modifications in the Modified
 Version, together with at least five of the principal authors of the
 Document (all of its principal authors, if it has fewer than five),
 unless they release you from this requirement.
 .IP "C." 4
+.IX Item "C."
 State on the Title page the name of the publisher of the
 Modified Version, as the publisher.
 .IP "D." 4
+.IX Item "D."
 Preserve all the copyright notices of the Document.
 .IP "E." 4
+.IX Item "E."
 Add an appropriate copyright notice for your modifications
 adjacent to the other copyright notices.
 .IP "F." 4
+.IX Item "F."
 Include, immediately after the copyright notices, a license notice
 giving the public permission to use the Modified Version under the
 terms of this License, in the form shown in the Addendum below.
 .IP "G." 4
+.IX Item "G."
 Preserve in that license notice the full lists of Invariant Sections
 and required Cover Texts given in the Document's license notice.
 .IP "H." 4
+.IX Item "H."
 Include an unaltered copy of this License.
 .IP "I." 4
+.IX Item "I."
 Preserve the section Entitled ``History'', Preserve its Title, and add
 to it an item stating at least the title, year, new authors, and
 publisher of the Modified Version as given on the Title Page.  If
@@ -358,6 +369,7 @@
 given on its Title Page, then add an item describing the Modified
 Version as stated in the previous sentence.
 .IP "J." 4
+.IX Item "J."
 Preserve the network location, if any, given in the Document for
 public access to a Transparent copy of the Document, and likewise
 the network locations given in the Document for previous versions
@@ -366,21 +378,26 @@
 least four years before the Document itself, or if the original
 publisher of the version it refers to gives permission.
 .IP "K." 4
+.IX Item "K."
 For any section Entitled ``Acknowledgements'' or ``Dedications'', Preserve
 the Title of the section, and preserve in the section all the
 substance and tone of each of the contributor acknowledgements and/or
 dedications given therein.
 .IP "L." 4
+.IX Item "L."
 Preserve all the Invariant Sections of the Document,
 unaltered in their text and in their titles.  Section numbers
 or the equivalent are not considered part of the section titles.
 .IP "M." 4
+.IX Item "M."
 Delete any section Entitled ``Endorsements''.  Such a section
 may not be included in the Modified Version.
 .IP "N." 4
+.IX Item "N."
 Do not retitle any existing section to be Entitled ``Endorsements'' or
 to conflict in title with any Invariant Section.
 .IP "O." 4
+.IX Item "O."
 Preserve any Warranty Disclaimers.
 .RE
 .RS 4
@@ -413,6 +430,7 @@
 imply endorsement of any Modified Version.
 .RE
 .IP "5." 4
+.IX Item "5."
 \&\s-1COMBINING\s0 \s-1DOCUMENTS\s0
 .Sp
 You may combine the Document with other documents released under this
@@ -437,6 +455,7 @@
 and any sections Entitled ``Dedications''.  You must delete all
 sections Entitled ``Endorsements.''
 .IP "6." 4
+.IX Item "6."
 \&\s-1COLLECTIONS\s0 \s-1OF\s0 \s-1DOCUMENTS\s0
 .Sp
 You may make a collection consisting of the Document and other documents
@@ -450,6 +469,7 @@
 License into the extracted document, and follow this License in all
 other respects regarding verbatim copying of that document.
 .IP "7." 4
+.IX Item "7."
 \&\s-1AGGREGATION\s0 \s-1WITH\s0 \s-1INDEPENDENT\s0 \s-1WORKS\s0
 .Sp
 A compilation of the Document or its derivatives with other separate
@@ -469,6 +489,7 @@
 Otherwise they must appear on printed covers that bracket the whole
 aggregate.
 .IP "8." 4
+.IX Item "8."
 \&\s-1TRANSLATION\s0
 .Sp
 Translation is considered a kind of modification, so you may
@@ -489,6 +510,7 @@
 its Title (section 1) will typically require changing the actual
 title.
 .IP "9." 4
+.IX Item "9."
 \&\s-1TERMINATION\s0
 .Sp
 You may not copy, modify, sublicense, or distribute the Document except
@@ -516,7 +538,7 @@
 Free Software Foundation.  If the Document does not specify a version
 number of this License, you may choose any version ever published (not
 as a draft) by the Free Software Foundation.
-.Sh "\s-1ADDENDUM:\s0 How to use this License for your documents"
+.SS "\s-1ADDENDUM:\s0 How to use this License for your documents"
 .IX Subsection "ADDENDUM: How to use this License for your documents"
 To use this License in a document you have written, include a copy of
 the License in the document and put the following copyright and
@@ -527,9 +549,9 @@
 \&          Permission is granted to copy, distribute and/or modify this document
 \&          under the terms of the GNU Free Documentation License, Version 1.2
 \&          or any later version published by the Free Software Foundation;
-\&          with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
-\&          A copy of the license is included in the section entitled ``GNU
-\&          Free Documentation License''.
+\&          with no Invariant Sections, no Front\-Cover Texts, and no Back\-Cover Texts.
+\&          A copy of the license is included in the section entitled \`\`GNU
+\&          Free Documentation License\*(Aq\*(Aq.
 .Ve
 .PP
 If you have Invariant Sections, Front-Cover Texts and Back-Cover Texts,
@@ -537,7 +559,7 @@
 .PP
 .Vb 3
 \&            with the Invariant Sections being <list their titles>, with
-\&            the Front-Cover Texts being <list>, and with the Back-Cover Texts
+\&            the Front\-Cover Texts being <list>, and with the Back\-Cover Texts
 \&            being <list>.
 .Ve
 .PP
--- a/gcc/doc/gpl.7
+++ b/gcc/doc/gpl.7
@@ -1,15 +1,7 @@
-.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.14
+.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
 .\"
 .\" Standard preamble:
 .\" ========================================================================
-.de Sh \" Subsection heading
-.br
-.if t .Sp
-.ne 5
-.PP
-\fB\\$1\fR
-.PP
-..
 .de Sp \" Vertical space (when we can't use .PP)
 .if t .sp .5v
 .if n .sp
@@ -25,11 +17,11 @@
 ..
 .\" Set up some character translations and predefined strings.  \*(-- will
 .\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
-.\" double quote, and \*(R" will give a right double quote.  | will give a
-.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
-.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
-.\" expand to `' in nroff, nothing in troff, for use with C<>.
-.tr \(*W-|\(bv\*(Tr
+.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
+.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
+.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
+.\" nothing in troff, for use with C<>.
+.tr \(*W-
 .ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
 .ie n \{\
 .    ds -- \(*W-
@@ -48,22 +40,25 @@
 .    ds R" ''
 'br\}
 .\"
+.\" Escape single quotes in literal strings from groff's Unicode transform.
+.ie \n(.g .ds Aq \(aq
+.el       .ds Aq '
+.\"
 .\" If the F register is turned on, we'll generate index entries on stderr for
-.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
+.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
 .\" entries marked with X<> in POD.  Of course, you'll have to process the
 .\" output yourself in some meaningful fashion.
-.if \nF \{\
+.ie \nF \{\
 .    de IX
 .    tm Index:\\$1\t\\n%\t"\\$2"
 ..
 .    nr % 0
 .    rr F
 .\}
-.\"
-.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
-.\" way too many mistakes in technical documents.
-.hy 0
-.if n .na
+.el \{\
+.    de IX
+..
+.\}
 .\"
 .\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
 .\" Fear.  Run.  Save yourself.  No user-serviceable parts.
@@ -129,92 +124,81 @@
 .\" ========================================================================
 .\"
 .IX Title "GPL 7"
-.TH GPL 7 "2005-05-03" "gcc-3.3.6" "GNU"
+.TH GPL 7 "2013-10-10" "gcc-3.3.6-9s12x-20120502" "GNU"
+.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
+.\" way too many mistakes in technical documents.
+.if n .ad l
+.nh
 .SH "NAME"
 gpl \- GNU General Public License
 .SH "DESCRIPTION"
 .IX Header "DESCRIPTION"
-.Sh "\s-1GNU\s0 \s-1GENERAL\s0 \s-1PUBLIC\s0 \s-1LICENSE\s0"
+.SS "\s-1GNU\s0 \s-1GENERAL\s0 \s-1PUBLIC\s0 \s-1LICENSE\s0"
 .IX Subsection "GNU GENERAL PUBLIC LICENSE"
-.Sh "Version 2, June 1991"
+.SS "Version 2, June 1991"
 .IX Subsection "Version 2, June 1991"
 .Vb 2
 \&        Copyright (c) 1989, 1991 Free Software Foundation, Inc.
-\&        59 Temple Place - Suite 330, Boston, MA  02111-1307, USA
-.Ve
-.PP
-.Vb 2
+\&        59 Temple Place \- Suite 330, Boston, MA  02111\-1307, USA
+\&
 \&        Everyone is permitted to copy and distribute verbatim copies
 \&        of this license document, but changing it is not allowed.
 .Ve
-.Sh "Preamble"
+.SS "Preamble"
 .IX Subsection "Preamble"
 .Vb 9
 \&  The licenses for most software are designed to take away your
 \&freedom to share and change it.  By contrast, the GNU General Public
 \&License is intended to guarantee your freedom to share and change free
-\&software---to make sure the software is free for all its users.  This
+\&software\-\-\-to make sure the software is free for all its users.  This
 \&General Public License applies to most of the Free Software
-\&Foundation's software and to any other program whose authors commit to
+\&Foundation\*(Aqs software and to any other program whose authors commit to
 \&using it.  (Some other Free Software Foundation software is covered by
 \&the GNU Library General Public License instead.)  You can apply it to
 \&your programs, too.
-.Ve
-.PP
-.Vb 6
+\&
 \&  When we speak of free software, we are referring to freedom, not
 \&price.  Our General Public Licenses are designed to make sure that you
 \&have the freedom to distribute copies of free software (and charge for
 \&this service if you wish), that you receive source code or can get it
 \&if you want it, that you can change the software or use pieces of it
 \&in new free programs; and that you know you can do these things.
-.Ve
-.PP
-.Vb 4
+\&
 \&  To protect your rights, we need to make restrictions that forbid
 \&anyone to deny you these rights or to ask you to surrender the rights.
 \&These restrictions translate to certain responsibilities for you if you
 \&distribute copies of the software, or if you modify it.
-.Ve
-.PP
-.Vb 5
+\&
 \&  For example, if you distribute copies of such a program, whether
 \&gratis or for a fee, you must give the recipients all the rights that
 \&you have.  You must make sure that they, too, receive or can get the
 \&source code.  And you must show them these terms so they know their
 \&rights.
-.Ve
-.PP
-.Vb 3
+\&
 \&  We protect your rights with two steps: (1) copyright the software, and
 \&(2) offer you this license which gives you legal permission to copy,
 \&distribute and/or modify the software.
-.Ve
-.PP
-.Vb 6
-\&  Also, for each author's protection and ours, we want to make certain
+\&
+\&  Also, for each author\*(Aqs protection and ours, we want to make certain
 \&that everyone understands that there is no warranty for this free
 \&software.  If the software is modified by someone else and passed on, we
 \&want its recipients to know that what they have is not the original, so
 \&that any problems introduced by others will not reflect on the original
-\&authors' reputations.
-.Ve
-.PP
-.Vb 5
+\&authors\*(Aq reputations.
+\&
 \&  Finally, any free program is threatened constantly by software
 \&patents.  We wish to avoid the danger that redistributors of a free
 \&program will individually obtain patent licenses, in effect making the
 \&program proprietary.  To prevent this, we have made it clear that any
-\&patent must be licensed for everyone's free use or not licensed at all.
-.Ve
-.PP
-.Vb 2
+\&patent must be licensed for everyone\*(Aqs free use or not licensed at all.
+\&
 \&  The precise terms and conditions for copying, distribution and
 \&modification follow.
 .Ve
-.Sh "\s-1TERMS\s0 \s-1AND\s0 \s-1CONDITIONS\s0 \s-1FOR\s0 \s-1COPYING\s0, \s-1DISTRIBUTION\s0 \s-1AND\s0 \s-1MODIFICATION\s0"
+.SS "\s-1TERMS\s0 \s-1AND\s0 \s-1CONDITIONS\s0 \s-1FOR\s0 \s-1COPYING\s0, \s-1DISTRIBUTION\s0 \s-1AND\s0 \s-1MODIFICATION\s0"
 .IX Subsection "TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION"
 .IP "0." 4
+.IX Item "0."
 This License applies to any program or other work which contains
 a notice placed by the copyright holder saying it may be distributed
 under the terms of this General Public License.  The ``Program'', below,
@@ -232,6 +216,7 @@
 Program (independent of having been made by running the Program).
 Whether that is true depends on what the Program does.
 .IP "1." 4
+.IX Item "1."
 You may copy and distribute verbatim copies of the Program's
 source code as you receive it, in any medium, provided that you
 conspicuously and appropriately publish on each copy an appropriate
@@ -243,20 +228,24 @@
 You may charge a fee for the physical act of transferring a copy, and
 you may at your option offer warranty protection in exchange for a fee.
 .IP "2." 4
+.IX Item "2."
 You may modify your copy or copies of the Program or any portion
 of it, thus forming a work based on the Program, and copy and
 distribute such modifications or work under the terms of Section 1
 above, provided that you also meet all of these conditions:
 .RS 4
 .IP "a." 4
+.IX Item "a."
 You must cause the modified files to carry prominent notices
 stating that you changed the files and the date of any change.
 .IP "b." 4
+.IX Item "b."
 You must cause any work that you distribute or publish, that in
 whole or in part contains or is derived from the Program or any
 part thereof, to be licensed as a whole at no charge to all third
 parties under the terms of this License.
 .IP "c." 4
+.IX Item "c."
 If the modified program normally reads commands interactively
 when run, you must cause it, when started running for such
 interactive use in the most ordinary way, to print or display an
@@ -291,15 +280,18 @@
 the scope of this License.
 .RE
 .IP "3." 4
+.IX Item "3."
 You may copy and distribute the Program (or a work based on it,
 under Section 2) in object code or executable form under the terms of
 Sections 1 and 2 above provided that you also do one of the following:
 .RS 4
 .IP "a." 4
+.IX Item "a."
 Accompany it with the complete corresponding machine-readable
 source code, which must be distributed under the terms of Sections
 1 and 2 above on a medium customarily used for software interchange; or,
 .IP "b." 4
+.IX Item "b."
 Accompany it with a written offer, valid for at least three
 years, to give any third party, for a charge no more than your
 cost of physically performing source distribution, a complete
@@ -307,6 +299,7 @@
 distributed under the terms of Sections 1 and 2 above on a medium
 customarily used for software interchange; or,
 .IP "c." 4
+.IX Item "c."
 Accompany it with the information you received as to the offer
 to distribute corresponding source code.  (This alternative is
 allowed only for noncommercial distribution and only if you
@@ -333,6 +326,7 @@
 compelled to copy the source along with the object code.
 .RE
 .IP "4." 4
+.IX Item "4."
 You may not copy, modify, sublicense, or distribute the Program
 except as expressly provided under this License.  Any attempt
 otherwise to copy, modify, sublicense or distribute the Program is
@@ -341,6 +335,7 @@
 this License will not have their licenses terminated so long as such
 parties remain in full compliance.
 .IP "5." 4
+.IX Item "5."
 You are not required to accept this License, since you have not
 signed it.  However, nothing else grants you permission to modify or
 distribute the Program or its derivative works.  These actions are
@@ -350,6 +345,7 @@
 all its terms and conditions for copying, distributing or modifying
 the Program or works based on it.
 .IP "6." 4
+.IX Item "6."
 Each time you redistribute the Program (or any work based on the
 Program), the recipient automatically receives a license from the
 original licensor to copy, distribute or modify the Program subject to
@@ -358,6 +354,7 @@
 You are not responsible for enforcing compliance by third parties to
 this License.
 .IP "7." 4
+.IX Item "7."
 If, as a consequence of a court judgment or allegation of patent
 infringement or for any other reason (not limited to patent issues),
 conditions are imposed on you (whether by court order, agreement or
@@ -390,6 +387,7 @@
 This section is intended to make thoroughly clear what is believed to
 be a consequence of the rest of this License.
 .IP "8." 4
+.IX Item "8."
 If the distribution and/or use of the Program is restricted in
 certain countries either by patents or by copyrighted interfaces, the
 original copyright holder who places the Program under this License
@@ -398,6 +396,7 @@
 countries not thus excluded.  In such case, this License incorporates
 the limitation as if written in the body of this License.
 .IP "9." 4
+.IX Item "9."
 The Free Software Foundation may publish revised and/or new versions
 of the General Public License from time to time.  Such new versions will
 be similar in spirit to the present version, but may differ in detail to
@@ -419,7 +418,7 @@
 make exceptions for this.  Our decision will be guided by the two goals
 of preserving the free status of all derivatives of our free software and
 of promoting the sharing and reuse of software generally.
-.Sh "\s-1NO\s0 \s-1WARRANTY\s0"
+.SS "\s-1NO\s0 \s-1WARRANTY\s0"
 .IX Subsection "NO WARRANTY"
 .IP "11." 4
 .IX Item "11."
@@ -443,46 +442,37 @@
 \&\s-1YOU\s0 \s-1OR\s0 \s-1THIRD\s0 \s-1PARTIES\s0 \s-1OR\s0 A \s-1FAILURE\s0 \s-1OF\s0 \s-1THE\s0 \s-1PROGRAM\s0 \s-1TO\s0 \s-1OPERATE\s0 \s-1WITH\s0 \s-1ANY\s0 \s-1OTHER\s0
 \&\s-1PROGRAMS\s0), \s-1EVEN\s0 \s-1IF\s0 \s-1SUCH\s0 \s-1HOLDER\s0 \s-1OR\s0 \s-1OTHER\s0 \s-1PARTY\s0 \s-1HAS\s0 \s-1BEEN\s0 \s-1ADVISED\s0 \s-1OF\s0 \s-1THE\s0
 \&\s-1POSSIBILITY\s0 \s-1OF\s0 \s-1SUCH\s0 \s-1DAMAGES\s0.
-.Sh "\s-1END\s0 \s-1OF\s0 \s-1TERMS\s0 \s-1AND\s0 \s-1CONDITIONS\s0"
+.SS "\s-1END\s0 \s-1OF\s0 \s-1TERMS\s0 \s-1AND\s0 \s-1CONDITIONS\s0"
 .IX Subsection "END OF TERMS AND CONDITIONS"
-.Sh "How to Apply These Terms to Your New Programs"
+.SS "How to Apply These Terms to Your New Programs"
 .IX Subsection "How to Apply These Terms to Your New Programs"
 .Vb 3
 \&  If you develop a new program, and you want it to be of the greatest
 \&possible use to the public, the best way to achieve this is to make it
 \&free software which everyone can redistribute and change under these terms.
-.Ve
-.PP
-.Vb 4
+\&
 \&  To do so, attach the following notices to the program.  It is safest
 \&to attach them to the start of each source file to most effectively
 \&convey the exclusion of warranty; and each file should have at least
-\&the ``copyright'' line and a pointer to where the full notice is found.
-.Ve
-.PP
-.Vb 2
-\&        <one line to give the program's name and a brief idea of what it does.>
+\&the \`\`copyright\*(Aq\*(Aq line and a pointer to where the full notice is found.
+\&
+\&
+\&        <one line to give the program\*(Aqs name and a brief idea of what it does.>
 \&        Copyright (C) <year>  <name of author>
-.Ve
-.PP
-.Vb 4
+\&
 \&        This program is free software; you can redistribute it and/or modify
 \&        it under the terms of the GNU General Public License as published by
 \&        the Free Software Foundation; either version 2 of the License, or
 \&        (at your option) any later version.
-.Ve
-.PP
-.Vb 4
+\&
 \&        This program is distributed in the hope that it will be useful,
 \&        but WITHOUT ANY WARRANTY; without even the implied warranty of
 \&        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 \&        GNU General Public License for more details.
-.Ve
-.PP
-.Vb 3
+\&
 \&        You should have received a copy of the GNU General Public License
 \&        along with this program; if not, write to the Free Software Foundation,
-\&        Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+\&        Inc., 59 Temple Place \- Suite 330, Boston, MA  02111\-1307, USA.
 .Ve
 .PP
 Also add information on how to contact you by electronic and paper mail.
@@ -493,9 +483,9 @@
 .Vb 5
 \&        Gnomovision version 69, Copyright (C) <year> <name of author>
 \&        Gnomovision comes with ABSOLUTELY NO WARRANTY; for details
-\&        type `show w'.
+\&        type \`show w\*(Aq.
 \&        This is free software, and you are welcome to redistribute it
-\&        under certain conditions; type `show c' for details.
+\&        under certain conditions; type \`show c\*(Aq for details.
 .Ve
 .PP
 The hypothetical commands \fBshow w\fR and \fBshow c\fR should show
@@ -510,10 +500,8 @@
 .PP
 .Vb 2
 \&        Yoyodyne, Inc., hereby disclaims all copyright interest in the program
-\&        `Gnomovision' (which makes passes at compilers) written by James Hacker.
-.Ve
-.PP
-.Vb 2
+\&        \`Gnomovision\*(Aq (which makes passes at compilers) written by James Hacker.
+\&
 \&        <signature of Ty Coon>, 1 April 1989
 \&        Ty Coon, President of Vice
 .Ve
@@ -533,3 +521,12 @@
 .PP
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.
+.SH "POD ERRORS"
+.IX Header "POD ERRORS"
+Hey! \fBThe above document had some coding errors, which are explained below:\fR
+.IP "Around line 341:" 4
+.IX Item "Around line 341:"
+You forgot a '=back' before '=head2'
+.IP "Around line 345:" 4
+.IX Item "Around line 345:"
+\&'=item' outside of any '=over'
--- a/gcc/doc/invoke.texi
+++ b/gcc/doc/invoke.texi
@@ -329,7 +329,7 @@
 
 @emph{M68hc1x Options}
 @gccoptlist{-m6811  -m6812  -m68hc11  -m68hc12  -m68hcs12 @gol
--mauto-incdec  -minmax  -mlong-calls  -mshort @gol
+-mauto-incdec  -minmax  -mlong-calls  -mrelax  -mshort @gol
 -msoft-reg-count=@var{count}}
 
 @emph{VAX Options}
@@ -5624,7 +5624,20 @@
 @opindex mno-long-calls
 Treat all calls as being far away (near).  If calls are assumed to be
 far away, the compiler will use the @code{call} instruction to
-call a function and the @code{rtc} instruction for returning.
+call a function and the @code{rtc} instruction for returning.  An interrupt
+or a trap handler is not affected by this option and is always considered near.
+
+@item -mrelax
+@opindex mrelax
+Indicate to the compiler and linker that they should perform a relaxation
+optimization pass to shorten branches, calls and absolute memory addresses.
+The compiler will not use direct addressing mode for pseudo-soft registers and
+it will also emit some @code{bset} and @code{bclr} sequences that can be
+optimized by the linker.  The linker option @option{-relax} will be used
+and the linker will transform 16-bit addressing modes into direct addressing
+modes if possible.
+
+This option makes symbolic debugging impossible.
 
 @item -mshort
 @opindex mshort
--- a/gcc/expmed.c
+++ b/gcc/expmed.c
@@ -474,6 +474,15 @@
 	 result in an abort.  */
       fieldmode = smallest_mode_for_size (nwords * BITS_PER_WORD, MODE_INT);
 
+      /* When the value is a constant, the constant_subword applies a
+         correction on big endian targets.  If the bitfield contains less words
+         than the value (fieldmode), the constant that is extracted is shifted
+         by the word difference.  Example: bitfield = 33, fieldmode = DImode
+         and constant_subword extracts word 1 2 3 instead of 0 1 2.  */
+      int correction = 0;
+      if (WORDS_BIG_ENDIAN && CONSTANT_P (value))
+        correction = GET_MODE_BITSIZE (fieldmode) / BITS_PER_WORD - nwords;
+
       for (i = 0; i < nwords; i++)
 	{
 	  /* If I is 0, use the low-order word in both field and target;
@@ -488,7 +497,7 @@
 	  store_bit_field (op0, MIN (BITS_PER_WORD,
 				     bitsize - i * BITS_PER_WORD),
 			   bitnum + bit_offset, word_mode,
-			   operand_subword_force (value, wordnum,
+			   operand_subword_force (value, correction + wordnum,
 						  (GET_MODE (value) == VOIDmode
 						   ? fieldmode
 						   : GET_MODE (value))),
@@ -2142,7 +2151,7 @@
   if ((t & 1) == 0)
     {
       m = floor_log2 (t & -t);	/* m = number of low zero bits */
-      if (m < BITS_PER_WORD)
+      if (m < MAX_BITS_PER_WORD)
 	{
 	  q = t >> m;
 	  cost = shift_cost[m];
@@ -2227,7 +2236,7 @@
       unsigned HOST_WIDE_INT d;
 
       d = ((unsigned HOST_WIDE_INT) 1 << m) + 1;
-      if (t % d == 0 && t > d && m < BITS_PER_WORD)
+      if (t % d == 0 && t > d && m < MAX_BITS_PER_WORD)
 	{
 	  cost = MIN (shiftadd_cost[m], add_cost + shift_cost[m]);
 	  synth_mult (alg_in, t / d, cost_limit - cost);
@@ -2246,7 +2255,7 @@
 	}
 
       d = ((unsigned HOST_WIDE_INT) 1 << m) - 1;
-      if (t % d == 0 && t > d && m < BITS_PER_WORD)
+      if (t % d == 0 && t > d && m < MAX_BITS_PER_WORD)
 	{
 	  cost = MIN (shiftsub_cost[m], add_cost + shift_cost[m]);
 	  synth_mult (alg_in, t / d, cost_limit - cost);
@@ -2271,7 +2280,7 @@
       q = t - 1;
       q = q & -q;
       m = exact_log2 (q);
-      if (m >= 0 && m < BITS_PER_WORD)
+      if (m >= 0 && m < MAX_BITS_PER_WORD)
 	{
 	  cost = shiftadd_cost[m];
 	  synth_mult (alg_in, (t - 1) >> m, cost_limit - cost);
@@ -2290,7 +2299,7 @@
       q = t + 1;
       q = q & -q;
       m = exact_log2 (q);
-      if (m >= 0 && m < BITS_PER_WORD)
+      if (m >= 0 && m < MAX_BITS_PER_WORD)
 	{
 	  cost = shiftsub_cost[m];
 	  synth_mult (alg_in, (t + 1) >> m, cost_limit - cost);
@@ -2793,7 +2802,7 @@
 
   /* expand_mult handles constant multiplication of word_mode
      or narrower.  It does a poor job for large modes.  */
-  if (size < BITS_PER_WORD
+  if (size < MAX_BITS_PER_WORD
       && mul_cost[(int) wider_mode] + shift_cost[size-1] < max_cost)
     {
       /* We have to do this, since expand_binop doesn't do conversion for
@@ -2824,7 +2833,7 @@
 
   /* Secondly, same as above, but use sign flavor opposite of unsignedp.
      Need to adjust the result after the multiplication.  */
-  if (size - 1 < BITS_PER_WORD
+  if (size - 1 < MAX_BITS_PER_WORD
       && (mul_highpart_cost[(int) mode] + 2 * shift_cost[size-1] + 4 * add_cost
 	  < max_cost))
     {
@@ -2849,7 +2858,7 @@
   /* Try widening the mode and perform a non-widening multiplication.  */
   moptab = smul_optab;
   if (smul_optab->handlers[(int) wider_mode].insn_code != CODE_FOR_nothing
-      && size - 1 < BITS_PER_WORD
+      && size - 1 < MAX_BITS_PER_WORD
       && mul_cost[(int) wider_mode] + shift_cost[size-1] < max_cost)
     {
       op1 = wide_op1;
@@ -2859,7 +2868,7 @@
   /* Try widening multiplication of opposite signedness, and adjust.  */
   moptab = unsignedp ? smul_widen_optab : umul_widen_optab;
   if (moptab->handlers[(int) wider_mode].insn_code != CODE_FOR_nothing
-      && size - 1 < BITS_PER_WORD
+      && size - 1 < MAX_BITS_PER_WORD
       && (mul_widen_cost[(int) wider_mode]
 	  + 2 * shift_cost[size-1] + 4 * add_cost < max_cost))
     {
@@ -3199,7 +3208,7 @@
 			  {
 			    rtx t1, t2, t3, t4;
 
-			    if (post_shift - 1 >= BITS_PER_WORD)
+			    if (post_shift - 1 >= MAX_BITS_PER_WORD)
 			      goto fail1;
 
 			    extra_cost = (shift_cost[post_shift - 1]
@@ -3226,8 +3235,8 @@
 			  {
 			    rtx t1, t2;
 
-			    if (pre_shift >= BITS_PER_WORD
-				|| post_shift >= BITS_PER_WORD)
+			    if (pre_shift >= MAX_BITS_PER_WORD
+				|| post_shift >= MAX_BITS_PER_WORD)
 			      goto fail1;
 
 			    t1 = expand_shift (RSHIFT_EXPR, compute_mode, op0,
@@ -3363,8 +3372,8 @@
 		      {
 			rtx t1, t2, t3;
 
-			if (post_shift >= BITS_PER_WORD
-			    || size - 1 >= BITS_PER_WORD)
+			if (post_shift >= MAX_BITS_PER_WORD
+			    || size - 1 >= MAX_BITS_PER_WORD)
 			  goto fail1;
 
 			extra_cost = (shift_cost[post_shift]
@@ -3393,8 +3402,8 @@
 		      {
 			rtx t1, t2, t3, t4;
 
-			if (post_shift >= BITS_PER_WORD
-			    || size - 1 >= BITS_PER_WORD)
+			if (post_shift >= MAX_BITS_PER_WORD
+			    || size - 1 >= MAX_BITS_PER_WORD)
 			  goto fail1;
 
 			ml |= (~(unsigned HOST_WIDE_INT) 0) << (size - 1);
@@ -3480,8 +3489,8 @@
 		    if (mh)
 		      abort ();
 
-		    if (post_shift < BITS_PER_WORD
-			&& size - 1 < BITS_PER_WORD)
+		    if (post_shift < MAX_BITS_PER_WORD
+			&& size - 1 < MAX_BITS_PER_WORD)
 		      {
 			t1 = expand_shift (RSHIFT_EXPR, compute_mode, op0,
 					   build_int_2 (size - 1, 0),
@@ -4135,8 +4144,12 @@
 
     case SIGN_EXTEND:
     case ZERO_EXTEND:
-      t = (*lang_hooks.types.type_for_mode) (GET_MODE (XEXP (x, 0)),
-					     GET_CODE (x) == ZERO_EXTEND);
+      if (CONSTANT_P (XEXP (x, 0)))
+        t = (*lang_hooks.types.type_for_mode) (GET_MODE (x),
+					       GET_CODE (x) == ZERO_EXTEND);
+      else
+        t = (*lang_hooks.types.type_for_mode) (GET_MODE (XEXP (x, 0)),
+					       GET_CODE (x) == ZERO_EXTEND);
       return fold (convert (type, make_tree (t, XEXP (x, 0))));
 
    default:
--- a/gcc/final.c
+++ b/gcc/final.c
@@ -2909,7 +2909,22 @@
   /* simplify_subreg does not remove subreg from volatile references.
      We are required to.  */
   if (GET_CODE (y) == MEM)
-    *xp = adjust_address (y, GET_MODE (x), SUBREG_BYTE (x));
+    {
+      unsigned outer_size = GET_MODE_SIZE (GET_MODE (x));
+      unsigned inner_size = GET_MODE_SIZE (GET_MODE (y));
+      int offset = SUBREG_BYTE (x);
+
+      /* If this is a paradoxical subreg with a SUBREG_BYTE set
+         to 0 we must adjust the offset for big-endian machines
+         (otherwise we take the address of the high part).  */
+      if (BYTES_BIG_ENDIAN && !offset && outer_size > inner_size)
+        {
+          offset += MIN (inner_size, UNITS_PER_WORD);
+          offset -= MIN (outer_size, UNITS_PER_WORD);
+        }
+
+      *xp = adjust_address (y, GET_MODE (x), offset);
+    }
   else
     {
       rtx new = simplify_subreg (GET_MODE (x), y, GET_MODE (y),
--- a/gcc/flow.c
+++ b/gcc/flow.c
@@ -571,7 +571,7 @@
 	      fputs ("Old:\n", rtl_dump_file);
 	      dump_bb (bb, rtl_dump_file);
 	    }
-	  abort ();
+	  // SCz: abort ();
 	}
     }
   else
--- a/gcc/gcse.c
+++ b/gcc/gcse.c
@@ -3513,8 +3513,7 @@
       /* ??? If the change fails, we return 0, even though we created
 	 an insn.  I think this is ok.  */
       new_insn
-	= emit_insn_after (gen_rtx_SET (VOIDmode, to,
-					SET_DEST (expr_set)),
+	= emit_insn_after (gen_move_insn (to, SET_DEST (expr_set)),
 			   insn_computes_expr);
 
       /* Keep register set table up to date.  */
@@ -3525,7 +3524,7 @@
 	{
 	  fprintf (gcse_file, "GCSE: Creating insn %d to copy value of reg %d",
 		   INSN_UID (NEXT_INSN (insn_computes_expr)),
-		   REGNO (SET_SRC (PATTERN (NEXT_INSN (insn_computes_expr)))));
+		   REGNO (SET_DEST (expr_set)));
 	  fprintf (gcse_file, ", computed in insn %d,\n",
 		   INSN_UID (insn_computes_expr));
 	  fprintf (gcse_file, "      into newly allocated reg %d\n",
--- a/gcc/gengtype-lex.c
+++ b/gcc/gengtype-lex.c
@@ -2,7 +2,7 @@
 /* A lexical scanner generated by flex */
 
 /* Scanner skeleton version:
- * $Header: /home/daffy/u0/vern/flex/RCS/flex.skl,v 2.91 96/09/10 16:58:48 vern Exp $
+ * $Header: /home/cvs/toolscvsroot/tools/gcc/gcc-3.3.6-s12x/gcc/gengtype-lex.c,v 1.1 2012/05/02 15:45:12 jsmcortina Exp $
  */
 
 #define FLEX_SCANNER
--- a/gcc/libgcc2.c
+++ b/gcc/libgcc2.c
@@ -490,7 +490,12 @@
 
 #if (defined (L_udivdi3) || defined (L_divdi3) || \
      defined (L_umoddi3) || defined (L_moddi3))
-#define L_udivmoddi4
+#if !defined(mc6811) && !defined(mc6812)
+# define L_udivmoddi4
+#else
+extern UDWtype
+__udivmoddi4 (UDWtype n, UDWtype d, UDWtype *rp);
+#endif
 #endif
 
 #ifdef L_clz
--- a/gcc/longlong.h
+++ b/gcc/longlong.h
@@ -1162,6 +1162,67 @@
 
 #endif /* __GNUC__ */
 
+#if defined(mc6811) || defined(mc6812)
+#define sub_ddmmss(sh, sl, ah, al, bh, bl)				\
+  do {									\
+    __asm__ ("subd 2+%2\n"						\
+             "\txgdx\n"							\
+             "\tsbcb 1+%2\n"						\
+             "\tsbca %2\n"						\
+             "\txgdx" : "=D"((USItype) (sl))				\
+		      : "0"((USItype) (al)), "m"((USItype) (bl)));	\
+    /* Assumes that the carry is not modified. */			\
+    /* which is true since the reload instructions */			\
+    /* generated between the two __asm__ only do load/store.  */	\
+    __asm__ ("sbcb 3+%2\n"						\
+             "\tsbca 2+%2\n"						\
+             "\txgdx\n"							\
+             "\tsbcb 1+%2\n"						\
+             "\tsbca %2\n"						\
+             "\txgdx" : "=D"((USItype) (sh))				\
+		      : "0"((USItype) (ah)), "m"((USItype) (bh)));	\
+  } while (0)
+#if defined(mc6812)
+#define umul_ppmm(w1, w0, u, v)						\
+  do {									\
+    UWtype __x0, __x1, __x2, __x3;					\
+									\
+    __x0 = ((UWtype) ((UHItype) __ll_lowpart (u))) * ((UWtype) ((UHItype) __ll_lowpart (v)));	\
+    __x1 = ((UWtype) ((UHItype) __ll_lowpart (u))) * ((UWtype) ((UHItype) __ll_highpart (v)));	\
+    __x2 = ((UWtype) ((UHItype) __ll_highpart (u))) * ((UWtype) ((UHItype) __ll_lowpart (v)));	\
+    __x3 = ((UWtype) ((UHItype) __ll_highpart (u))) * ((UWtype) ((UHItype) __ll_highpart (v)));	\
+									\
+    __x1 += __ll_highpart (__x0);/* this can't give carry */		\
+    __x1 += __x2;		/* but this indeed can */		\
+    __asm__ ("bcc 1f\n"                                                 \
+	     "\tinx\n"							\
+	     "1:" : "=D"(__x3) : "0"(__x3));				\
+									\
+    (w1) = __x3 + __ll_highpart (__x1);					\
+    (w0) = __ll_lowpart (__x1) * __ll_B + __ll_lowpart (__x0);		\
+  } while (0)
+#else
+#define umul_ppmm(w1, w0, u, v)						\
+  do {									\
+    UWtype __x0, __x1, __x2, __x3;					\
+    extern UWtype __attribute__((near)) __mulhi32 (UHItype, UHItype);	\
+									\
+    __x0 = __mulhi32 (__ll_lowpart (u), __ll_lowpart (v));		\
+    __x1 = __mulhi32 (__ll_lowpart (u), __ll_highpart (v));		\
+    __x2 = __mulhi32 (__ll_highpart (u), __ll_lowpart (v));		\
+    __x3 = __mulhi32 (__ll_highpart (u), __ll_highpart (v));		\
+									\
+    __x1 += __ll_highpart (__x0);/* this can't give carry */		\
+    __x1 += __x2;		/* but this indeed can */		\
+    __asm__ ("bcc 1f\n"                                                 \
+	     "\tinx\n"							\
+	     "1:" : "=D"(__x3) : "0"(__x3));				\
+									\
+    (w1) = __x3 + __ll_highpart (__x1);					\
+    (w0) = __ll_lowpart (__x1) * __ll_B + __ll_lowpart (__x0);		\
+  } while (0)
+#endif
+#endif
 /* If this machine has no inline assembler, use C macros.  */
 
 #if !defined (add_ssaaaa)
@@ -1232,6 +1293,45 @@
 #endif
 
 /* Define this unconditionally, so it can be used for debugging.  */
+#if defined(mc6811) || defined(mc6812)
+extern USItype __udivmodsi4(USItype num, USItype den, USItype* mod);
+
+#define __udiv_qrnnd_c(q, r, n1, n0, d) \
+  do {									\
+    USItype __d1, __d0, __q1, __q0;					\
+    USItype __r0, __m;						\
+    __d1 = __ll_highpart (d);						\
+    __d0 = __ll_lowpart (d);						\
+									\
+    __q1 = __udivmodsi4 (n1,__d1,&__r0);				\
+    __m = (USItype) __q1 * __d0;					\
+    __r0 = __r0 * __ll_B | __ll_highpart (n0);				\
+    if (__r0 < __m)							\
+      {									\
+	__q1--, __r0 += (d);						\
+	if (__r0 >= (d)) /* i.e. we didn't get carry when adding to __r0 */\
+	  if (__r0 < __m)						\
+	    __q1--, __r0 += (d);					\
+      }									\
+    __r0 -= __m;							\
+									\
+    __q0 = __udivmodsi4 (__r0,__d1,&__r0);				\
+    __m = (USItype) __q0 * __d0;					\
+    __r0 = __r0 * __ll_B | __ll_lowpart (n0);				\
+    if (__r0 < __m)							\
+      {									\
+	__q0--, __r0 += (d);						\
+	if (__r0 >= (d))						\
+	  if (__r0 < __m)						\
+	    __q0--, __r0 += (d);					\
+      }									\
+    __r0 -= __m;							\
+									\
+    (q) = (USItype) __q1 * __ll_B | __q0;				\
+    (r) = __r0;								\
+  } while (0)
+#else
+/* Define this unconditionally, so it can be used for debugging.  */
 #define __udiv_qrnnd_c(q, r, n1, n0, d) \
   do {									\
     UWtype __d1, __d0, __q1, __q0;					\
@@ -1268,6 +1368,7 @@
     (q) = (UWtype) __q1 * __ll_B | __q0;				\
     (r) = __r0;								\
   } while (0)
+#endif
 
 /* If the processor has no udiv_qrnnd but sdiv_qrnnd, go through
    __udiv_w_sdiv (defined in libgcc or elsewhere).  */
--- a/gcc/loop.c
+++ b/gcc/loop.c
@@ -4703,7 +4703,8 @@
 	     this is an address giv, then try to put the increment
 	     immediately after its use, so that flow can create an
 	     auto-increment addressing mode.  */
-	  if (v->giv_type == DEST_ADDR && bl->biv_count == 1
+	  if ((HAVE_POST_INCREMENT || HAVE_POST_DECREMENT)
+              && v->giv_type == DEST_ADDR && bl->biv_count == 1
 	      && bl->biv->always_executed && ! bl->biv->maybe_multiple
 	      /* We don't handle reversed biv's because bl->biv->insn
 		 does not have a valid INSN_LUID.  */
@@ -8979,7 +8980,13 @@
 		    || (GET_CODE (v->add_val) == REG
 			&& REG_POINTER (v->add_val)))
 		&& ! v->ignore && ! v->maybe_dead && v->always_computable
-		&& v->mode == mode)
+		&& v->mode == mode
+                /* SCz: There is a possible overflow here.
+                   If we compare to a constant value, the constant is
+                   re-computed (CST * mult_add + add_val) and there may
+                   be an overflow. CST was 16399, mult was 8, and integers
+                   are 16-bits.   (execute/loop-3c.c, -Os -mshort).  */
+                && 0)
 	      {
 		if (! biv_elimination_giv_has_0_offset (bl->biv, v, insn))
 		  continue;
--- a/gcc/mkinstalldirs
+++ b/gcc/mkinstalldirs
@@ -4,7 +4,7 @@
 # Created: 1993-05-16
 # Public domain
 
-# $Id: mkinstalldirs,v 1.2 1999/09/04 15:08:55 law Exp $
+# $Id: mkinstalldirs,v 1.1 2012/05/02 15:45:12 jsmcortina Exp $
 
 errstatus=0
 
--- a/gcc/regrename.c
+++ b/gcc/regrename.c
@@ -102,6 +102,9 @@
   HARD_REG_SET *pset = (HARD_REG_SET *) data;
   unsigned int regno;
   int nregs;
+
+  if (GET_CODE (x) == SUBREG)
+    x = SUBREG_REG (x);
   if (GET_CODE (x) != REG)
     return;
   regno = REGNO (x);
@@ -292,6 +295,7 @@
 	  for (new_reg = 0; new_reg < FIRST_PSEUDO_REGISTER; new_reg++)
 	    {
 	      int nregs = HARD_REGNO_NREGS (new_reg, GET_MODE (*this->loc));
+              int mode = GET_MODE (*this->loc);
 
 	      for (i = nregs - 1; i >= 0; --i)
 	        if (TEST_HARD_REG_BIT (this_unavailable, new_reg + i)
@@ -307,7 +311,7 @@
 			&& !LEAF_REGISTERS[new_reg + i])
 #endif
 #ifdef HARD_REGNO_RENAME_OK
-		    || ! HARD_REGNO_RENAME_OK (reg + i, new_reg + i)
+		    || ! HARD_REGNO_RENAME_OK (reg + i, new_reg + i, mode)
 #endif
 		    )
 		  break;
--- a/gcc/reload.c
+++ b/gcc/reload.c
@@ -4216,6 +4216,20 @@
 
       if (goal_alternative_matches[rld[i].opnum] >= 0)
 	rld[i].opnum = goal_alternative_matches[rld[i].opnum];
+
+      /* If an operand's reload is RELOAD_OTHER, change any
+         RELOAD_FOR_OPERAND_ADDRESS and RELOAD_FOR_OUTPUT_ADDRESS reloads
+         of that operand to RELOAD_FOR_OTHER_ADDRESS.  This is necessary
+         to make sure the reloads are emitted in the good order.  We only need
+         to scan backward.  */
+      if (rld[i].when_needed == RELOAD_OTHER
+          && rld[i].optional == 0)
+        {
+          for (j = i - 1; j >= 0; j--)
+            if (rld[j].opnum == rld[i].opnum
+                && rld[j].when_needed == RELOAD_FOR_OPERAND_ADDRESS)
+              rld[j].when_needed = RELOAD_FOR_OTHER_ADDRESS;
+        }
     }
 
   /* Scan all the reloads, and check for RELOAD_FOR_OPERAND_ADDRESS reloads.
@@ -4556,10 +4570,8 @@
 	 force a reload in that case.  So we should not do anything here.  */
 
       else if (regno >= FIRST_PSEUDO_REGISTER
-#ifdef LOAD_EXTEND_OP
 	       && (GET_MODE_SIZE (GET_MODE (x))
 		   <= GET_MODE_SIZE (GET_MODE (SUBREG_REG (x))))
-#endif
 	       && (reg_equiv_address[regno] != 0
 		   || (reg_equiv_mem[regno] != 0
 		       && (! strict_memory_address_p (GET_MODE (x),
@@ -5913,7 +5925,7 @@
 		}
 
 	      find_reloads_address (GET_MODE (tem), &tem, XEXP (tem, 0),
-				    &XEXP (tem, 0), opnum, ADDR_TYPE (type),
+				    &XEXP (tem, 0), opnum, type,
 				    ind_levels, insn);
 
 	      /* If this is not a toplevel operand, find_reloads doesn't see
--- a/gcc/reload1.c
+++ b/gcc/reload1.c
@@ -1777,9 +1777,6 @@
   if (best_reg == -1)
     return 0;
 
-  if (rtl_dump_file)
-    fprintf (rtl_dump_file, "Using reg %d for reload %d\n", best_reg, rnum);
-
   rl->nregs = HARD_REGNO_NREGS (best_reg, rl->mode);
   rl->regno = best_reg;
 
@@ -1930,6 +1927,7 @@
     {
       error ("unable to find a register to spill in class `%s'",
 	     reg_class_names[class]);
+
       fatal_insn ("this is the insn:", insn);
     }
 }
@@ -3979,7 +3977,7 @@
 	     for this insn in order to be stored in
 	     (obeying register constraints).  That is correct; such reload
 	     registers ARE still valid.  */
-	  note_stores (oldpat, forget_old_reloads_1, NULL);
+         note_stores (oldpat, forget_old_reloads_1, NULL);
 
 	  /* There may have been CLOBBER insns placed after INSN.  So scan
 	     between INSN and NEXT and use them to forget old reloads.  */
@@ -4580,6 +4578,9 @@
     case RELOAD_OTHER:
       /* Since a RELOAD_OTHER reload claims the reg for the entire insn,
 	 its value must reach the end.  */
+      for (i = 0; i < reload_n_operands; i++)
+        if (TEST_HARD_REG_BIT (reload_reg_used_in_output[i], regno))
+          return 0;
       return 1;
 
       /* If this use is for part of the insn,
@@ -5298,6 +5299,13 @@
   CLEAR_HARD_REG_SET (reload_reg_used_in_insn);
   CLEAR_HARD_REG_SET (reload_reg_used_in_other_addr);
 
+#if 0 /* TARGET_M68HC11 or NO_SPILL_REG_ROUND_ROBIN */
+  /* Don't use the round-robin fashion for allocation of spill registers.
+     If we use round-robin, the reload pass allocates Y and Z registers
+     which are expensive compared to X and D.  */
+  last_spill_reg = -1;
+#endif
+
   CLEAR_HARD_REG_SET (reg_used_in_insn);
   {
     HARD_REG_SET tmp;
@@ -6037,6 +6045,29 @@
   reload_spill_index[r] = -1;
 }
 
+
+/* Returns true if merging reloads i and j should result in a
+   RELOAD_FOR_OTHER_ADDRESS reload, else false for RELOAD_OTHER.  */
+static int
+merge_becomes_other_address (int i, int j)
+{
+  int wn1 = rld[i].when_needed;
+  int wn2 = rld[j].when_needed;
+
+  if (wn2 == RELOAD_FOR_OTHER_ADDRESS)
+    wn2 = wn1;
+  else if (wn1 != RELOAD_FOR_OTHER_ADDRESS)
+    return 0;
+
+  return (wn2 == RELOAD_FOR_INPUT_ADDRESS
+	  || wn2 == RELOAD_FOR_INPADDR_ADDRESS
+	  || wn2 == RELOAD_FOR_OUTPUT_ADDRESS
+	  || wn2 == RELOAD_FOR_OUTADDR_ADDRESS
+	  || wn2 == RELOAD_FOR_OPERAND_ADDRESS
+	  || wn2 == RELOAD_FOR_OPADDR_ADDR
+	  || wn2 == RELOAD_FOR_OTHER_ADDRESS);
+}
+
 /* If SMALL_REGISTER_CLASSES is nonzero, we may not have merged two
    reloads of the same item for fear that we might not have enough reload
    registers. However, normally they will get the same reload register
@@ -6050,6 +6081,7 @@
    This will not increase the number of spill registers needed and will
    prevent redundant code.  */
 
+extern const char *const reload_when_needed_name[];
 static void
 merge_assigned_reloads (insn)
      rtx insn;
@@ -6114,6 +6146,7 @@
       if (j == n_reloads
 	  && max_input_address_opnum <= min_conflicting_input_opnum)
 	{
+          int changed = 0;
 	  for (j = 0; j < n_reloads; j++)
 	    if (i != j && rld[j].reg_rtx != 0
 		&& rtx_equal_p (rld[i].reg_rtx, rld[j].reg_rtx)
@@ -6121,12 +6154,22 @@
 		    || rld[j].when_needed == RELOAD_FOR_INPUT_ADDRESS
 		    || rld[j].when_needed == RELOAD_FOR_OTHER_ADDRESS))
 	      {
-		rld[i].when_needed = RELOAD_OTHER;
+ 		if (merge_becomes_other_address (i, j))
+ 		  rld[i].when_needed = RELOAD_FOR_OTHER_ADDRESS;
+ 		else
+ 		  rld[i].when_needed = RELOAD_OTHER;
 		rld[j].in = 0;
 		reload_spill_index[j] = -1;
 		transfer_replacements (i, j);
+                changed = 1;
 	      }
 
+ 	  /* If this is now RELOAD_OTHER or RELOAD_FOR_OTHER_ADDRESS,
+ 	     look for any reloads that load parts of this operand and
+ 	     set them to RELOAD_FOR_OTHER_ADDRESS if they were for
+ 	     inputs, RELOAD_OTHER for outputs.  Note that this test is
+ 	     equivalent to looking for reloads for this operand
+  	     number.  */
 	  /* If this is now RELOAD_OTHER, look for any reloads that load
 	     parts of this operand and set them to RELOAD_FOR_OTHER_ADDRESS
 	     if they were for inputs, RELOAD_OTHER for outputs.  Note that
@@ -6137,7 +6180,9 @@
 	     same value or a part of it; we must not change its type if there
 	     is a conflicting input.  */
 
-	  if (rld[i].when_needed == RELOAD_OTHER)
+ 	  if (changed
+              && (rld[i].when_needed == RELOAD_OTHER
+ 	          || rld[i].when_needed == RELOAD_FOR_OTHER_ADDRESS))
 	    for (j = 0; j < n_reloads; j++)
 	      if (rld[j].in != 0
 		  && rld[j].when_needed != RELOAD_OTHER
@@ -6152,7 +6197,8 @@
 
 		  rld[j].when_needed
 		    = ((rld[j].when_needed == RELOAD_FOR_INPUT_ADDRESS
-			|| rld[j].when_needed == RELOAD_FOR_INPADDR_ADDRESS)
+			|| rld[j].when_needed == RELOAD_FOR_INPADDR_ADDRESS
+                        || rld[j].when_needed == RELOAD_FOR_OPADDR_ADDR)
 		       ? RELOAD_FOR_OTHER_ADDRESS : RELOAD_OTHER);
 
 		  /* Check to see if we accidentally converted two reloads
@@ -6164,8 +6210,13 @@
 		      if (rld[k].in != 0 && rld[k].reg_rtx != 0
 			  && rld[k].when_needed == rld[j].when_needed
 			  && rtx_equal_p (rld[k].reg_rtx, rld[j].reg_rtx)
-			  && ! rtx_equal_p (rld[k].in, rld[j].in))
+			  && ! rtx_equal_p (rld[k].in, rld[j].in)) {
+                        printf("Changed reload %d, conflict %d with %d\n",
+                               i, k, j);
+
 			abort ();
+                      }
+
 		}
 	}
     }
@@ -7306,6 +7357,13 @@
 					      rld[r].when_needed))
 		  CLEAR_HARD_REG_BIT (reg_reloaded_valid, i + k);
 	    }
+          else
+            {
+              /* When the reload does not reach the end, we must
+                 invalidate the old info.  */
+              for (k = 0; k < nr; k++)
+                CLEAR_HARD_REG_BIT (reg_reloaded_valid, i + k);
+            }
 	}
 
       /* The following if-statement was #if 0'd in 1.34 (or before...).
--- /dev/null
+++ b/gcc/testsuite/ChangeLog.M68HC11
@@ -0,0 +1,111 @@
+2006-01-20  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* gcc.c-torture/execute-scz/pr-15493.c (struct): New test for
+	savannah/15493
+
+2005-11-05  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* gcc.c-torture/execute-scz/pr-13917.c: New test for savannah/13917.
+	* gcc.c-torture/execute-scz/b-20051105.c: New test.
+
+2005-05-08  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* gcc.c-torture/compile-scz/pr-12572.c: Test case for savannah/12572.
+
+2005-04-03  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* gcc.c-torture/execute-scz/pr-12297.c: Test case for savannah/12297.
+	* gcc.c-torture/execute-scz/pr-12243.c: New test for savannah/12243.
+	* gcc.c-torture/compile-scz/b-2005-02-14.c: New test.
+
+2005-02-13  Stephane Carrez  <stcarrez@nerim.fr>
+
+	PR target/16925
+	* gcc.c-torture/compile-scz/pr-16925.c: New test.
+
+	PR target/14629
+	* gcc.c-torture/compile-scz/pr-14629.cc: New test.
+
+2005-02-12  Stephane Carrez  <stcarrez@nerim.fr>
+
+	PR savannah/11903
+	* gcc.c-torture/compile-scz/pr-11903.c: New test.
+
+2005-01-30  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* gcc.c-torture/execute-scz/pr-11741.c (strncpy): New test
+	for savannah/11741
+
+2004-08-29  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* gcc.c-torture/execute-scz/b-20040816.c: New file for
+	bug savannah/10207.
+
+2003-10-01  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* gcc.dg/20020219-1.c: Compile with -mshort to make sure integers
+	are 16-bit (test disabled as it defines a huge array).
+	* gcc.dg/20020426-2.c: Likewise.
+	* gcc.dg/20020430-1.c: Likewise.
+	* gcc.dg/20021018-1.c: Likewise.
+	* gcc.dg/20021029-1.c: Likewise.
+	* gcc.dg/20021023-1.c: -fpic is not supported on m6811/m6812.
+
+2003-09-30  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* gcc.c-torture/compile/simd-5.x: Don't execute for 68HC11 because
+	it fails with 16-bit int.
+
+2003-08-02  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* gcc.c-torture/execute-scz/execute.exp: New testsuite for 68hc11/hc12.
+	andqi.c, b-20020520.c, bitfield.c, malloc.c, negqi.c,
+	autoinc.c, bigmul.c, bset.c, memset-2003-01-25.c, orqi.c,
+	b-20010414.c, bit.c, mul-1.c, setjmp-test.c: New test for compilation
+	and execution.
+
+	* gcc.c-torture/compile-scz/compile.exp: New testsuite for 68hc11/hc12.
+	add_opt.c, b-20010920.c, b-20030518.c, di.c, orext.c, push.c,
+	string.c, addshift.c, b-20011203.c, b-20030519.c, foo.c, pr-1416.c,
+	ret64.c, tst-asm.c, alloca.c, b-20020203.c, b-2003-07-04.c,
+	fprintf.c, pr-6698.c, rotate.c, vsprintf.c, ashr.c, b-20020206.c,
+	b-2003-07-30.c, gcc-bug.c, pr-6744.c, sex.c, b-20000411.c,
+	b-20020403.c, bclr.c, interrupt.c, pr-7223.c, sext.c,
+	b-20001206.c, b-20020610.c, lshr.c, pr-7361.c,
+	shift-1.c, b-20010424.c, b-20021015.c, cp.c, min.c, printf.c
+	shl.c: New tests for compilation only.
+
+2003-07-20  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* gcc.c-torture/execute/ieee/920810-1.x: New file, don't execute on
+	68HC11/HC12 because sprintf does not support floats.
+
+2003-07-20  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* gcc.c-torture/execute/shiftdi.x: New file, don't execute this
+	test on 68HC11/HC12 as it relies on 32-bit ints.
+	* gcc.c-torture/execute/20021024-1.x: New file, likewise.
+
+2003-05-18  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* gcc.c-torture/execute/20020404-1.x: New file, don't run this
+	test on 68HC11/68HC12.
+
+2003-05-18  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* gcc.dg/20001009-1.c: -fpic is not supported on m6811-* and m6812-*
+	* gcc.dg/inline-2.c: Likewise.
+	* gcc.dg/20030225-1.c: Likewise.
+	* gcc.dg/20010912-1.c: Likewise.
+	* gcc.dg/20020122-4.c: Likewise.
+	* gcc.dg/20020415-1.c: Likewise.
+	* gcc.dg/20021116-1.c: Likewise.
+	* gcc.dg/20030213-1.c: Likewise.
+	* gcc.dg/20030120-1.c: Likewise.
+	* gcc.misc-tests/bprob.exp: Don't run on m6811-* and m6812-* since
+	the __bb_init_func are not available.
+
+2003-05-18  Stephane Carrez  <stcarrez@nerim.fr>
+
+	* testsuite/gcc.c-torture/compile/20010327-1.x: New file, don't
+	run this test on m6811/m6812 as it assumes pointers are 32-bits.
--- a/gcc/testsuite/g++.dg/bprob/bprob.exp
+++ b/gcc/testsuite/g++.dg/bprob/bprob.exp
@@ -1,4 +1,4 @@
-#   Copyright (C) 2001, 2002 Free Software Foundation, Inc.
+#   Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.
 
 # This program is free software; you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
@@ -20,7 +20,9 @@
 # Some targets don't have any implementation of __bb_init_func or are
 # missing other needed machinery.
 if { [istarget mmix-*-*]
-     || [istarget cris-*-*] } {
+     || [istarget cris-*-*]
+     || [istarget m6811-*-*]
+     || [istarget m6812-*-*] } {
     return
 }
 
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile-scz/add_opt.c
@@ -0,0 +1,17 @@
+unsigned long addsi_and16(unsigned long a, unsigned long b)
+{
+  return a + (b & 0x0ffff);
+}
+
+unsigned long addsi_zext(unsigned long* a, unsigned long* b)
+{
+  *a = *a + (*b & 0x0ffff);
+  return *a;
+}
+
+unsigned long addsi_shift(unsigned long* a, unsigned long* b)
+{
+  *a = *a + (*b << 16);
+  return *a;
+}
+
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile-scz/addshift.c
@@ -0,0 +1,6 @@
+unsigned long addsi_shift(unsigned long* a, unsigned long* b)
+{
+  *a = (*b << 16) + *a;
+  return *a;
+}
+
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile-scz/alloca.c
@@ -0,0 +1,7 @@
+extern __attribute__((noreturn)) void bar(char*, int);
+
+void get(int size, char c)
+{
+  char *buf[size];
+  bar (buf, size);
+}
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile-scz/ashr.c
@@ -0,0 +1,5 @@
+long ashr(long a, short b)
+{
+  a = a >> b;
+  return a;
+}
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile-scz/b-20000411.c
@@ -0,0 +1,51 @@
+#include <string.h>
+
+typedef unsigned char byte;
+
+// Data structure for queues.
+typedef struct {
+  byte start;
+  byte end;
+  byte count;
+  byte* data;
+  byte length;
+} queueType;
+
+// Add a value to the end of a queue.
+void Enqueue (queueType* queue, void *value, byte size)
+{
+  // Working variables.
+  byte counter;
+  //  byte increment = 1;
+
+  // Save each byte of the given value at start.
+  for (counter = 0; counter < size; counter++) {
+    // Save byte of value.
+    *(queue->data + queue->start) = *(byte*)(value++);
+
+    // Increment start pointer (with wrap around).
+    queue->start = (queue->start + 1) % queue->length;
+
+    // Push the end forward as necessary (with wrap around). 
+    //if (queue->start == queue->end) {
+    //queue->end = (queue->end + 1) % queue->length;
+    //  increment = 0;
+    //}
+  }
+
+  // Increment element count if there was no shifting of the end pointer.
+  //  if (increment) queue->count++;
+}
+
+
+int main()
+{
+  byte input = 0x10;
+
+  static queueType queue;
+  static byte buffer[5];
+  queue.start = queue.end = queue.count = 0;
+  queue.data = buffer;
+  queue.length = 5;
+  Enqueue(&queue,&input,sizeof(input));
+}
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile-scz/b-20001206.c
@@ -0,0 +1 @@
+char *a[] = {"abcd", "defg"};
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile-scz/b-20010424.c
@@ -0,0 +1,46 @@
+typedef char byte;
+extern int strlen(char*);
+extern void LcdWriteChar(byte,byte,byte,byte);
+extern void os_disable();
+enum align {
+  LCD_ALIGN_LEFT,
+  LCD_ALIGN_CENTER,
+  LCD_ALIGN_RIGHT
+};
+
+void LcdWriteString(
+    byte page_no, byte x, byte y, char *str, byte align
+) {
+
+char *ptr;
+
+ os_disable ();
+    switch( align ) {
+    case LCD_ALIGN_LEFT:
+        break;
+    case LCD_ALIGN_CENTER:
+        x -= strlen( str ) >> 1; break;
+    case LCD_ALIGN_RIGHT:
+        x -= strlen( str ); break;
+    }
+    for( ptr = str; *ptr != 0; ptr++ ) {
+        LcdWriteChar( page_no, x, y, *ptr );
+        x++;
+    }
+}
+
+void
+os_disable()
+{
+  ;
+}
+int main()
+{
+  LcdWriteString(1,2,3,"Hello",LCD_ALIGN_CENTER);
+  return 0;
+}
+void
+LcdWriteChar(byte p, byte x, byte y, byte c)
+{
+  ;
+}
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile-scz/b-20010920.c
@@ -0,0 +1,14 @@
+unsigned int segwerte[9];
+void me_Measure_seg();
+void ser_putword( unsigned int data );
+
+void command_messen(void)
+{
+ // volatile int i;
+ int i;
+ me_Measure_seg();
+ for(i=0;i<9;i++)
+  {
+   ser_putword(segwerte[i]);
+  }
+}
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile-scz/b-20011203.c
@@ -0,0 +1,4 @@
+char IsWChanged(char c) {
+  char c1 = c * 10 + 60;
+  return c1;
+}
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile-scz/b-20020203.c
@@ -0,0 +1,4 @@
+unsigned long add_shift(unsigned long a, unsigned long b)
+{
+  return ((a >> 16) + b);
+}
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile-scz/b-20020206.c
@@ -0,0 +1,13 @@
+volatile char _io_ports[10];
+char bar;
+
+int get ()
+{
+  while (_io_ports[3] & 0x80)
+    continue;
+
+  if (bar & 0x80)
+    return _io_ports[1];
+
+  return _io_ports[2];
+}
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile-scz/b-20020403.c
@@ -0,0 +1,6 @@
+void foo(char* addr, char* data)
+{
+    *((volatile char*)0x0) |= 0x1;
+    *addr++ = *data++;
+    *((volatile char*)0x0) |= 0x1;
+}
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile-scz/b-20020610.c
@@ -0,0 +1,8 @@
+int check(char *p)
+{
+  *p = 'a';
+  if (*p == 'a')
+    return *p;
+
+  return 0;
+}
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile-scz/b-20021015.c
@@ -0,0 +1,22 @@
+int main (void);
+void Call1 (void);
+unsigned char Var1         __attribute__ ((section (".page0")));
+
+void _start (void)
+{
+ main();
+}
+
+int main (void)
+{
+ if (!Var1)
+ {
+  Call1();
+ }
+ Var1 |= 1;
+return (0);
+}
+
+void Call1 (void)
+{
+}
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile-scz/b-2003-07-04.c
@@ -0,0 +1,12 @@
+typedef unsigned long __u32;
+typedef unsigned short __u16;
+__u16 tcp_chksum;
+void a(void)
+{
+
+     __u32 checksum;
+     checksum += checksum >> 16;
+     tcp_chksum = ~checksum;
+}
+
+
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile-scz/b-2003-07-30.c
@@ -0,0 +1,15 @@
+struct a
+{
+  int a;
+  int b;
+  char bar[253];
+  long d;
+  int c[3];
+};
+
+struct a table[10];
+
+int get(int p)
+{
+  return table[p].c[2];
+}
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile-scz/b-20030518.c
@@ -0,0 +1,16 @@
+extern volatile unsigned char _io_ports[];
+
+int main(void)
+{
+    unsigned short x;
+    int i = 0;
+
+    x = (_io_ports[0x00] << 8) | _io_ports[0x00];
+
+    if (x >> i)
+    {
+        _io_ports[0x00] = 0;
+    }
+
+    return 0;
+}
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile-scz/b-20030519.c
@@ -0,0 +1,19 @@
+/*
+ *  compile with:
+ * m6811-elf-gcc -mshort -O -fomit-frame-pointer -S test.c
+ *
+ * Then notice that the generated code references the frame pointer,
+ * even though we have told the compiler not to use it. The code is
+ * correct if optimization is disabled.
+ * */
+
+void __attribute__((interrupt)) do_something(char *p1, char *p2);
+
+void __attribute__((interrupt)) something(char *p1)
+{
+   char p2;
+   char* p2p = &p2;
+   do_something(p1, p2p);
+}
+
+
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile-scz/b-2005-02-14.c
@@ -0,0 +1,16 @@
+unsigned int x;
+int main(void);
+int main()
+{
+
+      while(1)
+     {
+
+	      for (x=1; x<=60000;x++); // Delay loop
+	      for (x=1; x<=60000;x++); // Delay loop
+     }
+
+      return 0;
+}
+
+
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile-scz/bclr.c
@@ -0,0 +1,13 @@
+#define bclr(m, o, b) \
+    __asm __volatile("bclr %i1,%0 %2" : : "x" (m), "n" (o), "n" (b))
+
+extern volatile unsigned char _io_ports[];
+extern unsigned short toto;
+
+void set(char* p)
+{
+  bclr(_io_ports, 0x30, 0x20);
+  _io_ports[0x30] |= 0x20;
+  p[2] |= 1;
+  toto |= 4;
+}
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile-scz/compile.exp
@@ -0,0 +1,35 @@
+# Expect driver script for GCC Regression Tests
+# Copyright (C) 1993, 1995, 1997 Free Software Foundation
+#
+# This file is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+
+# These tests come from Torbjorn Granlund's (tege@cygnus.com)
+# C torture test suite, and other contributors.
+
+if $tracelevel then {
+    strace $tracelevel
+}
+
+# load support procs
+load_lib c-torture.exp
+
+foreach testcase [glob -nocomplain $srcdir/$subdir/*.c] {
+    # If we're only testing specific files and this isn't one of them, skip it.
+    if ![runtest_file_p $runtests $testcase] then {
+	continue
+    }
+
+    c-torture $testcase
+}
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile-scz/cp.c
@@ -0,0 +1,6 @@
+#include <stddef.h>
+
+void copy(short *s, short *q, size_t l)
+{
+  while (--l > 0) *s++ = *q++;
+}
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile-scz/di.c
@@ -0,0 +1,5 @@
+long long shl(long long a)
+{
+  return a << 1;
+}
+
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile-scz/foo.c
@@ -0,0 +1,4 @@
+int __attribute__((section("init")))  main()
+{
+  return 0;
+}
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile-scz/fprintf.c
@@ -0,0 +1,28 @@
+/*
+ * Simple replacement of fprintf() for use by GCC testsuite.
+ */
+#include <stdarg.h>
+#include <stddef.h>
+
+typedef struct _file {
+  long a;
+} FILE;
+
+extern int vsprintf(char*, const char*, ...);
+extern int write(int, const char*, size_t);
+
+int
+fprintf(FILE* fp, const char* fmt, ...)
+{
+  char buf[256];
+  va_list args;
+  int i;
+
+  va_start(args, fmt);
+  i=vsprintf(buf,fmt,args);
+  va_end(args);
+
+  write(0, buf, i);
+  return i;
+}
+
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile-scz/gcc-bug.c
@@ -0,0 +1,87 @@
+/*
+command that triggered the bug:
+$ m68hc12-elf-gcc -O3 -c -I./src -I./sys-inc -fno-builtin  src/hc12_eeprom.c -o obj/hc12_eeprom.o
+src/hc12_eeprom.c: In function `write_eeprom':
+src/hc12_eeprom.c:44: Insn does not satisfy its constraints:
+(insn 32 30 128 (set (mem:QI (const_int 243 [0xf3]) 0)
+        (ior:QI (mem:QI (const_int 243 [0xf3]) 0)
+            (const_int 22 [0x16]))) 83 {*iorqi3_const} (insn_list 25 (nil))
+    (nil))
+src/hc12_eeprom.c:44: Internal compiler error in reload_cse_simplify_operands, at reload1.c:8387
+Please submit a full bug report,
+with preprocessed source if appropriate.
+See <URL:http://www.gnu.org/software/gcc/bugs.html> for instructions.
+make: *** [obj/hc12_eeprom.o] Error 1
+*/
+# 7 "src/hc12_eeprom.c"
+# 1 "src/hc912bc32.h" 1
+# 8 "src/hc12_eeprom.c" 2
+# 1 "src/hc12_util.h" 1
+# 12 "src/hc12_util.h"
+enum true_false { false=0, true};
+# 22 "src/hc12_util.h"
+typedef char bool;
+typedef char boolean;
+typedef unsigned char byte;
+typedef unsigned int uint;
+typedef unsigned long ulong;
+
+typedef const unsigned char* pcbyte;
+typedef const unsigned short* pcword;
+# 40 "src/hc12_util.h"
+void wait_1msec(void);
+void wait_10msec(void);
+void sleep(unsigned long);
+char bitNr(char);
+
+void initMain(void);
+void restartMain(void);
+
+void InitLock(char*);
+bool SetLock(char*);
+void ResetLock(char*);
+void WaitLock(char*);
+
+void BootLoaderDownload(void);
+void BootLoad(void);
+void Reboot(void);
+void Coldstart(void);
+char IsInterrupt(void);
+
+boolean isMenu(void);
+# 9 "src/hc12_eeprom.c" 2
+
+
+
+# 1 "src/hc12_eeprom.h" 1
+# 41 "src/hc12_eeprom.h"
+void write_eeprom(unsigned char*,unsigned char);
+# 13 "src/hc12_eeprom.c" 2
+
+
+
+void write_eeprom
+   (unsigned char* pPointer,
+    unsigned char bByte)
+{
+    if (*pPointer!=bByte)
+    {
+
+        (* (unsigned char *) (0x0000 + 0xF1))=0x00;
+        (* (unsigned char *) (0x0000 + 0xF3))|=0x02|0x04|0x10;
+        *pPointer=bByte;
+        (* (unsigned char *) (0x0000 + 0xF3))|=0x01;
+        wait_10msec();
+        (* (unsigned char *) (0x0000 + 0xF3))&=~(0x01);
+
+
+
+        (* (unsigned char *) (0x0000 + 0xF3))&=~(0x04|0x10);
+        *pPointer=bByte;
+        (* (unsigned char *) (0x0000 + 0xF3))|=0x01;
+        wait_10msec();
+        (* (unsigned char *) (0x0000 + 0xF3))&=~(0x01);
+        (* (unsigned char *) (0x0000 + 0xF3))&=~(0x02);
+        (* (unsigned char *) (0x0000 + 0xF1))=0xFF;
+    }
+}
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile-scz/interrupt.c
@@ -0,0 +1,19 @@
+extern char clock_flags;
+extern char time_secs;
+extern char min_flag;
+
+#define REG_BASE 0
+#define REGISTER char
+#define PORTA           (*(volatile REGISTER *)(REG_BASE + 0x00))
+#define SHUTDOWN  0x40
+#define TIMING  0x01
+void __attribute__((interrupt))
+clock_interrupt_handler()
+{
+        PORTA &= ~SHUTDOWN;     /* power everything up*/
+        clock_flags |= TIMING;
+        if(time_secs != 0)
+                return;
+        min_flag = 1;           /* 1 minute flag for main.c*/
+}
+
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile-scz/lshr.c
@@ -0,0 +1,8 @@
+unsigned long global;
+
+unsigned long ashr(unsigned long a, short b)
+{
+  a = a >> b;
+  global = a >> 1;
+  return a;
+}
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile-scz/min.c
@@ -0,0 +1,39 @@
+unsigned short uminhi(unsigned short a, unsigned short b)
+{
+  a = (a < b) ? a : b;
+  return a;
+}
+
+unsigned short umaxhi(unsigned short a, unsigned short b)
+{
+  a = (a > b) ? a : b;
+  return a;
+}
+
+unsigned char e;
+
+void
+umaxqi(unsigned char a)
+{
+  e = (a > e) ? e : a;
+}
+
+unsigned char
+umaxqi2(unsigned char a)
+{
+  a = (a > e) ? e : a;
+  return a;
+}
+
+void
+uminqi(unsigned char a)
+{
+  e = (a < e) ? e : a;
+}
+
+unsigned char
+uminqi2(unsigned char a)
+{
+  a = (a < e) ? e : a;
+  return a;
+}
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile-scz/orext.c
@@ -0,0 +1,16 @@
+unsigned long b;
+unsigned char c;
+unsigned char d;
+
+unsigned short get()
+{
+  return (c << 8) | d;
+}
+
+unsigned long orext(unsigned long a)
+{
+  a = (b >> 16) | a;
+  a = a | c;
+  a = a | (unsigned long) ((d | (c << 8)));
+  return a;
+}
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile-scz/pr-11813.c
@@ -0,0 +1,20 @@
+struct Regs
+{
+volatile unsigned char reg;
+};
+
+struct Device
+{
+struct Regs *regs;
+};
+
+struct Device dev0 =
+{
+(struct Regs *) 0x0100,
+};
+
+void init(struct Device *device)
+{
+device->regs->reg |= 0x01;
+device->regs->reg &= ~0x01;
+}
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile-scz/pr-12572.c
@@ -0,0 +1,14 @@
+int main()
+{
+
+   unsigned short x;
+
+   for (x=1; x<=0x8000; x++)
+     {
+
+	asm volatile ("nop");
+     }
+
+
+   return 0;
+}
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile-scz/pr-1416.c
@@ -0,0 +1,8 @@
+
+#define MIN(x1,x2) (x1 > x2)?x1:x2
+typedef unsigned short WORD;
+
+WORD wT;
+WORD TstMin(void) {
+  return MIN(wT, 99);
+}
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile-scz/pr-14629.cc
@@ -0,0 +1,47 @@
+extern void Hex2Ascii(unsigned char,unsigned char*);
+extern void cputch(char);
+class CFrame {
+ protected:
+  unsigned char *m_rxBuf;
+  unsigned int m_frameLen;
+  unsigned char OnRxChar(unsigned char __c);
+ private:
+  unsigned int m_rxCnt;
+  unsigned char m_state;
+};
+
+unsigned char
+CFrame::OnRxChar(unsigned char c)
+{
+  switch (m_state)
+    {
+    case 0:
+      m_rxCnt = 0;
+      m_state = 1;
+
+    case 1:
+      if (c == 0x5a)
+        {
+          ++m_rxCnt;
+          if (m_rxCnt == 2)
+            m_state = 2;
+        }
+      else
+        {
+          char buf[2];
+          Hex2Ascii(c, (unsigned char*)buf);
+          cputch(buf[0]);
+          cputch(buf[1]);
+          m_rxCnt = 0;
+        }
+      break;
+
+    case 2:
+      m_rxBuf[m_rxCnt++] = c;
+      if (m_rxCnt == (unsigned int) 7)
+        m_frameLen = *(unsigned short*)(&m_rxBuf[4]);
+      break;
+    }
+
+  return 0;
+}
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile-scz/pr-16925.c
@@ -0,0 +1,9 @@
+/* PR target/16925: ICE on 64-bit host architectures */
+typedef unsigned int UDItype __attribute__ ((mode (DI)));
+
+void ICE_on_64bit_archs (void)
+{
+  UDItype a;
+  a |= 0x8000000000000LL;
+}
+
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile-scz/pr-17551.c
@@ -0,0 +1,14 @@
+int calc (void)
+  {
+    int  mask_size;
+    int i,j,x;
+
+  for(i=-mask_size; i<=mask_size; i++)
+    for(j=-mask_size; j<=mask_size; j++)
+    {
+      x = (i*i)+(j*j);
+    }
+
+  return x;
+}
+
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile-scz/pr-6698.c
@@ -0,0 +1,57 @@
+/*  scanner.c */
+/*  J. Tritthardt, MPIMF/BMO */
+/*  Version 1.0 - 28.02.2002 */
+
+/*  Testprogramm fuer die LEDs der Scanner-Box */
+
+#define COPCTL *(volatile unsigned char *)(0x16)
+
+#define IO_BASE 0
+#define PORTT *((volatile unsigned char *)(IO_BASE + 0xAE))
+#define DDRT *((volatile unsigned char *)(IO_BASE + 0xAF))
+
+#define led_red 0x02
+#define led_red_port PORTT
+#define led_red_ddr DDRT
+#define led_green 0x08
+#define led_green_port PORTT
+#define led_green_ddr DDRT
+
+void delay();
+
+int main()
+{
+  led_red_port = led_red_port | led_red;
+  led_red_ddr = led_red_ddr | led_red;
+  led_green_port = led_green_port | led_green;
+  led_green_ddr = led_green_ddr | led_green;
+
+  while (1) {
+    led_red_port = led_red_port | led_red;
+    led_green_port = led_green_port & ~led_green;
+
+    delay();
+
+    led_green_port = led_green_port | led_green;
+    led_red_port = led_red_port & ~led_red;
+
+    delay();
+  }
+
+  return 0;
+}
+
+void __premain()
+{
+    __asm__ __volatile__ ("clr 0x16");
+}
+
+void delay()
+{
+#ifdef mc6812
+  __asm__ __volatile__ ("PSHD\n\tLDD	0xFFFF\n\tDBNE	D,-3\n\tPULD\n\tRTS");
+#endif
+#ifdef mc6811
+  __asm__ __volatile__ ("PSHA\n\tLDD	0xFFFF\n\tPULA\n\tRTS");
+#endif
+}
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile-scz/pr-6744.c
@@ -0,0 +1,1671 @@
+# 1 "eeprom.c"
+#define ASM 0
+
+
+
+
+
+
+
+# 1 "eeprom.h" 1
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+# 1 "/usr/lib/gcc-lib/m6811-elf/2.95.3/include/stdbool.h" 1 3
+
+
+
+
+
+
+typedef enum
+  {
+    false = 0,
+    true = 1
+  } bool;
+
+
+
+
+
+
+
+
+
+# 16 "eeprom.h" 2
+
+# 1 "../../include/sys/hwreg.h" 1
+
+
+
+
+
+
+
+
+
+# 1 "../../include/asm-m68hc12/hwreg.h" 1
+
+
+
+
+
+
+
+
+
+
+
+
+# 1 "../../include/asm-m68hc12/param.h" 1
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+# 13 "../../include/asm-m68hc12/hwreg.h" 2
+
+# 1 "../../include/asm-m68hc12/hwregaddr.h" 1
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+# 14 "../../include/asm-m68hc12/hwreg.h" 2
+
+
+typedef unsigned char byte;
+typedef unsigned short word;
+
+
+extern volatile byte _io_ports[];
+extern volatile byte *io_ports;
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+static inline void
+relocate_reg(word base)
+{
+  _io_ports[0x11 ] = (base/0x100) & 0xF8;
+  io_ports = (byte*) base;
+}
+
+
+
+
+static inline void
+set_bus_expanded(void)
+{
+  *((volatile word*) &_io_ports[( 0x0A  )])  = (word)((byte)(1<<7) | (1<<2) )*0x100 + ((1<<5) | (1<<4) ) ;
+  _io_ports[( 0x13  )]  = 0x7F;
+}
+
+
+
+
+
+static inline void
+set_bus_expanded_wide(void)
+{
+  *((volatile word*) &_io_ports[( 0x0A  )])  = (word)((byte)(1<<7) | (1<<2) )*0x100 + ((1<<6) | (1<<5) | (1<<4) ) ;
+  _io_ports[( 0x13  )]  = 0x7F;
+}
+
+
+static inline void
+set_bus_single_chip(void)
+{
+  _io_ports[( 0x0B  )]  = (byte)(1<<7) | (1<<4) ;
+}
+
+
+
+
+static inline void
+rti_init(byte scale)
+{
+  _io_ports[( 0x14  )]  = (1<<5)  | (scale & (0x7) );
+}
+
+
+static inline byte
+rti_getFlg(void)
+{
+  return _io_ports[( 0x15  )] ;
+}
+
+
+static inline void
+rti_clearFlg(void)
+{
+  _io_ports[( 0x15  )]  = 0x80 ;
+}
+
+
+static inline void
+cop_disable(void)
+{
+#if ASM
+  asm("bclr %0,%1" : : "R"( _io_ports[( 0x16  )]  ), "i"(  (0x7)  )) ;
+#endif
+}
+
+
+static inline void
+cop_force_reset(void)
+{
+  _io_ports[( 0x17  )]  = 0x55;
+  _io_ports[( 0x17  )]  = 0xAA;
+}
+
+
+
+static inline void
+cop_reset(void)
+{
+
+  cop_force_reset();
+
+}
+
+
+static inline void
+cop_init(void)
+{
+  cop_force_reset();
+  _io_ports[( 0x16  )]  = (1<<3)  | 2 ;
+}
+
+
+
+
+
+
+# 10 "../../include/sys/hwreg.h" 2
+
+
+
+
+
+
+
+# 17 "eeprom.h" 2
+
+
+# 1 "/usr/lib/gcc-lib/m6811-elf/2.95.3/include/stddef.h" 1 3
+
+
+
+
+
+
+
+
+
+# 19 "/usr/lib/gcc-lib/m6811-elf/2.95.3/include/stddef.h" 3
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+# 61 "/usr/lib/gcc-lib/m6811-elf/2.95.3/include/stddef.h" 3
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+# 131 "/usr/lib/gcc-lib/m6811-elf/2.95.3/include/stddef.h" 3
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+typedef short unsigned int size_t;
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+# 271 "/usr/lib/gcc-lib/m6811-elf/2.95.3/include/stddef.h" 3
+
+
+# 283 "/usr/lib/gcc-lib/m6811-elf/2.95.3/include/stddef.h" 3
+
+
+
+
+
+
+# 317 "/usr/lib/gcc-lib/m6811-elf/2.95.3/include/stddef.h" 3
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+# 19 "eeprom.h" 2
+
+
+
+
+
+bool eeprom_isWriting (void);
+
+
+
+int eeprom_prepareRead (word offset);
+
+
+
+
+int eeprom_readByte (word offset);
+
+
+
+
+word eeprom_readWord (word offset);
+
+
+void eeprom_chkWrite (void);
+
+
+
+int eeprom_writeByte (word offset, byte data);
+
+
+
+
+int eeprom_writeWord (word offset, word data);
+
+
+
+
+
+
+# 9 "eeprom.c" 2
+
+# 1 "../../include/timer.h" 1
+
+
+
+
+
+
+
+
+
+
+
+
+
+# 1 "../../include/sys/timer.h" 1
+
+
+
+
+
+
+
+
+
+
+# 1 "../../include/asm-m68hc12/timer.h" 1
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+  static inline void
+  timer_init(void)
+  {
+    _io_ports[( 0x8D  )]  = (byte)(1<<5)  | 3 ;
+
+    _io_ports[( 0x86  )]   = (byte)(1<<7)  | (byte)(1<<5)  | (byte)(1<<4) ;
+  }
+
+
+
+  static inline short
+  get_hwtime(void)
+  {
+    return *((volatile word*) &_io_ports[( 0x84  )]) ;
+  }
+
+
+
+  static inline byte
+  get_tof_flg(void)
+  {
+    return (_io_ports[( 0x8F  )]  & (byte)(1<<7) );
+  }
+
+
+  static inline void
+  tc_set_outputcompare(byte n)
+  {
+    _io_ports[( 0x80  )]  |= 1<<n;
+  }
+
+
+  static inline void
+  tc_set_inputcapture(byte n)
+  {
+    _io_ports[( 0x80  )]  &= (byte)~(1<<n);
+  }
+
+
+  static inline void
+  tc_interrupt_enable(byte n)
+  {
+    _io_ports[( 0x8C  )]  |= (byte)(1<<n);
+  }
+
+
+  static inline void
+  tc_interrupt_disable(byte n)
+  {
+    _io_ports[( 0x8C  )]  &= (byte)~(1<<n);
+  }
+
+
+
+  static inline byte
+  tc_get_flg(byte n)
+  {
+    return (_io_ports[( 0x8E  )]  & (byte)(1<<n));
+  }
+
+
+
+  static inline word
+  tc_get_value(byte n)
+  {
+    return ((volatile word*) &_io_ports[( 0x90  )]) [n];
+  }
+
+
+
+  static inline void
+  tc_set_value(byte n, word val)
+  {
+    ((volatile word*) &_io_ports[( 0x90  )]) [n] = val;
+  }
+
+
+
+
+  static inline void
+  tc_add_microseconds(byte n, unsigned long t)
+  {
+    tc_set_value(n, tc_get_value(n) + (word)((8000000   / (1<< 3 ))   * t/1000000));
+  }
+
+
+
+
+  static inline void
+  tc_set_tocmode(byte n, byte mode)
+  {
+    word d = *((volatile word*) &_io_ports[( 0x88  )]) ;
+    n *= 2;
+    d &= ~(0x3 << n);
+    d |= mode << n;
+
+    *((volatile word*) &_io_ports[( 0x88  )])  = d;
+  }
+
+
+
+
+  static inline void
+  tc_toggle_tocmode(byte n)
+  {
+    *((volatile word*) &_io_ports[( 0x88  )])  ^= (word)(1<<(n*2));
+  }
+
+
+
+
+  static inline void
+  tc_set_ticmode(byte n, byte mode)
+  {
+    word d = *((volatile word*) &_io_ports[( 0x8A  )]) ;
+    n *= 2;
+    d &= ~(0x3 << n);
+    d |= mode << n;
+
+    *((volatile word*) &_io_ports[( 0x8A  )])  = d;
+  }
+
+
+
+
+
+
+# 11 "../../include/sys/timer.h" 2
+
+
+
+
+
+
+# 14 "../../include/timer.h" 2
+
+# 1 "../../include/sys/locks.h" 1
+
+
+
+
+
+
+
+
+
+
+# 1 "../../include/asm-m68hc12/locks.h" 1
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+static inline short
+lock(void)
+{
+  short ccsav;
+  asm volatile ("tpa\nsei": "=d"(ccsav):: "cc");
+  return ccsav;
+}
+
+
+
+static inline void
+unlock(void)
+{
+  asm volatile ("cli"::: "cc");
+}
+
+
+
+static inline void
+restorelock(short ccsav)
+{
+  asm volatile ("tap":: "d"(ccsav): "cc");
+}
+
+
+
+
+
+
+# 11 "../../include/sys/locks.h" 2
+
+
+
+
+
+
+# 15 "../../include/timer.h" 2
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+  extern volatile unsigned TofCnt;
+  extern volatile unsigned MillisecCnt;
+  extern volatile byte TimerFlgs;
+
+
+
+  extern void timer_init_tof (void);
+
+
+
+  extern signed char reserveTimerNum (byte n);
+
+
+
+  extern signed char reserveTimerNumOnly (byte n);
+  extern void freeTimerNum (byte n);
+  extern void timer_init_msec (byte tnum);
+  extern void doTimeMsec (void);
+  extern unsigned long get_time (void);
+
+  extern void intTof (void) __attribute__((__interrupt__));
+  extern void intTimeMsec (void) __attribute__((__interrupt__));
+
+
+
+  static inline void
+  doTof (void)
+  {
+    get_hwtime();
+    TofCnt++;
+#if ASM
+    asm("bset %0,%1"::"a"( TimerFlgs ), "i"(  (byte)(1<<7)  )) ;
+#endif
+  }
+
+
+  static inline byte
+  isTickMsecFlg (void)
+  {
+    return TimerFlgs & (1<<6) ;
+  }
+
+
+  static inline void
+  clearTickMsecFlg (void)
+  {
+#if ASM
+    asm("bclr %0,%1"::"R"( TimerFlgs ), "i"(  (1<<6)  )) ;
+#endif
+  }
+
+
+
+
+
+
+# 10 "eeprom.c" 2
+
+
+
+
+extern volatile byte _eeprom_base[0x300 ];
+static word   dataOffset;
+static byte   dataBuf[2];
+static byte   dataSize;
+static byte   writeTries = 2 ;
+static signed char eepTimerNum = -1;
+
+
+
+
+
+
+
+bool
+eeprom_isWriteMode (void)
+{
+  return _io_ports[( 0xF3  )]  & (1<<1) ;
+}
+
+
+
+static inline void
+eeprom_mapOn (void)
+{
+#if ASM
+  asm("bset %0,%1"::"R"( _io_ports[( 0x12  )]  ), "i"(  (1<<0)  )) ;
+#endif
+}
+
+
+static inline void
+eeprom_mapOff (void)
+{
+#if ASM
+  asm("bclr %0,%1"::"R"( _io_ports[( 0x12  )]  ), "i"(  (1<<0)  )) ;
+#endif
+}
+
+
+
+int
+eeprom_prepareRead (word offset)
+{
+  if(offset >= 0x300 )    return -2;
+  if(eeprom_isWriteMode())   return -1;
+  eeprom_mapOn();
+  return 0;
+}
+
+
+
+
+int
+eeprom_readByte (word offset)
+{
+  int rtn;
+
+  rtn = eeprom_prepareRead(offset);
+  if(rtn < 0) return rtn;
+
+  return _eeprom_base[( offset )] ;
+}
+
+
+
+
+word
+eeprom_readWord (word offset)
+{
+  if(eeprom_prepareRead(offset) < 0) return 0xFFFF;
+  return *((volatile word*) &_eeprom_base[( offset )]) ;
+}
+
+
+void
+eeprom_chkWrite (void)
+{
+  if(eepTimerNum < 0) return;
+
+
+  if((_io_ports[( 0xF3  )]  & (1<<0) ) )
+  {
+
+    if(tc_get_flg(eepTimerNum))
+    {
+
+#if ASM
+      asm("bclr %0,%1" : : "R"(_io_ports[( 0xF3  )]  ), "i"(  (1<<0)  )) ;
+      asm("bclr %0,%1" : : "R"( _io_ports[( 0xF3  )]  ), "i"(  (1<<1)  )) ;
+#endif
+    }
+  }
+
+
+  if(! (_io_ports[( 0xF3  )]  & (1<<0) ) )
+  {
+
+    if(dataSize)
+    {
+      byte dataOddBoundary = dataSize & 1;
+      byte dataIdx;
+      word currOffset, r, w;
+
+
+      dataIdx = dataSize - 1;
+#if ASM
+      asm("bclr %0,%1"::"R"( dataIdx ), "i"(  1 )) ;
+#endif
+      currOffset = dataOffset + dataIdx;
+
+      if(dataOddBoundary) {
+
+        r = eeprom_readByte(currOffset);
+        w = dataBuf[dataIdx];
+      }
+      else {
+
+        r = eeprom_readWord(currOffset);
+        w = *((word*)&dataBuf[dataIdx]);
+      }
+
+
+      if((w ^ r) & w)
+      {
+
+#if ASM
+        asm("bset %0,%1"::"R"( _io_ports[( 0xF3  )]  ), "i"(  (1<<4) | (1<<2) | (1<<1)  )) ;
+#endif
+        if(dataOddBoundary)
+        {
+          _eeprom_base[( currOffset )]  = w;
+        }
+        else
+        {
+          *((volatile word*) &_eeprom_base[( currOffset )])  = w;
+        }
+
+
+        tc_set_value(eepTimerNum, get_hwtime()+(word)((8000000   / (1<< 3 ))  *.010));
+#if ASM
+        asm("bset %0,%1"::"R"( _io_ports[( 0xF3  )]  ), "i"(  (1<<0)  )) ;
+#endif
+      }
+      else if(r != w && writeTries)
+      {
+
+        _io_ports[( 0xF3  )]  = (_io_ports[( 0xF3  )]  & ~(1<<2) ) | (1<<1) ;
+
+        if(dataOddBoundary) {
+          _eeprom_base[( currOffset )]  = w;
+        }
+        else {
+          *((volatile word*) &_eeprom_base[( currOffset )])  = w;
+        }
+
+        writeTries--;
+
+
+        tc_set_value(eepTimerNum, get_hwtime()+(word)((8000000   / (1<< 3 ))  *.010));
+#if ASM
+        asm("bset %0,%1"::"R"( _io_ports[( 0xF3  )]  ), "i"(  (1<<0)  )) ;
+#endif
+      }
+      else
+      {
+        dataSize = dataIdx;
+        writeTries = 2 ;
+
+        if(!dataSize)
+        {
+
+          freeTimerNum(eepTimerNum);
+          eepTimerNum = -1;
+        }
+      }
+    }
+  }
+}
+
+
+
+
+
+
+static int
+eeprom_writeData (word offset, void *data, size_t sz)
+{
+  if(dataSize) return -1;
+  if(offset + sz > 0x300 ) return -2;
+  eepTimerNum = reserveTimerNum(0);
+  if(eepTimerNum < 0) return -3;
+  if(sz > sizeof(dataBuf)) return -4;
+
+
+  tc_set_outputcompare(eepTimerNum);
+
+
+  dataOffset = offset;
+  memcpy(dataBuf, data, sz);
+  dataSize   = sz;
+
+  return 0;
+}
+
+
+
+int
+eeprom_writeByte (word offset, byte data)
+{
+  return eeprom_writeData(offset, &data, 1);
+}
+
+
+
+
+int
+eeprom_writeWord (word offset, word data)
+{
+  return eeprom_writeData(offset, &data, 2);
+}
+
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile-scz/pr-7223.c
@@ -0,0 +1,22 @@
+
+extern int foo(int);
+
+int main(int argn, char ** argv)
+{
+        char i;
+        int pos;
+        short d, e, f;
+
+        for(i=100;i>0;--i){
+                argn += i;
+        }
+
+        e = (short)i-argn;
+        d = argn / 1000;
+
+        pos = foo(d * e);
+
+        (*(((unsigned char *)0x1000)+(0x00))) |= 0x10;
+
+        return argn;
+}
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile-scz/pr-7361.c
@@ -0,0 +1,211 @@
+# 5 "essai.c"
+# 1 "nanoK.h" 1
+# 26 "nanoK.h"
+# 1 "type_def.h" 1
+# 26 "type_def.h"
+typedef unsigned char u8;
+typedef unsigned short u16;
+typedef unsigned int u32;
+typedef signed char s8;
+typedef signed short s16;
+typedef signed int s32;
+# 27 "nanoK.h" 2
+# 45 "nanoK.h"
+u8 nanoK_init(void);
+# 56 "nanoK.h"
+u8 nanoK_task_init(u8 t, void (*fct)(void), u8* stk, u16 stk_len);
+# 65 "nanoK.h"
+u8 nanoK_aggregate_task(u8 t1, u8 t2);
+# 74 "nanoK.h"
+inline void nanoK_task_terminate(void);
+# 84 "nanoK.h"
+inline u8 nanoK_task_reset(u8 t);
+# 98 "nanoK.h"
+void nanoK_hook_init(void (*fct)(void), u8* stk, u16 stk_len);
+
+
+
+
+
+void nanoK_start(void);
+
+
+
+
+
+void nanoK_kernel(void);
+
+
+
+
+typedef struct {
+        struct {
+                u8 CCR;
+                u16 D;
+                u16 X;
+                u16 Y;
+                u16 PC;
+                u16 SP;
+        } hard_regs;
+        struct {
+                u16 r[8];
+                u16 tmp;
+                u16 z;
+                u16 xy;
+                u16 frame;
+        } soft_regs;
+} t_context;
+# 6 "essai.c" 2
+# 1 "vectors.h" 1
+# 26 "vectors.h"
+# 1 "type_def.h" 1
+# 27 "vectors.h" 2
+
+typedef enum {
+        Sci,
+        Spi,
+        Pulse_acc_input,
+        Pulse_acc_overf,
+        Timer_overf,
+        Output_compare_5,
+        Output_compare_4,
+        Output_compare_3,
+        Output_compare_2,
+        Output_compare_1,
+        Input_capture_3,
+        Input_capture_2,
+        Input_capture_1,
+        Real_time,
+        Irq,
+        Xirq,
+        Swi,
+        Illegal,
+        Cop_fail,
+        Cop_clock_fail
+
+} t_vector_num;
+
+extern u8 VECTORS_init(void);
+extern void VECTORS_set(t_vector_num n, void (*f)(void));
+# 7 "essai.c" 2
+# 23 "essai.c"
+extern u8 run_task_num;
+# 37 "essai.c"
+static u16 compteur;
+
+static u8 stk0[50];
+static void task0(void)
+{
+
+        while(1) {
+                (*((u8*)0x1003)) &= ~0x03;
+                (*((u8*)0x1003)) |= 0x00;
+                nanoK_task_terminate();
+        }
+}
+
+static u8 stk1[50];
+static void task1(void)
+{
+
+        while(1) {
+                (*((u8*)0x1003)) &= ~0x02;
+                (*((u8*)0x1003)) |= 0x01;
+                nanoK_task_terminate();
+        }
+}
+
+static u8 stk2[50];
+static void task2(void)
+{
+
+        while(1) {
+                (*((u8*)0x1003)) &= ~0x01;
+                (*((u8*)0x1003)) |= 0x02;
+                nanoK_task_terminate();
+        }
+}
+
+static u8 stk3[50];
+static void task3(void)
+{
+
+        while(1) {
+                (*((u8*)0x1003)) &= ~0x00;
+                (*((u8*)0x1003)) |= 0x03;
+                nanoK_task_terminate();
+        }
+}
+
+static u8 hook_stk[50];
+
+static void hook(void)
+{
+
+        compteur++;
+
+
+
+
+
+
+
+        (*((u8*)0x1025)) |= 0x40;
+
+}
+
+typedef void(*JMP)(void);
+typedef struct t_vectors_table {
+  u8 opcode;
+  JMP f;
+} t_vectors_table;
+
+int main(void)
+{
+
+        (*((u8*)0x1007)) = 0xf3;
+
+        nanoK_init();
+        VECTORS_init();
+        compteur = 0;
+
+
+        nanoK_task_init(0, task0, stk0, sizeof(stk0));
+
+
+        nanoK_task_init(1, task1, stk1, sizeof(stk1));
+
+
+        nanoK_task_init(2, task2, stk2, sizeof(stk2));
+
+
+        nanoK_task_init(3, task3, stk3, sizeof(stk3));
+
+
+        nanoK_hook_init(hook, hook_stk, sizeof(hook_stk));
+
+
+
+
+
+
+
+        VECTORS_set(Real_time, nanoK_kernel);
+        (*((u8*)0x1026)) |= 0x03;
+        (*((u8*)0x1024)) |= 0x43;
+
+
+
+        nanoK_start();
+
+
+        return 0;
+}
+
+
+
+
+void __premain() {
+  return;
+}
+
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile-scz/printf.c
@@ -0,0 +1,24 @@
+/*
+ * Simple replacement of printf() for use by GCC testsuite.
+ */
+#include <stdarg.h>
+#include <stddef.h>
+
+extern int vsprintf(char*, const char*, ...);
+extern int write(int, const char*, size_t);
+
+int
+printf(const char *fmt, ...)
+{
+  char buf[256];
+  va_list args;
+  int i;
+
+  va_start(args, fmt);
+  i=vsprintf(buf,fmt,args);
+  va_end(args);
+
+  write(0, buf, i);
+  return i;
+}
+
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile-scz/push.c
@@ -0,0 +1,4 @@
+int bar()
+{
+  return toto(1, 2, 3, 4);
+}
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile-scz/ret64.c
@@ -0,0 +1,9 @@
+long long ret64L()
+{
+  return (long long) (1);
+}
+
+long long ret642L(int a, int b)
+{
+  return (long long) (a + b);
+}
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile-scz/rotate.c
@@ -0,0 +1,60 @@
+unsigned short rotate15(unsigned short a)
+{
+  return (a << 15) | (a >> 1);
+}
+unsigned short rotate14(unsigned short a)
+{
+  return (a << 14) | (a >> 2);
+}
+unsigned short rotate13(unsigned short a)
+{
+  return (a << 13) | (a >> 3);
+}
+unsigned short rotate12(unsigned short a)
+{
+  return (a << 12) | (a >> 4);
+}
+unsigned short rotate11(unsigned short a)
+{
+  return (a << 11) | (a >> 5);
+}
+unsigned short rotate10(unsigned short a)
+{
+  return (a << 10) | (a >> 6);
+}
+unsigned short rotate9(unsigned short a)
+{
+  return (a << 9) | (a >> 7);
+}
+unsigned short rotate8(unsigned short a)
+{
+  return (a << 8) | (a >> 8);
+}
+unsigned short rotate7(unsigned short a)
+{
+  return (a << 7) | (a >> 9);
+}
+unsigned short rotate6(unsigned short a)
+{
+  return (a << 6) | (a >> 10);
+}
+unsigned short rotate5(unsigned short a)
+{
+  return (a << 5) | (a >> 11);
+}
+unsigned short rotate4(unsigned short a)
+{
+  return (a << 4) | (a >> 12);
+}
+unsigned short rotate3(unsigned short a)
+{
+  return (a << 3) | (a >> 13);
+}
+unsigned short rotate2(unsigned short a)
+{
+  return (a << 2) | (a >> 14);
+}
+unsigned short rotate1(unsigned short a)
+{
+  return (a << 1) | (a >> 15);
+}
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile-scz/sex.c
@@ -0,0 +1,5 @@
+short
+sexh (signed char *p)
+{
+  return *p;
+}
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile-scz/sext.c
@@ -0,0 +1,9 @@
+short get16(signed char a)
+{
+  return a;
+}
+
+long get(short a)
+{
+  return a;
+}
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile-scz/shift-1.c
@@ -0,0 +1,9 @@
+unsigned char Shift( unsigned char bitPosition )
+{
+        unsigned char mask;
+
+        mask = 1 <<  bitPosition;
+
+        return ( mask );
+}
+
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile-scz/shl.c
@@ -0,0 +1,6 @@
+unsigned long shl(unsigned long a, int b)
+{
+  a = a >> b;
+  bar(b);
+  return a;
+}
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile-scz/string.c
@@ -0,0 +1,313 @@
+/*
+ *  linux/lib/string.c
+ *
+ *  Copyright (C) 1991, 1992  Linus Torvalds
+ */
+
+/*
+ * stupid library routines.. The optimized versions should generally be found
+ * as inline code in <asm-xx/string.h>
+ *
+ * These are buggy as well..
+ */
+
+#define NULL (void*)0
+typedef unsigned short size_t;
+
+char * ___strtok = NULL;
+
+#ifndef __HAVE_ARCH_STRCPY
+char * strcpy(char * dest,const char *src)
+{
+	char *tmp = dest;
+
+	while ((*dest++ = *src++) != '\0')
+		/* nothing */;
+	return tmp;
+}
+#endif
+
+#ifndef __HAVE_ARCH_STRNCPY
+char * strncpy(char * dest,const char *src,size_t count)
+{
+	char *tmp = dest;
+
+	while (count-- && (*dest++ = *src++) != '\0')
+		/* nothing */;
+
+	return tmp;
+}
+#endif
+
+#ifndef __HAVE_ARCH_STRCAT
+char * strcat(char * dest, const char * src)
+{
+	char *tmp = dest;
+
+	while (*dest)
+		dest++;
+	while ((*dest++ = *src++) != '\0')
+		;
+
+	return tmp;
+}
+#endif
+
+#ifndef __HAVE_ARCH_STRNCAT
+char * strncat(char *dest, const char *src, size_t count)
+{
+	char *tmp = dest;
+
+	if (count) {
+		while (*dest)
+			dest++;
+		while ((*dest++ = *src++)) {
+			if (--count == 0) {
+				*dest = '\0';
+				break;
+			}
+		}
+	}
+
+	return tmp;
+}
+#endif
+
+#ifndef __HAVE_ARCH_STRCMP
+int strcmp(const char * cs,const char * ct)
+{
+	register signed char __res;
+
+	while (1) {
+		if ((__res = *cs - *ct++) != 0 || !*cs++)
+			break;
+	}
+
+	return __res;
+}
+#endif
+
+#ifndef __HAVE_ARCH_STRNCMP
+int strncmp(const char * cs,const char * ct,size_t count)
+{
+	register signed char __res = 0;
+
+	while (count) {
+		if ((__res = *cs - *ct++) != 0 || !*cs++)
+			break;
+		count--;
+	}
+
+	return __res;
+}
+#endif
+
+#ifndef __HAVE_ARCH_STRCHR
+char * strchr(const char * s, int c)
+{
+	for(; *s != (char) c; ++s)
+		if (*s == '\0')
+			return NULL;
+	return (char *) s;
+}
+#endif
+
+#ifndef __HAVE_ARCH_STRRCHR
+char * strrchr(const char * s, int c)
+{
+       const char *p = s + strlen(s);
+       do {
+           if (*p == (char)c)
+               return (char *)p;
+       } while (--p >= s);
+       return NULL;
+}
+#endif
+
+#ifndef __HAVE_ARCH_STRLEN
+size_t strlen(const char * s)
+{
+	const char *sc;
+
+	for (sc = s; *sc != '\0'; ++sc)
+		/* nothing */;
+	return sc - s;
+}
+#endif
+
+#ifndef __HAVE_ARCH_STRNLEN
+size_t strnlen(const char * s, size_t count)
+{
+	const char *sc;
+
+	for (sc = s; count-- && *sc != '\0'; ++sc)
+		/* nothing */;
+	return sc - s;
+}
+#endif
+
+#ifndef __HAVE_ARCH_STRSPN
+size_t strspn(const char *s, const char *accept)
+{
+	const char *p;
+	const char *a;
+	size_t count = 0;
+
+	for (p = s; *p != '\0'; ++p) {
+		for (a = accept; *a != '\0'; ++a) {
+			if (*p == *a)
+				break;
+		}
+		if (*a == '\0')
+			return count;
+		++count;
+	}
+
+	return count;
+}
+#endif
+
+#ifndef __HAVE_ARCH_STRPBRK
+char * strpbrk(const char * cs,const char * ct)
+{
+	const char *sc1,*sc2;
+
+	for( sc1 = cs; *sc1 != '\0'; ++sc1) {
+		for( sc2 = ct; *sc2 != '\0'; ++sc2) {
+			if (*sc1 == *sc2)
+				return (char *) sc1;
+		}
+	}
+	return NULL;
+}
+#endif
+
+#ifndef __HAVE_ARCH_STRTOK
+char * strtok(char * s,const char * ct)
+{
+	char *sbegin, *send;
+
+	sbegin  = s ? s : ___strtok;
+	if (!sbegin) {
+		return NULL;
+	}
+	sbegin += strspn(sbegin,ct);
+	if (*sbegin == '\0') {
+		___strtok = NULL;
+		return( NULL );
+	}
+	send = strpbrk( sbegin, ct);
+	if (send && *send != '\0')
+		*send++ = '\0';
+	___strtok = send;
+	return (sbegin);
+}
+#endif
+
+#ifndef __HAVE_ARCH_MEMSET
+void * memset(void * s,char c,size_t count)
+{
+	char *xs = (char *) s;
+
+	while (count--)
+		*xs++ = c;
+
+	return s;
+}
+#endif
+
+#ifndef __HAVE_ARCH_BCOPY
+char * bcopy(const char * src, char * dest, int count)
+{
+	char *tmp = dest;
+
+	while (count--)
+		*tmp++ = *src++;
+
+	return dest;
+}
+#endif
+
+#ifndef __HAVE_ARCH_MEMCPY
+void * memcpy(void * dest,const void *src,size_t count)
+{
+	char *tmp = (char *) dest, *s = (char *) src;
+
+	while (count--)
+		*tmp++ = *s++;
+
+	return dest;
+}
+#endif
+
+#ifndef __HAVE_ARCH_MEMMOVE
+void * memmove(void * dest,const void *src,size_t count)
+{
+	char *tmp, *s;
+
+	if (dest <= src) {
+		tmp = (char *) dest;
+		s = (char *) src;
+		while (count--)
+			*tmp++ = *s++;
+		}
+	else {
+		tmp = (char *) dest + count;
+		s = (char *) src + count;
+		while (count--)
+			*--tmp = *--s;
+		}
+
+	return dest;
+}
+#endif
+
+#ifndef __HAVE_ARCH_MEMCMP
+int memcmp(const void * cs,const void * ct,size_t count)
+{
+	const unsigned char *su1, *su2;
+	signed char res = 0;
+
+	for( su1 = cs, su2 = ct; 0 < count; ++su1, ++su2, count--)
+		if ((res = *su1 - *su2) != 0)
+			break;
+	return res;
+}
+#endif
+
+/*
+ * find the first occurrence of byte 'c', or 1 past the area if none
+ */
+#ifndef __HAVE_ARCH_MEMSCAN
+void * memscan(void * addr, int c, size_t size)
+{
+	unsigned char * p = (unsigned char *) addr;
+
+	while (size) {
+		if (*p == c)
+			return (void *) p;
+		p++;
+		size--;
+	}
+  	return (void *) p;
+}
+#endif
+
+#ifndef __HAVE_ARCH_STRSTR
+char * strstr(const char * s1,const char * s2)
+{
+	int l1, l2;
+
+	l2 = strlen(s2);
+	if (!l2)
+		return (char *) s1;
+	l1 = strlen(s1);
+	while (l1 >= l2) {
+		l1--;
+		if (!memcmp(s1,s2,l2))
+			return (char *) s1;
+		s1++;
+	}
+	return NULL;
+}
+#endif
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile-scz/tst-asm.c
@@ -0,0 +1,19 @@
+void __premain()
+{
+  __asm__ volatile("clra\n\t"
+	                     "tap" : : : "d");
+}
+
+void inline foo()
+{
+  char* msg = "TEST STRING";
+  unsigned char code = 16;
+
+  __asm__ __volatile__("jsr  0x7012"
+                       : : "x"(msg), "d"(code));
+}
+
+int main()
+{
+  ;
+}
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile-scz/vsprintf.c
@@ -0,0 +1,320 @@
+/*
+ *  linux/lib/vsprintf.c
+ *
+ *  Copyright (C) 1991, 1992  Linus Torvalds
+ */
+
+/* vsprintf.c -- Lars Wirzenius & Linus Torvalds. */
+/*
+ * Wirzenius wrote this portably, Torvalds fucked it up :-)
+ */
+
+#include <stdarg.h>
+/*#include <sys/types.h>*/
+/*#include <linux/string.h>*/
+/*#include <ctype.h> */
+
+#define isxdigit(c) (((c) >= '0' && (c) <= '9') || \
+                     ((c) >= 'a' && (c) <= 'f') || \
+                     ((c) >= 'A' && (c) <= 'F'))
+#define isdigit(c)  ((c) >= '0' && (c) <= '9')
+#define islower(c)  ((c) >= 'a')
+#define toupper(c)  ((c) - 'a' + 'A')
+
+unsigned long simple_strtoul(const char *cp,char **endp,unsigned int base)
+{
+	unsigned long result = 0,value;
+
+	if (!base) {
+		base = 10;
+		if (*cp == '0') {
+			base = 8;
+			cp++;
+			if ((*cp == 'x') && isxdigit(cp[1])) {
+				cp++;
+				base = 16;
+			}
+		}
+	}
+	while (isxdigit(*cp) && (value = isdigit(*cp) ? *cp-'0' : (islower(*cp)
+	    ? toupper(*cp) : *cp)-'A'+10) < base) {
+		result = result*base + value;
+		cp++;
+	}
+	if (endp)
+		*endp = (char *)cp;
+	return result;
+}
+
+/* we use this so that we can do without the ctype library */
+#define is_digit(c)	((c) >= '0' && (c) <= '9')
+
+static int skip_atoi(const char **s)
+{
+	int i=0;
+
+	while (is_digit(**s))
+		i = i*10 + *((*s)++) - '0';
+	return i;
+}
+
+#define ZEROPAD	1		/* pad with zero */
+#define SIGN	2		/* unsigned/signed long */
+#define PLUS	4		/* show plus */
+#define SPACE	8		/* space if plus */
+#define LEFT	16		/* left justified */
+#define SPECIAL	32		/* 0x */
+#define LARGE	64		/* use 'ABCDEF' instead of 'abcdef' */
+
+#define do_div(n,base) ({ \
+int __res; \
+__res = ((unsigned long) n) % (unsigned) base; \
+n = ((unsigned long) n) / (unsigned) base; \
+__res; })
+
+static char * number(char * str, long num, int base, int size, int precision
+	,int type)
+{
+	char c,sign,tmp[66];
+	const char *digits="0123456789abcdefghijklmnopqrstuvwxyz";
+	int i;
+
+	if (type & LARGE)
+		digits = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
+	if (type & LEFT)
+		type &= ~ZEROPAD;
+	if (base < 2 || base > 36)
+		return 0;
+	c = (type & ZEROPAD) ? '0' : ' ';
+	sign = 0;
+	if (type & SIGN) {
+		if (num < 0) {
+			sign = '-';
+			num = -num;
+			size--;
+		} else if (type & PLUS) {
+			sign = '+';
+			size--;
+		} else if (type & SPACE) {
+			sign = ' ';
+			size--;
+		}
+	}
+	if (type & SPECIAL) {
+		if (base == 16)
+			size -= 2;
+		else if (base == 8)
+			size--;
+	}
+	i = 0;
+	if (num == 0)
+		tmp[i++]='0';
+	else while (num != 0)
+		tmp[i++] = digits[do_div(num,base)];
+	if (i > precision)
+		precision = i;
+	size -= precision;
+	if (!(type&(ZEROPAD+LEFT)))
+		while(size-->0)
+			*str++ = ' ';
+	if (sign)
+		*str++ = sign;
+	if (type & SPECIAL)
+		if (base==8)
+			*str++ = '0';
+		else if (base==16) {
+			*str++ = '0';
+			*str++ = digits[33];
+		}
+	if (!(type & LEFT))
+		while (size-- > 0)
+			*str++ = c;
+	while (i < precision--)
+		*str++ = '0';
+	while (i-- > 0)
+		*str++ = tmp[i];
+	while (size-- > 0)
+		*str++ = ' ';
+	return str;
+}
+
+int vsprintf(char *buf, const char *fmt, va_list args)
+{
+	int len;
+	unsigned long num;
+	int i, base;
+	char * str;
+	const char *s;
+
+	int flags;		/* flags to number() */
+
+	int field_width;	/* width of output field */
+	int precision;		/* min. # of digits for integers; max
+				   number of chars for from string */
+	int qualifier;		/* 'h', 'l', or 'L' for integer fields */
+
+	for (str=buf ; *fmt ; ++fmt) {
+		if (*fmt != '%') {
+			*str++ = *fmt;
+			continue;
+		}
+
+		/* process flags */
+		flags = 0;
+		repeat:
+			++fmt;		/* this also skips first '%' */
+			switch (*fmt) {
+				case '-': flags |= LEFT; goto repeat;
+				case '+': flags |= PLUS; goto repeat;
+				case ' ': flags |= SPACE; goto repeat;
+				case '#': flags |= SPECIAL; goto repeat;
+				case '0': flags |= ZEROPAD; goto repeat;
+				}
+
+		/* get field width */
+		field_width = -1;
+		if (is_digit(*fmt))
+			field_width = skip_atoi(&fmt);
+		else if (*fmt == '*') {
+			++fmt;
+			/* it's the next argument */
+			field_width = va_arg(args, int);
+			if (field_width < 0) {
+				field_width = -field_width;
+				flags |= LEFT;
+			}
+		}
+
+		/* get the precision */
+		precision = -1;
+		if (*fmt == '.') {
+			++fmt;
+			if (is_digit(*fmt))
+				precision = skip_atoi(&fmt);
+			else if (*fmt == '*') {
+				++fmt;
+				/* it's the next argument */
+				precision = va_arg(args, int);
+			}
+			if (precision < 0)
+				precision = 0;
+		}
+
+		/* get the conversion qualifier */
+		qualifier = -1;
+		if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L') {
+			qualifier = *fmt;
+			++fmt;
+		}
+
+		/* default base */
+		base = 10;
+
+		switch (*fmt) {
+		case 'c':
+			if (!(flags & LEFT))
+				while (--field_width > 0)
+					*str++ = ' ';
+			*str++ = (unsigned char) va_arg(args, int);
+			while (--field_width > 0)
+				*str++ = ' ';
+			continue;
+
+		case 's':
+			s = va_arg(args, char *);
+			if (!s)
+				s = "<NULL>";
+
+			len = strlen(s);
+                        if (len > precision && precision >= 0)
+                          len = precision;
+
+			if (!(flags & LEFT))
+				while (len < field_width--)
+					*str++ = ' ';
+			for (i = 0; i < len; ++i)
+				*str++ = *s++;
+			while (len < field_width--)
+				*str++ = ' ';
+			continue;
+
+		case 'p':
+			if (field_width == -1) {
+				field_width = 2*sizeof(void *);
+				flags |= ZEROPAD;
+			}
+			str = number(str,
+				(unsigned long) va_arg(args, void *), 16,
+				field_width, precision, flags);
+			continue;
+
+
+		case 'n':
+			if (qualifier == 'l') {
+				long * ip = va_arg(args, long *);
+				*ip = (str - buf);
+			} else {
+				int * ip = va_arg(args, int *);
+				*ip = (str - buf);
+			}
+			continue;
+
+		/* integer number formats - set up the flags and "break" */
+		case 'o':
+			base = 8;
+			break;
+
+		case 'X':
+			flags |= LARGE;
+		case 'x':
+			base = 16;
+			break;
+
+		case 'd':
+		case 'i':
+			flags |= SIGN;
+		case 'u':
+			break;
+
+                        /* For GCC test gcc.c-torture/execute/ieee/920810-1.c */
+                case 'g':
+                  *str++ = '0';
+                  continue;
+
+		default:
+			if (*fmt != '%')
+				*str++ = '%';
+			if (*fmt)
+				*str++ = *fmt;
+			else
+				--fmt;
+			continue;
+		}
+		if (qualifier == 'l')
+			num = va_arg(args, unsigned long);
+		else if (qualifier == 'h')
+			if (flags & SIGN)
+				num = va_arg(args, int);
+			else
+				num = va_arg(args, unsigned int);
+		else if (flags & SIGN)
+			num = va_arg(args, int);
+		else
+			num = va_arg(args, unsigned int);
+		str = number(str, num, base, field_width, precision, flags);
+	}
+	*str = '\0';
+	return str-buf;
+}
+
+int sprintf(char * buf, const char *fmt, ...)
+{
+	va_list args;
+	int i;
+
+	va_start(args, fmt);
+	i=vsprintf(buf,fmt,args);
+	va_end(args);
+	return i;
+}
+
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/20010327-1.x
@@ -0,0 +1,8 @@
+# This test does not compile on m68hc11 because it
+# assumes pointers are 32-bits
+
+if { [istarget "m6811-*-*"] || [istarget "m6812-*-*"] } {
+      return 1
+}
+
+return 0
--- a/gcc/testsuite/gcc.c-torture/compile/920521-1.x
+++ b/gcc/testsuite/gcc.c-torture/compile/920521-1.x
@@ -1,2 +1,7 @@
+# Test defines an asm which sometimes requires too many
+# registers for HC11/HC12.
+if { [istarget "m6811-*-*"] || [istarget "m6812-*-*"] } {
+      return 1
+}
 set options "-S"
 return 0
--- a/gcc/testsuite/gcc.c-torture/compile/simd-5.x
+++ b/gcc/testsuite/gcc.c-torture/compile/simd-5.x
@@ -3,6 +3,11 @@
     return 1;
 }
 
+# On 68HC11 is fails with 16-bit ints
+if { [istarget "m6811-*-*"] || [istarget "m6812-*-*"] } {
+    return 1;
+}
+
 if { [istarget "sparc64-*-*"] || [istarget "sparcv9-*-*"] } {
     # On SPARC64/SPARC-V9 it fails, except with -m32.
     set torture_eval_before_compile {
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute-scz/andqi.c
@@ -0,0 +1,52 @@
+signed char value;
+
+signed char values[] = {
+  0, 1, 2, 3, 5, 7, 9, 16, 127, 128
+};
+
+signed char expect[] = {
+  0, 0, 0, 0, 4, 4, 8, 0, 12, 0
+};
+
+void
+andqi_global ()
+{
+  value &= 12;
+}
+
+void
+andqi_ptr (signed char* p)
+{
+  *p &= 12;
+}
+
+signed char
+andqi_return (signed char v)
+{
+  return v & 12;
+}
+
+int
+main()
+{
+  unsigned i;
+  signed char c;
+
+  for (i = 0; i < sizeof(values) / sizeof(values[0]); i++)
+    {
+      value = values[i];
+      andqi_global ();
+      if (value != expect[i])
+        abort ();
+
+      c = values[i];
+      andqi_ptr (&c);
+      if (c != expect[i])
+        abort ();
+
+      c = andqi_return (values[i]);
+      if (c != expect[i])
+        abort ();
+    }
+  exit (0);
+}
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute-scz/autoinc.c
@@ -0,0 +1,70 @@
+void
+post_inc_short (unsigned short *dst, unsigned short *src)
+{
+  *dst++ = *src++;
+  *dst++ = 0xabcd;
+  *dst++ = src[2];
+  *dst = *src++;
+}
+
+void
+pre_inc_short (unsigned short *dst, unsigned short *src)
+{
+  *++dst = *++src;
+  *++dst = 0xabcd;
+  *++dst = src[3];
+  *++dst = *++src;
+}
+
+
+void
+post_inc_long (unsigned long *dst, unsigned long *src)
+{
+  *dst++ = *src++;
+  *dst++ = 0xabcdef23;
+  *dst++ = src[2];
+  *dst = *src++;
+}
+
+void
+pre_inc_long (unsigned long *dst, unsigned long *src)
+{
+  *++dst = *++src;
+  *++dst = 0xabcdef23;
+  *++dst = src[3];
+  *++dst = *++src;
+}
+
+int
+main ()
+{
+  unsigned short dst[10];
+  unsigned short src[10];
+  unsigned long dstl[10];
+  unsigned long srcl[10];
+
+  src[0] = 0x1234;
+  src[1] = 0x2345;
+  src[3] = 0x3456;
+  src[4] = 0x4567;
+  post_inc_short (dst, src);
+  if (dst[0] != 0x1234 || dst[1] != 0xabcd
+      || dst[2] != 0x3456 || dst[3] != 0x2345)
+    abort ();
+
+  srcl[0] = 0x12345678;
+  srcl[1] = 0x23456789;
+  srcl[3] = 0x3456789a;
+  srcl[4] = 0x456789ab;
+  post_inc_long (dstl, srcl);
+  if (dstl[0] != 0x12345678 || dstl[1] != 0xabcdef23
+      || dstl[2] != 0x3456789a || dstl[3] != 0x23456789)
+    abort ();
+
+  pre_inc_long (dstl, &srcl[-1]);
+  if (dstl[1] != 0x12345678 || dstl[2] != 0xabcdef23
+      || dstl[3] != 0x3456789a || dstl[4] != 0x23456789)
+    abort ();
+
+  return 0;
+}
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute-scz/b-20010414.c
@@ -0,0 +1,55 @@
+enum v {
+  L1, L2, L3
+};
+void bar();
+
+int
+get(unsigned char a, unsigned char b, long *c, enum v d)
+{
+  int i, j;
+
+  bar ();
+  switch (d)
+    {
+    case L1:
+      i = 1;
+      break;
+
+    case L2:
+      i = b;
+      break;
+
+    case L3:
+      i = *c;
+      break;
+    }
+  j = 0;
+  while (i > 0)
+    {
+      j += i;
+      i--;
+    }
+  return j;
+}
+
+void
+bar()
+{
+  ;
+}
+
+int
+main ()
+{
+  long a = 0x12345678;
+  int result;
+
+  result = get (1, 2, &a, L2);
+  if (a != 0x12345678)
+    abort ();
+
+  if (result != 3)
+    abort ();
+
+  return 0;
+}
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute-scz/b-20020520.c
@@ -0,0 +1,13 @@
+ static  struct {
+     unsigned int b0 : 1;
+   int v : 4;
+   int b : 8;
+  }tester;
+
+int main()
+{
+  tester.b = 4;
+  tester.v = 2;
+  return tester.b0;
+}
+
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute-scz/b-20040816.c
@@ -0,0 +1,22 @@
+typedef unsigned char uint8_t;
+typedef unsigned short uint16_t;
+typedef unsigned long uint32_t;
+
+uint32_t test;
+
+void shl(uint8_t Nr)
+{
+    test |= (1L<<Nr);
+}
+
+int main(void)
+{
+  test = 1;
+  shl(2);
+  if (test != 5L)
+     return 1;
+  shl(17);
+  if (test != (5L | (1L << 17)))
+     return 1;
+  return 0;
+}
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute-scz/b-20051105.c
@@ -0,0 +1,79 @@
+struct fields
+{
+  unsigned long long u1 : 15;
+  unsigned long long u2 : 33;
+  unsigned long long u3 : 16;
+  signed long long   s1 : 15;
+  signed long long   s2 : 33;
+  signed long long   s3 : 16;
+} flags;
+
+struct sfields
+{
+  unsigned long u1 : 15;
+  unsigned long u2 : 17;
+  unsigned long u3 : 16;
+  signed long    s1 : 15;
+  signed long    s2 : 17;
+  signed long    s3 : 16;
+} sflags;
+
+void break1()
+{
+}
+
+#define FIELD(S,VAL,CODE) \
+  flags.S = VAL;          \
+  break1();               \
+  if (flags.S != VAL) {   \
+    return CODE;          \
+  }
+
+#define CHECK_U2(CODE) \
+  FIELD(u2,1,CODE+1);        \
+  FIELD(u2,2,CODE+1);        \
+  FIELD(u2,0x100,CODE+1);     \
+  FIELD(u2,0xabcd,CODE+1);    \
+  FIELD(u2,0x12ab34cd,CODE+1)
+
+#define CHECK_S2(CODE) \
+  FIELD(s2,1,CODE+1);        \
+  FIELD(s2,2,CODE+1);        \
+  FIELD(s2,0x100,CODE+1);     \
+  FIELD(s2,0xabcd,CODE+1);    \
+  FIELD(s2,0x12ab34cd,CODE+1)
+
+int main()
+{
+  flags.s2 = 1;
+  break1();
+  if (flags.s2 != 1)
+    return 1;
+
+  flags.u2 = 0x1aaaaffffLL;
+  break1();
+  if (flags.u2 != 0x1aaaaffffLL)
+    return 2;
+
+  flags.u2 = ~0x1aaaaffffLL;
+  break1();
+  if (flags.u2 != 0x055550000LL)
+    return 3;
+
+  sflags.s2 = 1;
+  break1();
+  if (sflags.s2 != 1)
+    return 4;
+
+  sflags.u2 = 0x1aaffL;
+  break1();
+  if (sflags.u2 != 0x1aaffL)
+    return 5;
+
+  sflags.u2 = ~0x1aaffL;
+  if (sflags.u2 != 0x5500L)
+    return 6;
+
+  CHECK_U2(50);
+  return 0;
+}
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute-scz/bigmul.c
@@ -0,0 +1,28 @@
+long a = 10000;
+long b = 200000;
+unsigned long c = 100000;
+unsigned long d = 20000;
+long long e = 100000000LL;
+long long f = 200000000LL;
+
+int main()
+{
+  long r;
+  unsigned long p;
+  long long q;
+
+  r = a * b;
+  if (r != 10000 * 200000)
+    return 1;
+
+  p = c * d;
+  if (p != 100000 * 20000)
+    return 1;
+
+  q = e * f;
+  if (q != 100000000LL * 200000000LL)
+    return 1;
+
+  return 0;
+}
+
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute-scz/bit.c
@@ -0,0 +1,95 @@
+unsigned
+bit_char (unsigned char n)
+{
+  unsigned cnt = 0;
+
+  if (n & 1) cnt++;
+  if (n & 2) cnt++;
+  if (n & 4) cnt++;
+  if (n & 8) cnt++;
+  if (n & 16) cnt++;
+  if (n & 32) cnt++;
+  if (n & 64) cnt++;
+  if (n & 128) cnt++;
+  return cnt;
+}
+
+unsigned
+bit_short (unsigned short n)
+{
+  unsigned cnt = 0;
+
+  if (n & 1) cnt++;
+  if (n & 128) cnt++;
+  if (n & 256) cnt++;
+  if (n & 0x8000) cnt++;
+
+  return cnt + bit_char (n) + bit_char (n >> 8);
+}
+
+unsigned
+bit_ulong (unsigned long n)
+{
+  unsigned cnt = 0;
+
+  if (n & 1) cnt++;
+  if (n & 0x8000) cnt++;
+  if (n & 0x10000) cnt++;
+  if (n & 0x80000000) cnt++;
+  return cnt + bit_short (n) + bit_short (n >> 16);
+}
+
+unsigned
+bit_ulonglong (unsigned long long n)
+{
+  unsigned cnt = 0;
+
+  if (n & 1LL) cnt++;
+  if (n & 0x80000000LL) cnt++;
+  if (n & 0x100000000LL) cnt++;
+  if (n & 0x8000000000000000LL) cnt++;
+  return cnt + bit_ulong (n) + bit_ulong (n >> 32);
+}
+
+int
+main ()
+{
+  long long n;
+  int i, j;
+  unsigned cnt_char, cnt_short, cnt_long, cnt_longlong;
+
+  for (i = 0; i < 64; i++)
+    {
+      n = (1LL << i);
+      cnt_char = 0;
+      cnt_short = 0;
+      cnt_long  = 0;
+      cnt_longlong = bit_ulonglong (n);
+      for (j = 0; j < 8; j++)
+	{
+	  cnt_char += bit_char (n >> (j * 8));
+	  if ((j & 1) == 0)
+	    cnt_short += bit_short (n >> (j * 8));
+
+	  if ((j & 3) == 0)
+	    cnt_long += bit_ulong (n >> (j * 8));
+	}
+#if 0
+      printf ("%d: %d %d %d %d\n", i, cnt_char, cnt_short,
+	      cnt_long, cnt_longlong);
+#endif
+      if ((i % 8) == 0 || (i % 8) == 7)
+	cnt_short --, cnt_long --, cnt_longlong --;
+
+      if ((i % 16) == 0 || (i % 16) == 15)
+	cnt_long --, cnt_longlong --;
+
+      if ((i % 32) == 0 || (i % 32) == 31)
+	cnt_longlong --;
+
+      if (cnt_short != cnt_char || cnt_short != cnt_long
+	  || cnt_long != cnt_longlong || cnt_char != 1)
+	exit (1);
+    }
+  return 0;
+}
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute-scz/bitfield.c
@@ -0,0 +1,328 @@
+struct bfield
+{
+  int b1 : 1;
+  int b2 : 2;
+  int b3 : 3;
+  int b4 : 4;
+  int b5 : 5;
+  int b6 : 6;
+  int b7 : 7;
+  int b8 : 8;
+  int b9 : 9;
+  int b10: 10;
+  int b11: 11;
+  int b12: 12;
+  int b13: 13;
+  int b14: 14;
+  int b15: 15;
+};
+
+struct bfield
+fillup (int value)
+{
+  struct bfield bf;
+
+  bf.b1 = value;
+  bf.b2 = value;
+  bf.b3 = value;
+  bf.b4 = value;
+  bf.b5 = value;
+  bf.b6 = value;
+  bf.b7 = value;
+  bf.b8 = value;
+  bf.b9 = value;
+  bf.b10 = value;
+  bf.b11 = value;
+  bf.b12 = value;
+  bf.b13 = value;
+  bf.b14 = value;
+  bf.b15 = value;
+  return bf;
+}
+
+int
+compare (struct bfield b1, struct bfield b2)
+{
+  if (b1.b1 != b2.b1)
+    return 1;
+  if (b1.b2 != b2.b2)
+    return 2;
+  if (b1.b3 != b2.b3)
+    return 3;
+  if (b1.b4 != b2.b4)
+    return 4;
+  if (b1.b5 != b2.b5)
+    return 5;
+  if (b1.b6 != b2.b6)
+    return 6;
+  if (b1.b7 != b2.b7)
+    return 7;
+  if (b1.b8 != b2.b8)
+    return 8;
+  if (b1.b9 != b2.b9)
+    return 9;
+  if (b1.b10 != b2.b10)
+    return 10;
+  if (b1.b11 != b2.b11)
+    return 11;
+  if (b1.b12 != b2.b12)
+    return 12;
+  if (b1.b13 != b2.b13)
+    return 13;
+  if (b1.b14 != b2.b14)
+    return 14;
+  if (b1.b15 != b2.b15)
+    return 15;
+
+  return 0;
+}
+
+int
+expect_value (int n, int bits)
+{
+  if (n & (1 << (bits - 1)))
+    return (n & ((1 << bits) - 1)) | ~((1 << bits) - 1);
+  else
+    return (n & ((1 << bits) - 1));
+}
+
+
+int
+main ()
+{
+  long long n;
+  long i, j;
+  unsigned cnt_char, cnt_short, cnt_long, cnt_longlong;
+  struct bfield b1, b2;
+
+  for (i = 0; i < 32768; )
+    {
+      int res;
+
+      b1 = fillup (i);
+      b2 = fillup (i);
+#define exit(P) {printf ("At %d\n", __LINE__); return 1; }
+
+      if (b1.b1 != expect_value (i, 1))
+	exit (1);
+      if (b1.b2 != expect_value (i, 2))
+	exit (1);
+      if (b1.b3 != expect_value (i, 3))
+	exit (1);
+      if (b1.b4 != expect_value (i, 4))
+	exit (1);
+      if (b1.b5 != expect_value (i, 5))
+	exit (1);
+      if (b1.b6 != expect_value (i, 6))
+	exit (1);
+      if (b1.b7 != expect_value (i, 7))
+	exit (1);
+      if (b1.b8 != expect_value (i, 8))
+	exit (1);
+      if (b1.b9 != expect_value (i, 9))
+	exit (1);
+      if (b1.b10 != expect_value (i, 10))
+	exit (1);
+      if (b1.b11 != expect_value (i, 11))
+	exit (1);
+      if (b1.b12 != expect_value (i, 12))
+	exit (1);
+      if (b1.b13 != expect_value (i, 13))
+	exit (1);
+      if (b1.b14 != expect_value (i, 14))
+	exit (1);
+
+      if (b1.b15 != expect_value (i, 15))
+	exit (1);
+
+      res = compare (b1, b2);
+      if (res != 0)
+	exit (1);
+
+      /* B1 */
+      b2.b1 = ~b2.b1;
+      res = compare (b1, b2);
+      if (res != 1)
+	exit (1);
+
+      b2.b1 = b1.b1;
+      res = compare (b1, b2);
+      if (res != 0)
+	exit (1);
+
+      /* B2 */
+      b2.b2 = ~b2.b2;
+      res = compare (b1, b2);
+      if (res != 2)
+	exit (1);
+
+      b2.b2 = b1.b2;
+      res = compare (b1, b2);
+      if (res != 0)
+	exit (1);
+
+      /* B3 */
+      b2.b3 = ~b2.b3;
+      res = compare (b1, b2);
+      if (res != 3)
+	exit (1);
+
+      b2.b3 = b1.b3;
+      res = compare (b1, b2);
+      if (res != 0)
+	exit (1);
+
+      /* B4 */
+      b2.b4 = ~b2.b4;
+      res = compare (b1, b2);
+      if (res != 4)
+	exit (1);
+
+      b2.b4 = b1.b4;
+      res = compare (b1, b2);
+      if (res != 0)
+	exit (1);
+
+      /* B5 */
+      b2.b5 = ~b2.b5;
+      res = compare (b1, b2);
+      if (res != 5)
+	exit (1);
+
+      b2.b5 = b1.b5;
+      res = compare (b1, b2);
+      if (res != 0)
+	exit (1);
+
+      /* B6 */
+      b2.b6 = ~b2.b6;
+      res = compare (b1, b2);
+      if (res != 6)
+	exit (1);
+
+      b2.b6 = b1.b6;
+      res = compare (b1, b2);
+      if (res != 0)
+	exit (1);
+
+      /* B7 */
+      b2.b7 = ~b2.b7;
+      res = compare (b1, b2);
+      if (res != 7)
+	exit (1);
+
+      b2.b7 = b1.b7;
+      res = compare (b1, b2);
+      if (res != 0)
+	exit (1);
+
+      /* B8 */
+      b2.b8 = ~b2.b8;
+      res = compare (b1, b2);
+      if (res != 8)
+	exit (1);
+
+      b2.b8 = b1.b8;
+      res = compare (b1, b2);
+      if (res != 0)
+	exit (1);
+
+      /* B9 */
+      b2.b9 = ~b2.b9;
+      res = compare (b1, b2);
+      if (res != 9)
+	exit (1);
+
+      b2.b9 = b1.b9;
+      res = compare (b1, b2);
+      if (res != 0)
+	exit (1);
+
+      /* B10 */
+      b2.b10 = ~b2.b10;
+      res = compare (b1, b2);
+      if (res != 10)
+	exit (1);
+
+      b2.b10 = b1.b10;
+      res = compare (b1, b2);
+      if (res != 0)
+	exit (1);
+
+      /* B10 */
+      b2.b10 = ~b2.b10;
+      res = compare (b1, b2);
+      if (res != 10)
+	exit (1);
+
+      b2.b10 = b1.b10;
+      res = compare (b1, b2);
+      if (res != 0)
+	exit (1);
+
+      /* B11 */
+      b2.b11 = ~b2.b11;
+      res = compare (b1, b2);
+      if (res != 11)
+	exit (1);
+
+      b2.b11 = b1.b11;
+      res = compare (b1, b2);
+      if (res != 0)
+	exit (1);
+
+      /* B12 */
+      b2.b12 = ~b2.b12;
+      res = compare (b1, b2);
+      if (res != 12)
+	exit (1);
+
+      b2.b12 = b1.b12;
+      res = compare (b1, b2);
+      if (res != 0)
+	exit (1);
+
+      /* B13 */
+      b2.b13 = ~b2.b13;
+      res = compare (b1, b2);
+      if (res != 13)
+	exit (1);
+
+      b2.b13 = b1.b13;
+      res = compare (b1, b2);
+      if (res != 0)
+	exit (1);
+
+      /* B14 */
+      b2.b14 = ~b2.b14;
+      res = compare (b1, b2);
+      if (res != 14)
+	exit (1);
+
+      b2.b14 = b1.b14;
+      res = compare (b1, b2);
+      if (res != 0)
+	exit (1);
+
+      /* B15 */
+      b2.b15 = ~b2.b15;
+      res = compare (b1, b2);
+      if (res != 15)
+	exit (1);
+
+      b2.b15 = b1.b15;
+      res = compare (b1, b2);
+      if (res != 0)
+	exit (1);
+
+      if (i < 300)
+        {
+          i++;
+        }
+      else
+        {
+          i += 119;
+        }
+    }
+  return 0;
+}
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute-scz/bset.c
@@ -0,0 +1,13 @@
+/* Handle GEL page0 indications.  The global/static variables
+   specified with that attribute will be put within page0.  */
+#define PAGE0_ATTRIBUTE __attribute__((section(".page0")))
+
+char var PAGE0_ATTRIBUTE;
+
+int main()
+{
+  var |= 1;
+  if (var & 2)
+    var &= 8;
+  return 0;
+}
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute-scz/execute.exp
@@ -0,0 +1,43 @@
+# Copyright (C) 1991, 1992, 1993, 1995, 1997 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+
+# This file was written by Rob Savoye. (rob@cygnus.com)
+# Modified and maintained by Jeffrey Wheat (cassidy@cygnus.com)
+
+#
+# These tests come from Torbjorn Granlund (tege@cygnus.com)
+# C torture test suite.
+#
+
+if $tracelevel then {
+    strace $tracelevel
+}
+
+# load support procs
+load_lib c-torture.exp
+
+#
+# main test loop
+#
+
+foreach src [lsort [glob -nocomplain $srcdir/$subdir/*.c]] {
+    # If we're only testing specific files and this isn't one of them, skip it.
+    if ![runtest_file_p $runtests $src] then {
+	continue
+    }
+
+    c-torture-execute $src
+}
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute-scz/malloc.c
@@ -0,0 +1,32 @@
+#include <stdlib.h>
+#include <string.h>
+
+int main()
+{
+  char *p[100];
+  int i, j;
+
+  for (i = 0; i < 100; i++)
+    {
+      p[i] = malloc (40);
+      /* printf ("p[%d] = 0x%02x\n", i, p[i]); */
+    }
+
+  for (i = 0; i < 10; i++)
+    for (j = 0; j < 32; j++)
+      p[i][j] = i + j + ' ';
+
+  for (i = 0; i < 10; i++)
+    p[i][32] = 0;
+
+  for (i = 0; i < 10; i++)
+    for (j = 0; j < 10; j++)
+      if (i == j)
+        {
+          if (strcmp (p[i], p[j]) != 0)
+            return 1;
+        }
+      else if (strcmp (p[i], p[j]) == 0)
+        return 1;
+  return 0;
+}
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute-scz/memset-2003-01-25.c
@@ -0,0 +1,9 @@
+#include <string.h>
+
+char foo[10];
+
+int main()
+{
+  memset (foo, 1, sizeof (foo));
+  return foo[0] - 1;
+}
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute-scz/mul-1.c
@@ -0,0 +1,114 @@
+unsigned char
+frac_char (unsigned char n)
+{
+  if (n > 1)
+    return n * frac_char (n - 1);
+  else
+    return 1;
+}
+
+unsigned short
+frac_ushort (unsigned short n)
+{
+  if (n > 1)
+    return n * frac_ushort (n - 1);
+  else
+    return 1;
+}
+
+short
+frac_short (short n)
+{
+  if (n > 1)
+    return n * frac_short (n - 1);
+  else
+    return 1;
+}
+
+unsigned long
+frac_ulong (unsigned long n)
+{
+  if (n > 1)
+    return n * frac_ulong (n - 1);
+  else
+    return 1;
+}
+
+long
+frac_long (long n)
+{
+  if (n > 1)
+    return n * frac_long (n - 1);
+  else
+    return 1;
+}
+
+unsigned long long
+frac_ulonglong (unsigned long long n)
+{
+  if (n > 1)
+    return n * frac_ulonglong (n - 1);
+  else
+    return 1;
+}
+
+long long
+frac_longlong (long long n)
+{
+  if (n > 1)
+    return n * frac_longlong (n - 1);
+  else
+    return 1;
+}
+
+long long ftable[] = {
+  1, 2, 6, 24, 120, 720, 5040, 40320, 362880,
+  3628800, 39916800, 479001600, 6227020800,
+  87178291200, 1307674368000, 20922789888000,
+  355687428096000, 6402373705728000, 121645100408832000,
+  2432902008176640000
+};
+
+void
+error (char *func, int n, long long result)
+{
+  printf ("Failed: %s (%d) => %lld\n", func, n, result);
+  exit (1);
+}
+
+int
+main ()
+{
+  int i;
+
+  for (i = 0; i < sizeof(ftable) / sizeof(ftable[0]); i++)
+    {
+      if (ftable[i] < 256)
+	{
+	  if (frac_char (i+1) != ftable[i])
+	    error ("frac_char", i, (long long) frac_char (i+1));
+	}
+      if (ftable[i] < 65536)
+	{
+	  if (ftable[i] <= 32767 && frac_short (i+1) != ftable[i])
+	    error ("frac_short", i, (long long) frac_short (i+1));
+
+	  if (frac_ushort (i+1) != ftable[i])
+	    error ("frac_ushort", i, (long long) frac_ushort (i+1));
+	}
+      if (ftable[i] < 65536*65536)
+	{
+	  if (ftable[i] <= 0x7ffffffffL && frac_long (i+1) != ftable[i])
+	    error ("frac_long", i, (long long) frac_long (i+1));
+
+	  if (frac_ulong (i+1) != ftable[i])
+	    error ("frac_ulong", i, (long long) frac_ulong (i+1));
+	}
+      if (frac_longlong (i+1) != ftable[i])
+	error ("frac_longlong", i, frac_longlong (i+1));
+
+      if (frac_ulonglong (i+1) != ftable[i])
+	error ("frac_ulonglong", i, frac_ulonglong (i+1));
+    }
+  return 0;
+}
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute-scz/negqi.c
@@ -0,0 +1,64 @@
+signed char value;
+
+signed char values[] = {
+  0, 1, 2, 3, 5, 7, 9, 16, 127, 128
+};
+
+signed char expect[] = {
+  0, -1, -2, -3, -5, -7, -9, -16, -127, 128
+};
+
+void
+negqi_global ()
+{
+  value = - value;
+}
+
+void
+negqi_ptr (signed char* p)
+{
+  *p = - *p;
+}
+
+signed char
+negqi_return (signed char v)
+{
+  return -v;
+}
+
+int
+main()
+{
+  unsigned i;
+  signed char c;
+
+  for (i = 0; i < sizeof(values) / sizeof(values[0]); i++)
+    {
+      value = values[i];
+      negqi_global ();
+      if (value != expect[i])
+        abort ();
+
+      negqi_global ();
+      if (value != values[i])
+        abort ();
+
+      c = value;
+      negqi_ptr (&c);
+      if (c != expect[i])
+        abort ();
+
+      negqi_ptr (&c);
+      if (c != values[i])
+        abort ();
+
+      c = negqi_return (c);
+      if (c != expect[i])
+        abort ();
+
+      c = negqi_return (c);
+      if (c != values[i])
+        abort ();
+    }
+  exit (0);
+}
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute-scz/orqi.c
@@ -0,0 +1,52 @@
+signed char value;
+
+signed char values[] = {
+  0,  1,  2,  3,  5,  7, 9, 16, 127, 128
+};
+
+signed char expect[] = {
+ 12, 13, 14, 15, 13, 15, 13, 28, 127, 140
+};
+
+void
+orqi_global ()
+{
+  value |= 12;
+}
+
+void
+orqi_ptr (signed char* p)
+{
+  *p |= 12;
+}
+
+signed char
+orqi_return (signed char v)
+{
+  return v | 12;
+}
+
+int
+main()
+{
+  unsigned i;
+  signed char c;
+
+  for (i = 0; i < sizeof(values) / sizeof(values[0]); i++)
+    {
+      value = values[i];
+      orqi_global ();
+      if (value != expect[i])
+        abort ();
+
+      c = values[i];
+      orqi_ptr (&c);
+      if (c != expect[i])
+        abort ();
+
+      c = orqi_return (values[i]);
+      if (c != expect[i])
+        abort ();
+    }
+  exit (0);
+}
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute-scz/pr-11741.c
@@ -0,0 +1,59 @@
+typedef short bsdstuff_size_t;
+char *strncpy(char *dst, const char *src, bsdstuff_size_t n)
+{
+  // printf("src=%s\r\n", src);
+  // printf("size=%d", n);
+  if (n != 0) {
+    char *d = dst;
+    const char *s = src;
+
+    do {
+      if ((*d++ = *s++) == 0) {
+        /* NUL pad the remaining n-1 bytes */
+        while (--n != 0)
+          *d++ = 0;
+        break;
+      }
+    } while (--n != 0);
+  }
+  //printf("dst=%s\r\n", dst);
+
+  return (dst);
+
+}
+
+static const char* strings[] = {
+  "hello world",
+  "a",
+  "bb",
+  "0123456789012234568",
+  "asfasfsgdhtrhwrthrhwvdvegqeasdfasf",
+  0
+};
+
+int
+main ()
+{
+  char buf[64];
+  char *p;
+  int i;
+
+  for (i = 0; strings[i] != 0; i++)
+    {
+      memset (buf, 1, sizeof (buf));
+      if (buf[3] != 1 || buf[12] != 1 || buf[sizeof (buf) - 1] != 1)
+        abort ();
+
+      p = strncpy (buf, strings[i], sizeof (buf));
+      if (buf[sizeof (buf) - 1] != 0)
+        abort ();
+      if (p != buf)
+        abort ();
+
+      if (buf[0] != strings[i][0])
+        abort ();
+      if (strcmp (buf, strings[i]) != 0)
+        abort ();
+    }
+  return 0;
+}
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute-scz/pr-12243.c
@@ -0,0 +1,27 @@
+static unsigned char spi_test1[256];
+
+void fnTest(void)
+{
+  unsigned short i;
+
+  for (i = 0; i < sizeof(spi_test1); i++)
+    {
+      spi_test1[i] = (unsigned char)i;
+    }
+}
+
+void main(void)
+{
+  fnTest ();
+
+  if (spi_test1[0] != 0)
+    exit (1);
+
+  if (spi_test1[1] != 1)
+    exit (2);
+
+  if (spi_test1[10] != 10)
+    exit (3);
+
+  exit (0);
+}
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute-scz/pr-12297.c
@@ -0,0 +1,50 @@
+unsigned long lsqrt (unsigned long x)
+{
+	if (x <= 1)
+		return x;
+
+	/* If 'x' is small enough, use 16-bit integers.  */
+	if ((x & 0xFFFF0000L) == 0)
+	{
+		unsigned short v0, x0, q0, x1;
+
+		v0 = (unsigned short) (x);
+		x0 = v0 / 2;
+		while (1)
+		{
+			q0 = v0 / x0;
+			x1 = (x0 + q0) / 2;
+			if (q0 >= x0)
+				break;
+			x0 = x1;
+		}
+		return (unsigned long) x1;
+	}
+	else
+	{
+		unsigned long v0, q0, x1;
+
+		v0 = x;
+		x = x / 2;
+		while (1)
+		{
+			q0 = v0 / x;
+			x1 = (x + q0) / 2;
+			if (q0 >= x)
+				break;
+			x = x1;
+		}
+		return x1;
+	}
+}
+
+int main ()
+{
+  unsigned long result = lsqrt (40);
+  if (result != 6)
+    exit (1);
+
+  return 0;
+}
+
+
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute-scz/pr-13917.c
@@ -0,0 +1,50 @@
+#include <string.h>
+
+void ltoa(char *buf, unsigned long i, int base);
+
+void ltoa(char *buf, unsigned long i, int base)
+{
+  char *s;
+#define LEN 25
+  int rem;
+  char rev[LEN+1];
+
+  if (i == 0)
+    s = "0";
+  else
+    {
+      rev[LEN] = 0;
+      s = &rev[LEN];
+      while (i)
+        {
+          rem = i % base;
+          if (rem < 10)
+            *--s = rem + '0'; // >>>>>>>> Here appears the error.
+          else
+            if (base == 16)
+              *--s = "abcdef"[rem - 10];
+          i /= base;
+        }
+    }
+  strcpy(buf, s);
+}
+
+int main()
+{
+  char buf[32];
+
+  ltoa(buf, 0x123456, 10);
+  if (strcmp(buf, "1193046") != 0)
+    return 1;
+
+  ltoa(buf, 0x2345678, 13);
+  if (strcmp(buf, "7870") != 0)
+    return 1;
+
+  ltoa(buf, 0xabcdef0, 16);
+  if (strcmp(buf, "abcdef0") != 0)
+    return 1;
+
+  /* Also check that the strcmp detects strings not equal!  */
+  return strcmp(buf, "bcde") != 0 ? 0 : 1;
+}
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute-scz/pr-15493.c
@@ -0,0 +1,57 @@
+#ifdef mc68hc1x
+/* The softregs start at address 0.  The test needs to write
+   at 0x0 to verify that the 'mebi->dirX = 0' are fixed.
+   We use this padding scratch area to make sure the soft
+   registers do not start at 0. */
+char __attribute__((section(".page0"))) scratch[0x20] = { 0 };
+#endif
+
+typedef struct
+{
+   volatile unsigned char portA;
+   volatile unsigned char  portB;
+   volatile unsigned char  dirA;
+   volatile unsigned char  dirB;
+} MEBI_Regs;
+
+void ReadExternalBus( unsigned int addr )
+{
+   MEBI_Regs *mebi = (MEBI_Regs*)0;
+
+   // Write the address to the port A and B registers
+   mebi->portB = addr;
+   mebi->portA = addr>>8;
+
+   // Change ports A and B to inputs
+   mebi->dirA = 0;
+   mebi->dirB = 0;
+}
+
+void check(MEBI_Regs* p, unsigned char a, unsigned char b)
+{
+  if (p->portA != a)
+    abort();
+  if (p->portB != b)
+    abort();
+  if (p->dirA != 0)
+    abort();
+  if (p->dirB != 0)
+    abort();
+}
+
+int main( void )
+{
+#ifdef mc68hc1x
+  char* p = (char*) 0;
+  unsigned short i;
+
+  for (i = 0x20; i > 0; i--)
+    *p++ = 0xaa;
+
+#endif
+  ReadExternalBus( 0x1000 );
+#ifdef mc68hc1x
+  check(0, 0x10, 0);
+#endif
+  return 0;
+}
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute-scz/setjmp-test.c
@@ -0,0 +1,50 @@
+#include <stdio.h>
+#include <setjmp.h>
+
+jmp_buf jbuf;
+int jret;
+
+int
+fact (int n)
+{
+  if (n <= 1)
+    {
+      if (jret)
+        longjmp (jbuf, jret);
+
+      return 1;
+    }
+  else
+    {
+      return fact (n - 1) * n;
+    }
+}
+
+int
+compute (int n)
+{
+  int result;
+
+  result = setjmp (jbuf);
+  if (result != 0)
+    return result;
+
+  result = fact (n);
+  return result * n;
+}
+
+int
+main ()
+{
+  int result;
+
+  result = compute (4);
+  if (result != 96)
+    abort ();
+
+  jret = 23;
+  result = compute (4);
+  if (result != 23)
+    abort ();
+  return 0;
+}
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/20020404-1.x
@@ -0,0 +1,6 @@
+# This test fails on HC11/HC12 when it is compiled with 16-bit integers
+# because it passes value 0x1eadbeef in an int.
+if { [istarget "m6811-*-*"] || [istarget "m6812-*-*"] } {
+    return 1
+}
+return 0
--- a/gcc/testsuite/gcc.c-torture/execute/20020720-1.x
+++ b/gcc/testsuite/gcc.c-torture/execute/20020720-1.x
@@ -29,7 +29,7 @@
     set compiler_conditional_xfail_data {
         "This test fails to optimize completely on certain platforms." \
         { "xtensa-*-*" "sh-*-*" "arm*-*-*" "strongarm*-*-*" "xscale*-*-*" \
-	  "h8300*-*-*" "x86_64-*-*" "cris-*-*" } \
+	  "h8300*-*-*" "x86_64-*-*" "cris-*-*" "m6811-*-*" "m6812-*-*" } \
         { "*" } \
         { "-O0" }
     }
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/20021024-1.x
@@ -0,0 +1,10 @@
+# 16-bit "int"
+if { [istarget "xstormy16-*"] } {
+	return 1
+}
+if { [istarget "m6811-*-*"] || [istarget "m6812-*-*"]} {
+	return 1
+}
+
+return 0
+
--- a/gcc/testsuite/gcc.c-torture/execute/960312-1.x
+++ b/gcc/testsuite/gcc.c-torture/execute/960312-1.x
@@ -2,6 +2,6 @@
 # is uses an asm that requires two 32-bit registers (int).  It passes
 # when using -mshort because there are enough registers;  force -mshort.
 if { [istarget "m6811-*-*"] || [istarget "m6812-*-*"] } {
-	set options "-mshort"
+	set additional_flags "-mshort"
 }
 return 0
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/ieee/920810-1.x
@@ -0,0 +1,7 @@
+# sprintf %g is not supported on HC11/HC12 (too big for a final link)
+if { [istarget "m6811-*-*"] || [istarget "m6812-*-*"]} {
+	return 1
+}
+
+return 0
+
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/shiftdi.x
@@ -0,0 +1,10 @@
+# 16-bit "int"
+if { [istarget "xstormy16-*"] } {
+	return 1
+}
+if { [istarget "m6811-*-*"] || [istarget "m6812-*-*"]} {
+	return 1
+}
+
+return 0
+
--- a/gcc/testsuite/gcc.dg/20001009-1.c
+++ b/gcc/testsuite/gcc.dg/20001009-1.c
@@ -1,6 +1,6 @@
 /* { dg-do compile } */
 /* { dg-options "-O2 -fpic" } */
-/* { dg-warning "not supported" "PIC unsupported" { target cris-*-elf* cris-*-aout* mmix-*-* } 0 } */
+/* { dg-warning "not supported" "PIC unsupported" { target cris-*-elf* cris-*-aout* mmix-*-* m6811-*-* m6812-*-* } 0 } */
 
 extern void foo (void *a, double x, double y);
 void
--- a/gcc/testsuite/gcc.dg/20010912-1.c
+++ b/gcc/testsuite/gcc.dg/20010912-1.c
@@ -1,6 +1,6 @@
 /* { dg-do run } */
 /* { dg-options "-O2 -fpic" } */
-/* { dg-warning "not supported" "PIC unsupported" { target cris-*-elf* cris-*-aout* mmix-*-* } 0 } */
+/* { dg-warning "not supported" "PIC unsupported" { target cris-*-elf* cris-*-aout* mmix-*-* m6811-*-* m6812-*-* } 0 } */
 
 extern void abort (void);
 extern void exit (int);
--- a/gcc/testsuite/gcc.dg/20020122-4.c
+++ b/gcc/testsuite/gcc.dg/20020122-4.c
@@ -2,7 +2,7 @@
    (mem (lo_sum pic (symbol_ref))) within an asm at the right time.  */
 /* { dg-do compile } */
 /* { dg-options "-O2 -fpic" } */
-/* { dg-warning "not supported" "PIC unsupported" { target cris-*-elf* cris-*-aout* mmix-*-* } 0 } */
+/* { dg-warning "not supported" "PIC unsupported" { target cris-*-elf* cris-*-aout* mmix-*-* m6811-*-* m6812-*-* } 0 } */
 
 void foo()
 {
--- a/gcc/testsuite/gcc.dg/20020219-1.c
+++ b/gcc/testsuite/gcc.dg/20020219-1.c
@@ -8,6 +8,7 @@
 /* { dg-do run } */
 /* { dg-options "-O2" } */
 /* { dg-options "-O2 -mdisable-indexing" { target hppa*-*-hpux* } } */
+/* { dg-options "-mshort" { target m6811-*-* m6812-*-* } } */
 
 /* Disable the test entirely for 16-bit targets.  */
 #if __INT_MAX__ > 32767
--- a/gcc/testsuite/gcc.dg/20020415-1.c
+++ b/gcc/testsuite/gcc.dg/20020415-1.c
@@ -3,7 +3,7 @@
    ASM_SIMPLIFY_DWARF_ADDR hook.  */
 /* { dg-do compile } */
 /* { dg-options "-O2 -fpic -g" } */
-/* { dg-warning "not supported" "PIC unsupported" { target cris-*-elf* mmix-*-* } 0 } */
+/* { dg-warning "not supported" "PIC unsupported" { target cris-*-elf* mmix-*-* m6811-*-* m6812-*-* } 0 } */
 
 static inline char *
 bar (unsigned long x, char *y)
--- a/gcc/testsuite/gcc.dg/20020426-2.c
+++ b/gcc/testsuite/gcc.dg/20020426-2.c
@@ -3,6 +3,7 @@
 /* { dg-do run } */
 /* { dg-options "-O2" } */
 /* { dg-options "-O2 -frename-registers -fomit-frame-pointer -fPIC -mcpu=i686" { target i?86-*-* } } */
+/* { dg-warning "not supported" "PIC unsupported" { target m6811-*-* m6812-*-* } 0 } */
 
 typedef struct
 {
--- a/gcc/testsuite/gcc.dg/20020430-1.c
+++ b/gcc/testsuite/gcc.dg/20020430-1.c
@@ -6,6 +6,7 @@
 
 /* { dg-do compile } */
 /* { dg-options "-O2 -frename-registers -fpic" } */
+/* { dg-warning "not supported" "PIC unsupported" { target m6811-*-* m6812-*-* } 0 } */
 
 typedef unsigned long XID;
 typedef XID Window;
--- a/gcc/testsuite/gcc.dg/20021014-1.c
+++ b/gcc/testsuite/gcc.dg/20021014-1.c
@@ -9,6 +9,7 @@
 /* Support for -p on irix relies on libprof1.a which doesn't appear to
    exist on any irix6 system currently posting testsuite results.  */
 /* { dg-error "libprof1.a" "Profiler support missing" { target mips*-*-irix* } 0 } */
+/* { dg-error "mcount" "Profiler support missing" { target m6811-*-* m6812-*-* } 0 } */
 
 extern void abort (void);
 extern void exit (int);
--- a/gcc/testsuite/gcc.dg/20021018-1.c
+++ b/gcc/testsuite/gcc.dg/20021018-1.c
@@ -1,5 +1,6 @@
 /* { dg-do run } */
 /* { dg-options "-O2 -fpic" } */
+/* { dg-warning "not supported" "PIC unsupported" { target m6811-*-* m6812-*-* } 0 } */
 
 extern void abort (void);
 extern void exit (int);
--- a/gcc/testsuite/gcc.dg/20021023-1.c
+++ b/gcc/testsuite/gcc.dg/20021023-1.c
@@ -2,6 +2,7 @@
    considered as local_symbolic_operand.  */
 /* { dg-do compile } */
 /* { dg-options "-O2 -fpic" } */
+/* { dg-warning "not supported" "PIC unsupported" { target m6811-*-* m6812-*-* } 0 } */
 
 typedef __builtin_va_list va_list;
 
--- a/gcc/testsuite/gcc.dg/20021029-1.c
+++ b/gcc/testsuite/gcc.dg/20021029-1.c
@@ -2,6 +2,7 @@
    variables into writable sections.  */
 /* { dg-do compile } */
 /* { dg-options "-O2 -fpic" } */
+/* { dg-warning "not supported" "PIC unsupported" { target m6811-*-* m6812-*-* } 0 } */
 /* { dg-final { scan-assembler-not ".data.rel.ro.local" } } */
 
 int foo (int a)
--- a/gcc/testsuite/gcc.dg/20021116-1.c
+++ b/gcc/testsuite/gcc.dg/20021116-1.c
@@ -1,6 +1,6 @@
 /* { dg-do compile } */
 /* { dg-options "-O2 -fpic" } */
-/* { dg-warning "not supported" "PIC unsupported" { target cris-*-elf* cris-*-aout* mmix-*-* } 0 } */
+/* { dg-warning "not supported" "PIC unsupported" { target cris-*-elf* cris-*-aout* mmix-*-* m6811-*-* m6812-*-* } 0 } */
 
 void **
 foo (void **x, int y, void *z)
--- a/gcc/testsuite/gcc.dg/20030120-1.c
+++ b/gcc/testsuite/gcc.dg/20030120-1.c
@@ -1,7 +1,7 @@
 /* PR 7154 */
 /* { dg-do compile } */
 /* { dg-options "-O -fpic" } */
-/* { dg-warning "not supported" "PIC unsupported" { target cris-*-elf* mmix-*-* } 0 } */
+/* { dg-warning "not supported" "PIC unsupported" { target cris-*-elf* mmix-*-* m6811-*-* m6812-*-* } 0 } */
 
 const int x[1]={ 1 };
 void foo(int i, int *p)
--- a/gcc/testsuite/gcc.dg/20030213-1.c
+++ b/gcc/testsuite/gcc.dg/20030213-1.c
@@ -1,7 +1,7 @@
 /* Testcase for http://gcc.gnu.org/ml/gcc-patches/2003-02/msg01017.html */
 /* { dg-do link } */
 /* { dg-options "-O -fpic" } */
-/* { dg-warning "not supported" "PIC unsupported" { target cris-*-elf* cris-*-aout* mmix-*-* } 0 } */
+/* { dg-warning "not supported" "PIC unsupported" { target cris-*-elf* cris-*-aout* mmix-*-* m6811-*-* m6812-*-* } 0 } */
 
 int *g;
 
--- a/gcc/testsuite/gcc.dg/20030225-1.c
+++ b/gcc/testsuite/gcc.dg/20030225-1.c
@@ -5,7 +5,7 @@
    and Benjamin Herrenschmidt <benh@kernel.crashing.org>.  */
 /* { dg-do run } */
 /* { dg-options "-O2 -fPIC" } */
-/* { dg-warning "not supported" "PIC unsupported" { target cris-*-elf* mmix-*-* } 0 } */
+/* { dg-warning "not supported" "PIC unsupported" { target cris-*-elf* mmix-*-* m6811-*-* m6812-*-* } 0 } */
 
 
 extern void exit (int);
--- a/gcc/testsuite/gcc.dg/inline-2.c
+++ b/gcc/testsuite/gcc.dg/inline-2.c
@@ -2,7 +2,7 @@
    it has been deferred.  */
 /* { dg-do compile } */
 /* { dg-options "-O3 -finline-limit=0 -fpic" } */
-/* { dg-warning "not supported" "PIC unsupported" { target cris-*-elf* cris-*-aout* mmix-*-* } 0 } */
+/* { dg-warning "not supported" "PIC unsupported" { target cris-*-elf* cris-*-aout* mmix-*-* m6811-*-* m6812-*-* } 0 } */
 
 static int foo(void)
 {
--- a/gcc/testsuite/gcc.dg/nest.c
+++ b/gcc/testsuite/gcc.dg/nest.c
@@ -5,6 +5,7 @@
 /* Support for -pg on irix relies on gcrt1.o which doesn't exist yet.
    See: http://gcc.gnu.org/ml/gcc/2002-10/msg00169.html */
 /* { dg-error "gcrt1.o" "Profiler support missing" { target mips*-*-irix* } 0 } */
+/* { dg-error "mcount" "Profiler support missing" { target m6811-*-* m6812-*-* } 0 } */
 /* { dg-error "-pg not supported" "Profiler support missing" { target *-*-sco3.2v5* } 0 } */
 
 long foo (long x)
--- a/gcc/testsuite/gcc.dg/noncompile/20020213-1.c
+++ b/gcc/testsuite/gcc.dg/noncompile/20020213-1.c
@@ -3,8 +3,8 @@
 typedef struct { int i; } FILE;
 typedef __SIZE_TYPE__ size_t;
 int fputs (const char *, FILE *);
-void bzero (void *, size_t);
-int bcmp (const void *, const void *, size_t);
+void bzero (void *, size_t); /* { dg-warning "conflicting types for built-in" { target m6811-*-* } } */
+int bcmp (const void *, const void *, size_t); /* { dg-warning "conflicting types for built-in" { target m6811-*-* } } */
 
 char buf[32];
 FILE *f;
--- a/gcc/testsuite/gcc.misc-tests/bprob.exp
+++ b/gcc/testsuite/gcc.misc-tests/bprob.exp
@@ -1,4 +1,4 @@
-#   Copyright (C) 2001, 2002 Free Software Foundation, Inc.
+#   Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.
 
 # This program is free software; you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
@@ -20,7 +20,9 @@
 # Some targets don't have any implementation of __bb_init_func or are
 # missing other needed machinery.
 if { [istarget mmix-*-*]
-     || [istarget cris-*-*] } {
+     || [istarget cris-*-*]
+     || [istarget m6811-*-*]
+     || [istarget m6812-*-*] } {
     return
 }
 
--- a/gcc/toplev.c
+++ b/gcc/toplev.c
@@ -3101,7 +3101,10 @@
 	setjmp_args_warning ();
     }
 
-  if (optimize)
+  /* SCz: PR target/5854, this is initializing registers by inserting
+     instructions before the prologue instructions that save incomming
+     registers.  */
+  if (optimize && 0)
     {
       if (!flag_new_regalloc && initialize_uninitialized_subregs ())
 	{
--- a/gcc/version.c
+++ b/gcc/version.c
@@ -6,7 +6,7 @@
    please modify this string to indicate that, e.g. by putting your
    organization's name in parentheses at the end of the string.  */
 
-const char version_string[] = "3.3.6";
+const char version_string[] = "3.3.6-9s12x-20120502";
 
 /* This is the location of the online document giving instructions for
    reporting bugs.  If you distribute a modified version of GCC,
